```@meta
CurrentModule = StatsModels
DocTestSetup = quote
    using StatsModels
end
```

# Modeling tabular data

Most statistical models require that data be represented as a `Matrix`-like
collection of a single numeric type.  Much of the data we want to model,
however, is **tabular data**, where data is represented as a collection of
fields with possibly heterogeneous types.  One of the primary goals of
`StatsModels` is to make it simpler to transform tabular data into matrix format
suitable for statistical modeling.

At the moment, "tabular data" means a
[Tables.jl](https://github.com/JuliaData/Tables.jl) table, which will be
materialized as a `Tables.ColumnTable` (a `NamedTuple` of column vectors).  Work
on first-class support for streaming/row-oriented tables is ongoing.

## The `@formula` DSL

StatsModels implements the [`@formula`](@ref) domain-specific language (DSL) for
describing table-to-matrix transformations.  This DSL is designed to be familiar
to users of other statistical software, while also taking advantage of Julia's
unique strengths to be fast and flexible.

A basic formula is composed of individual *terms*—symbols which refer to data
columns, or literal numbers `0` or `1`—combined by `+`, `&`, `*`, and (at the
top level) `~`.

!!! note 

    The `@formula` macro **must** be called with parentheses to ensure that
    the formula is parsed properly.

Here is an example of the `@formula` in action:

```@repl 1
using Random; Random.seed!(1); # hide
using StatsModels, DataFrames
f = @formula(y ~ 1 + a + b + c + b&c)
df = DataFrame(y = rand(9), a = 1:9, b = rand(9), c = repeat(["d","e","f"], 3))
f = apply_schema(f, schema(f, df))
response, predictors = modelcols(f, df); 
predictors
coefnames(f)
```

Let's break down the formula expression ` y ~ 1 + a + b + c + b&c`:

At the top level is the **formula separator** `~`, which separates the left-hand
(or response) variable `y` from the right-hand size (or predictor) variables on
the right `1 + a + b + c + b&c`.

The left-hand side has one term `y` which means that the resopnse variable is
the column from the data named `:y`.  The response can be accessed with the
analogous `response(f, df)` function.

The right hand side is made up of a number of different **terms**, separated by
`+`: `1 + a + b + c + b&c`.  Each term corresponds to one or more columns in the
generated model matrix: 

* The first term `1` generates a constant or "intercept" column full of `1.0`s.
* The next two terms `a` and `b` correspond to columns from the data table
  called `:a`, `:b`, which both hold numeric data (`Float64` and `Int`
  respectively).  Such **continuous terms** are converted to `Float64` and
  copied to the model matrix.
* The term `c` corresponds to the `:c` column in the table, which is _not_
  numeric, so it has been [contrast coded](@ref Modeling-categorical-data):
  there are three unique values or levels, and the default coding scheme
  ([`DummyCoding`](@ref)) generates an indicator variable for each level after
  the first (e.g., `df[:c] .== "b"` and `df[:c] .== "a"`).
* The last term `b&c` is an **interaction term**, and generates model matrix
  columns for each _pair_ of columns generated by the `b` and `c` terms.
  Columns are combined with element-wise multiplication.  Since `b` generates
  only a single column and `c` two, `b&c` generates two columns, equivalent to
  `df[:b] .* (df[:c] .== "b")` and `df[:b] .* (df[:c] .== "c")`.

Because we often want to include both "main effects" (`b` and `c`) and
interactions (`b&c`) of multiple variables, the formula DSL uses the `*`
operator to denote this:

```@repl 1
@formula(y ~ 1 + a + b*c)
```

Also note that the interaction operators `&` and `*` are distributive with the
term separator `+`:

```@repl 1
@formula(y ~ 1 + (a + b) & c)
```

## Non-DSL calls

Any calls to functions that are not built into the DSL (or part of an
[extension](@ref Internals-and-extending-the-formula-DSL) provided by a modeling
package) are treated like normal Julia code, and evaluated elementwise:

```@repl 1
modelmatrix(@formula(y ~ 1 + a + log(1+a) + length(c)), df)
```

Note that the expression `1 + a` is treated differently as part of the formula
than in the call to `log`, where it's interpreted as normal addition.

## Constructing a formula programatically

A formula can be constructed at run-time by creating `Term`s and combining them
with the formula operators `+`, `&`, and `~`:

```@repl 1
Term(:y) ~ ConstantTerm(1) + Term(:a) + Term(:b) + Term(:a) & Term(:b)
```

The [`term`](@ref) function constructs a term of the appropriate type from
symbols and numbers, which makes it easy to work with collections of mixed type:

```@repl 1
ts = term.((1, :a, :b))
```

These can then be combined with standard reduction techniques:

```@repl 1
f1 = term(:y) ~ foldl(+, ts)
f2 = term(:y) ~ sum(ts)
f1 == f2 == @formula(y ~ 1 + a + b)
```

## Fitting a model from a formula

The main use of `@formula` is to streamline specifying and fitting statistical
models based on tabular data.  From the user's perspective, this is done by
`fit` methods that take a `FormulaTerm` and a table instead of numeric
matrices.

As an example, we'll simulate some data from a linear regression model with an
interaction term, a continuous predictor, a categorical predictor, and the
interaction of the two, and then fit a `GLM.LinearModel` to recover the
simulated coefficients.

```@repl 1
using GLM, DataFrames, StatsModels
data = DataFrame(a = rand(100), b = repeat(["d", "e", "f", "g"], 25));
X = modelmatrix(@formula(y ~ 1 + a*b).rhs, data);
β_true = 1:8;
ϵ = randn(100)*0.1;
data[:y] = X*β_true .+ ϵ;
mod = fit(LinearModel, @formula(y ~ 1 + a*b), data)
```

Internally, this is accomplished in three steps:

1. The expression passed to `@formula` is lowered to term constructors combined
   by `~`, `+`, and `&`, which evaluate to create terms for the whole formula
   and any interaction terms.
2. A schema is extracted from the data, which determines whether each variable
   is continuous or categorical and extracts the summary statistics of each
   variable (mean/variance/min/max or unique levels respectively).  This schema
   is then _applied_ to the formula with `apply_schema(term, schema,
   ::Type{Model})`, which returns a new formula with each placeholder `Term`
   replaced with a concrete `ContinuousTerm` or `CategoricalTerm` as
   appropriate.  This is also the stage where any custom syntax is applied (see
   [the section on extending the `@formula`
   DSL](@ref Internals-and-extending-the-formula-DSL) for more details).
3. Numeric arrays are generated for the response and predictors from the full
   table using `modelcols(term, data)`.

The `ModelFrame` and `ModelMatrix` types can still be used to do this
transformation, but this is only to preserve some backwards compatibility.
Package authors who would like to include support for fitting models from a
`@formula` are **strongly** encouraged to directly use `schema`, `apply_schema`,
and `modelcols` to handle the table-to-matrix transformations they need.
