```@meta
CurrentModule = StatsModels
DocTestSetup = quote
    using StatsModels
end
```

# Modeling tabular data

Most statistical models require that data be represented as a `Matrix`-like
collection of a single numeric type.  Much of the data we want to model,
however, is **tabular data**, where data is represented as a collection of
fields with possibly heterogeneous types.  One of the primary goals of
`StatsModels` is to make it simpler to transform tabular data into matrix format
suitable for statistical modeling.

At the moment, "tabular data" means a
[Tables.jl](https://github.com/JuliaData/Tables.jl) table, which will be
materialized as a `Tables.ColumnTable` (a `NamedTuple` of column vectors).  Work
on first-class support for streaming/row-oriented tables is ongoing.

## The `@formula` DSL

StatsModels implements the `@formula` domain-specific language (DSL) for
describing table-to-matrix transformations.  This DSL is designed to be familiar
to users of other statistical software, while also taking advantage of Julia's
unique strengths to be fast and flexible.

A basic formula is composed of individual *terms*—symbols which refer to data
columns, or literal numbers `0` or `1`—combined by `+`, `&`, `*`, and (at the
top level) `~`.

!!! note 

    The `@formula` macro **must** be called with parentheses to ensure that
    the formula is parsed properly.

### An example

```jldoctest
julia> using StatsModels, DataFrames

julia> f = @formula(y ~ 1 + a + b + c + b&c)
y ~ 1 + a + b + c + b&c

julia> df = DataFrame(y = rand(9), a = [1:9;], b = rand(9), c = repeat(["a","b","c"], 3))
9×4 DataFrame
│ Row │ y         │ a     │ b        │ c      │
│     │ Float64   │ Int64 │ Float64  │ String │
├─────┼───────────┼───────┼──────────┼────────┤
│ 1   │ 0.633146  │ 1     │ 0.537954 │ a      │
│ 2   │ 0.254722  │ 2     │ 0.852915 │ b      │
│ 3   │ 0.231935  │ 3     │ 0.743751 │ c      │
│ 4   │ 0.38103   │ 4     │ 0.209199 │ a      │
│ 5   │ 0.705814  │ 5     │ 0.162384 │ b      │
│ 6   │ 0.836353  │ 6     │ 0.690534 │ c      │
│ 7   │ 0.683606  │ 7     │ 0.845915 │ a      │
│ 8   │ 0.0524241 │ 8     │ 0.357598 │ b      │
│ 9   │ 0.735718  │ 9     │ 0.124941 │ c      │

julia> model_matrix(f, df)
9×7 Array{Float64,2}:
 1.0  1.0  0.537954  0.0  0.0  0.0       0.0     
 1.0  2.0  0.852915  1.0  0.0  0.852915  0.0     
 1.0  3.0  0.743751  0.0  1.0  0.0       0.743751
 1.0  4.0  0.209199  0.0  0.0  0.0       0.0     
 1.0  5.0  0.162384  1.0  0.0  0.162384  0.0     
 1.0  6.0  0.690534  0.0  1.0  0.0       0.690534
 1.0  7.0  0.845915  0.0  0.0  0.0       0.0     
 1.0  8.0  0.357598  1.0  0.0  0.357598  0.0     
 1.0  9.0  0.124941  0.0  1.0  0.0       0.124941
```

Let's break down the formula expression ` y ~ 1 + a + b + c + b&c`:

* At the top level is the **formula separator** `~`, which separates the
  response variables on the left from the predictor variables on the right
* On the left is `y`, which means that the resopnse variable is the column from
  the data named `:y` (this can be accessed with the analogous `model_response`
  function)
* The right hand side `1 + a + b + c + b&c` is made up of a number of different
  **terms**, separated by `+`.
* The first term `1` generates a constant or "intercept" column in the model
  matrix.
* The next three terms `a + b + c` correspond, like the right-hand side term
  `y`, to columns from the data table called `:a`, `:b`, and `:c`.
    * The `:a` and `:b` columns are both numeric, so they're treated as
      **continuous variables** and simply converted to `Float64` and copied to
      the model matrix.
    * The `:c` column contains `String` elements, so it has been [contrast
      coded](): there are three unique values or levels, and the default coding
      scheme (`DummyCoding()`) generates an indicator variable for each level
      after the first (e.g., `df[:c] .== "b"` and `df[:c] .== "a"`).
* The last term `b&c` is an **interaction term**, and generates model matrix
  columns for each _pair_ of columns generated by the `b` and `c` terms.
  Columns are combined with elementwise multiplication.  Since `b` generates
  only a single column and `c` two, `b&c` generates two columns, equivalent to
  `df[:b] .* (df[:c] .== "b")` and `df[:b] .* (df[:c] .== "c")`.

Because we often want to include both "main effects" (`b` and `c`) and
interactions (`b&c`) of multiple variables, the formula DSL uses the `*`
operator to denote this:

```jldoctest
julia> @formula(y ~ 1 + a + b*c)
y ~ 1 + a + b + c + b&c
```

Also note that the interaction operators `&` and `*` are distributive with the
term separator `+`:

```jldoctest
julia> @formula(y ~ 1 + (a + b) & c)
y ~ 1 + a&c + b&c
```

## Non-DSL calls

Any calls to functions that are not built into the DSL (or part of an
[extension]() provided by a modeling package) are treated like normal Julia
code, and evaluated elementwise:

```jldoctest
julia> model_matrix(@formula(y ~ 1 + a + log(1+a) + length(c)), df)
9×4 Array{Float64,2}:
 1.0  1.0  0.693147  1.0
 1.0  2.0  1.09861   1.0
 1.0  3.0  1.38629   1.0
 1.0  4.0  1.60944   1.0
 1.0  5.0  1.79176   1.0
 1.0  6.0  1.94591   1.0
 1.0  7.0  2.07944   1.0
 1.0  8.0  2.19722   1.0
 1.0  9.0  2.30259   1.0
```

Note that the expression `1 + a` is treated differently as part of the formula
then in the call to `log`, where it's interpreted as normal addition.

## The lifecycle of a `@formula`

The `model_matrix` function used in the example above hides a lot of important
internal details.  A formula goes through a number of stages, starting as an
expression that's passed to the `@formula` macro and ending up generating a
numeric matrix when ultimately combined with a tabular data source:

1. "Macro time" when only the surface syntax is available
2. "Schema time" incorporates information about **data invariants** (types of each
   variable, levels of categorical variables, summary statistics for continuous
   variables) and the **model type**.
3. "Data time" when the actual data values themselves are available.

For in-memory (columnar) tables, there is not much difference between "data
time" and "schema time" in practice, but in principle it's important to
distinguish between these when dealing with truly streaming data, or large data
stores where calculating invariants of the data may be expensive.

### Macro time

The `@formula` macro does syntactic transformations of the formula expression.
At this point, _only_ the expression itself is available, and there's no way to
know whether a term corresponds to a continuous or categorical variable.

For standard formulae, this amounts to applying the syntactic rules for the DSL
operators (expanding `*` and applying the distributive and associative rules),
and wrapping each symbol in a `Term` constructor:

```julia
julia> @macroexpand @formula(y ~ 1 + a*b)
:(Term(:y) ~ ConstantTerm(1) + Term(:a) + Term(:b) + Term(:a) & Term(:b))
```

Calling this stage "macro time" is a bit of a misnormer because much of the
action happens when the expression returned by the `@formula` macro is
evaluated.  At this point, the `Term`s are combined to create higher-order terms
via overloaded methods for `~`, `+`, and `&`:

```julia
julia> dump(Term(:a) & Term(:b))
InteractionTerm{Tuple{Term,Term}}
  terms: Tuple{Term,Term}
    1: Term
      sym: Symbol a
    2: Term
      sym: Symbol b

julia> dump(Term(:a) + Term(:b))
Tuple{Term,Term}
  1: Term
    sym: Symbol a
  2: Term
    sym: Symbol b

julia> dump(Term(:y) ~ Term(:a))
FormulaTerm{Term,Term}
  lhs: Term
    sym: Symbol y
  rhs: Term
    sym: Symbol a
```

!!! note
    
    As always, you can introspect which method is called with

    ```julia
    julia> @which Term(:a) & Term(:b)
    &(terms::AbstractTerm...) in StatsModels at /home/dave/.julia/dev/StatsModels/src/terms.jl:224
    ```

The reason that the actual construction of higher-order terms is done after the
macro is expanded is that it makes it much easier to create a formula
programatically:

```julia
julia> f = Term(:y) ~ sum(Term(s) for s in [:a, :b, :c])
y ~ a + b + c

julia> f == @formula(y ~ a + b + c)
true
```

The major exception to this is that non-DSL calls **must** be specified using
the `@formula` macro.  The reason for this is that non-DSL calls are "captured"
and turned into anonymous functions that can be evaluated elementwise, which has
to happen at compile time.  For instance, the call to `log` in `@formula(y ~
log(a+b))` is converted into the anonymous function `(a,b) -> log(a+b)`.

### Schema time

A formula has a left side and a right side, separated by `~`:

```jldoctest
julia> @formula(y ~ 1 + a)
Formula: y ~ 1 + a
```

!!! note 

    The `@formula` macro **must** be called with parentheses to ensure that
    the formula is parsed properly.

The left side of a formula conventionally represents *dependent* variables, and
the right side *independent* variables (or predictors/regressors).  *Terms* are
separated by `+`.  Basic terms are the integers `1` or `0`—evaluated as the
presence or absence of a constant intercept term, respectively—and variables
like `x`, which will evaluate to the data source column with that name as a
symbol (`:x`).

Individual variables can be combined into *interaction terms* with `&`, as in
`a&b`, which will evaluate to the product of the columns named `:a` and `:b`.
If either `a` or `b` are categorical, then the interaction term `a&b` generates
all the product of each pair of the columns of `a` and `b`.

It's often convenient to include main effects and interactions for a number of
variables.  The `*` operator does this, expanding in the following way:

```jldoctest
julia> @formula(y ~ 1 + a*b)
Formula: y ~ 1 + a + b + a & b
```

(We trigger parsing of the formula using the internal `Terms` type to show how
the `Formula` expands).

This applies to higher-order interactions, too: `a*b*c` expands to the main
effects, all two-way interactions, and the three way interaction `a&b&c`:

```jldoctest
julia> @formula(y ~ 1 + a*b*c)
Formula: y ~ 1 + a + b + c + a & b + a & c + b & c + &(a, b, c)
```

Both the `*` and the `&` operators act like multiplication, and are distributive
over addition:

```jldoctest
julia> @formula(y ~ 1 + (a+b) & c)
Formula: y ~ 1 + a & c + b & c

julia> @formula(y ~ 1 + (a+b) * c)
Formula: y ~ 1 + a + b + c + a & c + b & c
```

### Calls to non-DSL functions

Whenever the `@formula` macro encounters a call to a non-DSL function (e.g.,
anything other than `~`, `+`, `&`, or `*`), it "captures" it as a
`FunctionTerm`.  

### Constructing a formula programmatically

A basic formula consists of individual terms bound together with `+`, `&`, and
(at the highest level) `~`.  There are two basic kinds of terms: a
`ConstantTerm` represents a constant value (like a literal number), while a
`Term` represents a placeholder variable that names a table column.  You can
inspect the expression that is generated and evaluated by the `@formula` macro
with `@macroexpand`:

```jldoctest
julia> @macroexpand(@formula(y ~ 1 + a))
:((StatsModels.Term)(:y) ~ (StatsModels.ConstantTerm)(1) + (StatsModels.Term)(:a))

julia> @macroexpand(@formula(y ~ a*b))
:((StatsModels.Term)(:y) ~ (StatsModels.Term)(:a) + (StatsModels.Term)(:b) + (StatsModels.Term)(:a) & (StatsModels.Term)(:b))
```

Constructing formulae programmatically is thus straightforward: wrap each symbol
referring to columns in a `Term` and combine them using the same operators.

```jldoctest
julia> f = Term(:y) ~ ConstantTerm(1) + Term(:a)

julia> f == @formula(y ~ 1 + a)
```

The `term` function is provided as a convenience and generates a `Term` for
`Symbol` arguments and a `ConstantTerm` for numeric arguments.  This is
convenient if you have a vector of numbers (for an intercept) and symbols:

```jldoctest
julia> rhs = [1, :a, :b]

julia> f = term(:y) ~ (+)(term.(rhs)...) # or use sum

julia> f == @formula(y ~ 1 + a + b)
```

Note that at this stage, none of the syntactic transformations of the
`@formula` macro will be applied, so any interactions will need to be spelled
out in full:

```jldoctest
julia> term(:a) * term(:b)
ERROR: MethodError: no method matching *(::Term, ::Term)
Closest candidates are:
  *(::Any, ::Any, ::Any, ::Any...) at operators.jl:502
Stacktrace:
 [1] top-level scope at none:0

julia> term(:a) + term(:b) + term(:a)&term(:b)
a + b + a&b
```

Moreover, no non-DSL calls will be captured.

Because a `Formula` is created at compile time with the `@formula` macro,
creating one programmatically means dipping into Julia's
[metaprogramming](https://docs.julialang.org/en/latest/manual/metaprogramming/)
facilities.

Let's say you have a variable `lhs`:

```jldoctest
julia> lhs = :y
:y
```

and you want to create a formula whose left-hand side is the _value_ of `lhs`,
as in

```jldoctest
julia> @formula(y ~ 1 + x)
Formula: y ~ 1 + x
```

Simply using the Julia interpolation syntax `@formula($lhs ~ 1 + x)` won't work,
because `@formula` runs _at compile time_, before anything about the value of
`lhs` is known.  Instead, you need to construct and evaluate the _correct call_
to `@formula`.  The most concise way to do this is with `@eval`:

```jldoctest
julia> @eval @formula($lhs ~ 1 + x)
Formula: y ~ 1 + x
```

The `@eval` macro does two very different things in a single, convenient step:

1. Generate a _quoted expression_ using `$`-interpolation to insert the run-time
   value of `lhs` into the call to the `@formula` macro.
2. Evaluate this expression using `eval`.

An equivalent but slightly more verbose way of doing the same thing is:

```jldoctest
julia> formula_ex = :(@formula($lhs ~ 1 + x))
:(@formula y ~ 1 + x)

julia> eval(formula_ex)
Formula: y ~ 1 + x
```

### Technical details

You may be wondering why formulas in Julia require a macro, while in R they
appear "bare."  R supports nonstandard evaluation, allowing the formula to
remain an unevaluated object while its terms are parsed out. Julia uses a much
more standard evaluation mechanism, making this impossible using normal
expressions. However, unlike R, Julia provides macros to explicitly indicate
when code itself will be manipulated before it's evaluated. By constructing a
formula using a macro, we're able to provide convenient, R-like syntax and
semantics.

The formula syntactic transformations are applied _at parse time_ when using the
`@formula` macro.  You can see this with using `@macroexpand`:

```jldoctest
@macroexpand @formula y ~ 1 + (a+b)*c
:((StatsModels.Formula)($(Expr(:copyast, :($(QuoteNode(:(y ~ 1 + (a + b) * c)))))), $(Expr(:copyast, :($(QuoteNode(:(y ~ 1 + a + b + c + a & c + b & c)))))), :y, $(Expr(:copyast, :($(QuoteNode(:(1 + a + b + c + a & c + b & c))))))))
```
Or more legibly
```julia
:((StatsModels.Formula)($(Expr(:copyast, :($(QuoteNode(:(y ~ 1 + (a + b) * c)))))),
                        $(Expr(:copyast, :($(QuoteNode(:(y ~ 1 + a + b + c + a & c + b & c)))))),
                        :y,
                        $(Expr(:copyast, :($(QuoteNode(:(1 + a + b + c + a & c + b & c))))))))
```

The `@formula` macro re-writes the formula expression `y ~ 1 + (a+b)*c` as a
call to the `Formula` constructor.  The arguments of the constructor correspond
to the fields of the `Formula` struct, which are, in order:

* `ex_orig`: the original expression `:(y ~ 1+(a+b)*c)`
* `ex`: the parsed expression `:(y ~ 1+a+b+a&c+b&c)`
* `lhs`: the left-hand side `:y`
* `rhs`: the right-hand side `:(1+a+b+a&c+b&c)`

```@docs
Formula
dropterm
```

## The `ModelFrame` and `ModelMatrix` types

The main use of `Formula`s is for fitting statistical models based on tabular
data.  From the user's perspective, this is done by `fit` methods that take a
`Formula` and a `DataFrame` instead of numeric matrices.

Internally, this is accomplished in three stages:

1. The `Formula` is parsed into [`Terms`](@ref).
2. The `Terms` and the data source are wrapped in a [`ModelFrame`](@ref).
3. A numeric [`ModelMatrix`](@ref) is generated from the `ModelFrame` and passed to the
   model's `fit` method.

```@docs
ModelFrame
ModelMatrix
```
