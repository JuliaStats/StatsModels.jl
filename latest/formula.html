<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modeling tabular data · StatsModels.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>StatsModels.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction</a></li><li class="current"><a class="toctext" href="formula.html">Modeling tabular data</a><ul class="internal"><li><a class="toctext" href="#The-Formula-type-1">The <code>Formula</code> type</a></li><li><a class="toctext" href="#The-ModelFrame-and-ModelMatrix-types-1">The <code>ModelFrame</code> and <code>ModelMatrix</code> types</a></li></ul></li><li><a class="toctext" href="contrasts.html">Contrast coding categorical variables</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="formula.html">Modeling tabular data</a></li></ul><a class="edit-page" href="https://github.com/JuliaStats/StatsModels.jl/blob/master/docs/src/formula.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Modeling tabular data</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Modeling-tabular-data-1" href="#Modeling-tabular-data-1">Modeling tabular data</a></h1><p>Most statistical models require that data be represented as a <code>Matrix</code>-like collection of a single numeric type.  Much of the data we want to model, however, is <strong>tabular data</strong>, where data is represented as a collection of fields with possibly heterogeneous types.  One of the primary goals of <code>StatsModels</code> is to make it simpler to transform tabular data into matrix format suitable for statistical modeling.</p><p>At the moment, &quot;tabular data&quot; means an <code>AbstractDataFrame</code>.  Ultimately, the goal is to support any tabular data format that adheres to a minimal API, <strong>regardless of backend</strong>.</p><h2><a class="nav-anchor" id="The-Formula-type-1" href="#The-Formula-type-1">The <code>Formula</code> type</a></h2><p>The basic conceptual tool for this is the <code>Formula</code>, which has a left side and a right side, separated by <code>~</code>. Formulas are constructed using the <code>@formula</code> macro:</p><pre><code class="language-julia-repl">julia&gt; @formula(y ~ 1 + a)
Formula: y ~ 1 + a</code></pre><p>Note that the <code>@formula</code> macro <strong>must</strong> be called with parentheses to ensure that the formula is parsed properly.</p><p>The left side of a formula conventionally represents <em>dependent</em> variables, and the right side <em>independent</em> variables (or regressors).  <em>Terms</em> are separated by <code>+</code>.  Basic terms are the integers <code>1</code> or <code>0</code>—evaluated as the presence or absence of a constant intercept term, respectively—and variables like <code>x</code>, which will evaluate to the data source column with that name as a symbol (<code>:x</code>).</p><p>Individual variables can be combined into <em>interaction terms</em> with <code>&amp;</code>, as in <code>a&amp;b</code>, which will evaluate to the product of the columns named <code>:a</code> and <code>:b</code>. If either <code>a</code> or <code>b</code> are categorical, then the interaction term <code>a&amp;b</code> generates all the product of each pair of the columns of <code>a</code> and <code>b</code>.</p><p>It&#39;s often convenient to include main effects and interactions for a number of variables.  The <code>*</code> operator does this, expanding in the following way:</p><pre><code class="language-julia-repl">julia&gt; Formula(StatsModels.Terms(@formula(y ~ 1 + a*b)))
Formula: y ~ 1 + a + b + a &amp; b</code></pre><p>(We trigger parsing of the formula using the internal <code>Terms</code> type to show how the <code>Formula</code> expands).</p><p>This applies to higher-order interactions, too: <code>a*b*c</code> expands to the main effects, all two-way interactions, and the three way interaction <code>a&amp;b&amp;c</code>:</p><pre><code class="language-julia-repl">julia&gt; Formula(StatsModels.Terms(@formula(y ~ 1 + a*b*c)))
Formula: y ~ 1 + a + b + c + a &amp; b + a &amp; c + b &amp; c + &amp;(a, b, c)</code></pre><p>Both the <code>*</code> and the <code>&amp;</code> operators act like multiplication, and are distributive over addition:</p><pre><code class="language-julia-repl">julia&gt; Formula(StatsModels.Terms(@formula(y ~ 1 + (a+b) &amp; c)))
Formula: y ~ 1 + a &amp; c + b &amp; c

julia&gt; Formula(StatsModels.Terms(@formula(y ~ 1 + (a+b) * c)))
Formula: y ~ 1 + a + b + c + a &amp; c + b &amp; c</code></pre><h3><a class="nav-anchor" id="Constructing-a-formula-programmatically-1" href="#Constructing-a-formula-programmatically-1">Constructing a formula programmatically</a></h3><p>Because a <code>Formula</code> is created at compile time with the <code>@formula</code> macro, creating one programmatically means dipping into Julia&#39;s <a href="https://docs.julialang.org/en/latest/manual/metaprogramming/">metaprogramming</a> facilities.</p><p>Let&#39;s say you have a variable <code>lhs</code>:</p><pre><code class="language-julia-repl">julia&gt; lhs = :y
:y</code></pre><p>and you want to create a formula whose left-hand side is the _value_ of <code>lhs</code>, as in</p><pre><code class="language-julia-repl">julia&gt; @formula(y ~ 1 + x)
Formula: y ~ 1 + x</code></pre><p>Simply using the Julia interpolation syntax <code>@formula($lhs ~ 1 + x)</code> won&#39;t work, because <code>@formula</code> runs _at compile time_, before anything about the value of <code>lhs</code> is known.  Instead, you need to construct and evaluate the _correct call_ to <code>@formula</code>.  The most concise way to do this is with <code>@eval</code>:</p><pre><code class="language-julia-repl">julia&gt; @eval @formula($lhs ~ 1 + x)
Formula: y ~ 1 + x</code></pre><p>The <code>@eval</code> macro does two very different things in a single, convenient step:</p><ol><li><p>Generate a _quoted expression_ using <code>$</code>-interpolation to insert the run-time value of <code>lhs</code> into the call to the <code>@formula</code> macro.</p></li><li><p>Evaluate this expression using <code>eval</code>.</p></li></ol><p>An equivalent but slightly more verbose way of doing the same thing is:</p><pre><code class="language-julia-repl">julia&gt; formula_ex = :(@formula($lhs ~ 1 + x))
:(@formula y ~ 1 + x)

julia&gt; eval(formula_ex)
Formula: y ~ 1 + x</code></pre><h3><a class="nav-anchor" id="Technical-details-1" href="#Technical-details-1">Technical details</a></h3><p>You may be wondering why formulas in Julia require a macro, while in R they appear &quot;bare.&quot;  R supports nonstandard evaluation, allowing the formula to remain an unevaluated object while its terms are parsed out. Julia uses a much more standard evaluation mechanism, making this impossible using normal expressions. However, unlike R, Julia provides macros to explicitly indicate when code itself will be manipulated before it&#39;s evaluated. By constructing a formula using a macro, we&#39;re able to provide convenient, R-like syntax and semantics.</p><p>The formula syntactic transformations are applied _at parse time_ when using the <code>@formula</code> macro.  You can see this with using <code>@macroexpand</code>:</p><pre><code class="language-julia">@macroexpand @formula y ~ 1 + (a+b)*c
:((StatsModels.Formula)($(Expr(:copyast, :($(QuoteNode(:(y ~ 1 + (a + b) * c)))))), $(Expr(:copyast, :($(QuoteNode(:(y ~ 1 + a + b + c + a &amp; c + b &amp; c)))))), :y, $(Expr(:copyast, :($(QuoteNode(:(1 + a + b + c + a &amp; c + b &amp; c))))))))</code></pre><p>Or more legibly</p><pre><code class="language-julia">:((StatsModels.Formula)($(Expr(:copyast, :($(QuoteNode(:(y ~ 1 + (a + b) * c)))))),
                        $(Expr(:copyast, :($(QuoteNode(:(y ~ 1 + a + b + c + a &amp; c + b &amp; c)))))),
                        :y,
                        $(Expr(:copyast, :($(QuoteNode(:(1 + a + b + c + a &amp; c + b &amp; c))))))))</code></pre><p>The <code>@formula</code> macro re-writes the formula expression <code>y ~ 1 + (a+b)*c</code> as a call to the <code>Formula</code> constructor.  The arguments of the constructor correspond to the fields of the <code>Formula</code> struct, which are, in order:</p><ul><li><p><code>ex_orig</code>: the original expression <code>:(y ~ 1+(a+b)*c)</code></p></li><li><p><code>ex</code>: the parsed expression <code>:(y ~ 1+a+b+a&amp;c+b&amp;c)</code></p></li><li><p><code>lhs</code>: the left-hand side <code>:y</code></p></li><li><p><code>rhs</code>: the right-hand side <code>:(1+a+b+a&amp;c+b&amp;c)</code></p></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.Formula" href="#StatsModels.Formula"><code>StatsModels.Formula</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">Formula(t::Terms)</code></pre><p>Reconstruct a Formula from Terms.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/73c21ac797e07b725efb0d19b49c9c9f5d56ae88/src/formula.jl#L347-L351">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.dropterm" href="#StatsModels.dropterm"><code>StatsModels.dropterm</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">dropterm(f::Formula, trm::Symbol)</code></pre><p>Return a copy of <code>f</code> without the term <code>trm</code>.</p><p><strong>Examples</strong></p><pre><code class="language-jl">julia&gt; dropterm(@formula(foo ~ 1 + bar + baz), :bar)
Formula: foo ~ 1 + baz

julia&gt; dropterm(@formula(foo ~ 1 + bar + baz), 1)
Formula: foo ~ 0 + bar + baz</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/73c21ac797e07b725efb0d19b49c9c9f5d56ae88/src/formula.jl#L368-L381">source</a></section><h2><a class="nav-anchor" id="The-ModelFrame-and-ModelMatrix-types-1" href="#The-ModelFrame-and-ModelMatrix-types-1">The <code>ModelFrame</code> and <code>ModelMatrix</code> types</a></h2><p>The main use of <code>Formula</code>s is for fitting statistical models based on tabular data.  From the user&#39;s perspective, this is done by <code>fit</code> methods that take a <code>Formula</code> and a <code>DataFrame</code> instead of numeric matrices.</p><p>Internally, this is accomplished in three stages:</p><ol><li><p>The <code>Formula</code> is parsed into <a href="formula.html#StatsModels.Terms"><code>Terms</code></a>.</p></li><li><p>The <code>Terms</code> and the data source are wrapped in a <a href="formula.html#StatsModels.ModelFrame"><code>ModelFrame</code></a>.</p></li><li><p>A numeric <a href="formula.html#StatsModels.ModelMatrix"><code>ModelMatrix</code></a> is generated from the <code>ModelFrame</code> and passed to the model&#39;s <code>fit</code> method.</p></li></ol><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.ModelFrame" href="#StatsModels.ModelFrame"><code>StatsModels.ModelFrame</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Wrapper which combines Formula (Terms) and an AbstractDataFrame</p><p>This wrapper encapsulates all the information that&#39;s required to transform data of the same structure as the wrapped data frame into a model matrix.  This goes above and beyond what&#39;s expressed in the <code>Formula</code> itself, for instance including information on how each categorical variable should be coded.</p><p>Creating a <code>ModelFrame</code> first parses the <code>Formula</code> into <code>Terms</code>, checks which variables are categorical and determines the appropriate contrasts to use, and then creates the necessary contrasts matrices and stores the results.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">ModelFrame(f::Formula, df::AbstractDataFrame; contrasts::Dict = Dict())
ModelFrame(ex::Expr, d::AbstractDataFrame; contrasts::Dict = Dict())
ModelFrame(terms::Terms, df::AbstractDataFrame; contrasts::Dict = Dict())
# Inner constructors:
ModelFrame(df::AbstractDataFrame, terms::Terms, missing::BitArray)
ModelFrame(df::AbstractDataFrame, terms::Terms, missing::BitArray, contrasts::Dict{Symbol, ContrastsMatrix})</code></pre><p><strong>Arguments</strong></p><ul><li><p><code>f::Formula</code>: Formula whose left hand side is the <em>response</em> and right hand side are the <em>predictors</em>.</p></li><li><p><code>df::AbstractDataFrame</code>: The data being modeled.  This is used at this stage to determine which variables are categorical, and otherwise held for <a href="formula.html#StatsModels.ModelMatrix"><code>ModelMatrix</code></a>.</p></li><li><p><code>contrasts::Dict</code>: An optional Dict of contrast codings for each categorical variable.  Any unspecified variables will have <a href="contrasts.html#StatsModels.DummyCoding"><code>DummyCoding</code></a>.  As a keyword argument, these can be either instances of a subtype of <a href="contrasts.html#StatsModels.AbstractContrasts"><code>AbstractContrasts</code></a>, or a <a href="contrasts.html#StatsModels.ContrastsMatrix"><code>ContrastsMatrix</code></a>.  For the inner constructor, they must be <a href="contrasts.html#StatsModels.ContrastsMatrix"><code>ContrastsMatrix</code></a>es.</p></li><li><p><code>ex::Expr</code>: An expression which will be converted into a <code>Formula</code>.</p></li><li><p><code>terms::Terms</code>: For inner constructor, the parsed <code>Terms</code> from the <code>Formula</code>.</p></li><li><p><code>missing::BitArray</code>: For inner constructor, indicates whether each row of <code>df</code> contains any missing data.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = DataFrame(x = 1:4, y = 5:9)
julia&gt; mf = ModelFrame(y ~ 1 + x, df)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/73c21ac797e07b725efb0d19b49c9c9f5d56ae88/src/modelframe.jl#L1-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.ModelMatrix" href="#StatsModels.ModelMatrix"><code>StatsModels.ModelMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Convert a <code>ModelFrame</code> into a numeric matrix suitable for modeling</p><p><strong>Constructors</strong></p><pre><code class="language-julia">ModelMatrix(mf::ModelFrame)
# Specify the type of the resulting matrix (default Matrix{Float64})
ModelMatrix{T &lt;: AbstractFloatMatrix}(mf::ModelFrame)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/73c21ac797e07b725efb0d19b49c9c9f5d56ae88/src/modelmatrix.jl#L4-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.Terms" href="#StatsModels.Terms"><code>StatsModels.Terms</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Representation of parsed <code>Formula</code></p><p>This is an internal type whose implementation is likely to change in the near future.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/73c21ac797e07b725efb0d19b49c9c9f5d56ae88/src/formula.jl#L83-L88">source</a></section><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="contrasts.html"><span class="direction">Next</span><span class="title">Contrast coding categorical variables</span></a></footer></article></body></html>
