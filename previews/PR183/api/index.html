<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API documentation · StatsModels.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">StatsModels.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../formula/">Modeling tabular data</a></li><li><a class="tocitem" href="../internals/">Internals and extending the <code>@formula</code></a></li><li><a class="tocitem" href="../contrasts/">Contrast coding categorical variables</a></li><li><a class="tocitem" href="../temporal_terms/">Temporal variables and Time Series Terms</a></li><li class="is-active"><a class="tocitem" href>API documentation</a><ul class="internal"><li><a class="tocitem" href="#Formulae-and-terms"><span>Formulae and terms</span></a></li><li><a class="tocitem" href="#Schema"><span>Schema</span></a></li><li><a class="tocitem" href="#Modeling"><span>Modeling</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaStats/StatsModels.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="StatsModels.jl-API"><a class="docs-heading-anchor" href="#StatsModels.jl-API">StatsModels.jl API</a><a id="StatsModels.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#StatsModels.jl-API" title="Permalink"></a></h1><h2 id="Formulae-and-terms"><a class="docs-heading-anchor" href="#Formulae-and-terms">Formulae and terms</a><a id="Formulae-and-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Formulae-and-terms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StatsModels.@formula" href="#StatsModels.@formula"><code>StatsModels.@formula</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@formula(ex)</code></pre><p>Capture and parse a formula expression as a <code>Formula</code> struct.</p><p>A formula is an abstract specification of a dependence between <em>left-hand</em> and <em>right-hand</em> side variables as in, e.g., a regression model.  Each side specifies at a high level how tabular data is to be converted to a numerical matrix suitable for modeling.  This specification looks something like Julia code, is represented as a Julia <code>Expr</code>, but uses special syntax.  The <code>@formula</code> macro takes an expression like <code>y ~ 1 + a*b</code>, transforms it according to the formula syntax rules into a lowered form (like <code>y ~ 1 + a + b + a&amp;b</code>), and constructs a <code>Formula</code> struct which captures the original expression, the lowered expression, and the left- and right-hand-side.</p><p>Operators that have special interpretations in this syntax are</p><ul><li><code>~</code> is the formula separator, where it is a binary operator (the first argument is the left-hand side, and the second is the right-hand side.</li><li><code>+</code> concatenates variables as columns when generating a model matrix.</li><li><code>&amp;</code> representes an <em>interaction</em> between two or more variables, which corresponds to a row-wise kronecker product of the individual terms (or element-wise product if all terms involved are continuous/scalar).</li><li><code>*</code> expands to all main effects and interactions: <code>a*b</code> is equivalent to <code>a+b+a&amp;b</code>, <code>a*b*c</code> to <code>a+b+c+a&amp;b+a&amp;c+b&amp;c+a&amp;b&amp;c</code>, etc.</li><li><code>1</code>, <code>0</code>, and <code>-1</code> indicate the presence (for <code>1</code>) or absence (for <code>0</code> and <code>-1</code>) of an intercept column.</li></ul><p>The rules that are applied are</p><ul><li>The associative rule (un-nests nested calls to <code>+</code>, <code>&amp;</code>, and <code>*</code>).</li><li>The distributive rule (interactions <code>&amp;</code> distribute over concatenation <code>+</code>).</li><li>The <code>*</code> rule expands <code>a*b</code> to <code>a+b+a&amp;b</code> (recursively).</li><li>Subtraction is converted to addition and negation, so <code>x-1</code> becomes <code>x + -1</code> (applies only to subtraction of literal 1).</li><li>Single-argument <code>&amp;</code> calls are stripped, so <code>&amp;(x)</code> becomes the main effect <code>x</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/formula.jl#L23-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.term" href="#StatsModels.term"><code>StatsModels.term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">term(x)</code></pre><p>Wrap argument in an appropriate <code>AbstractTerm</code> type: <code>Symbol</code>s and <code>AbstractString</code>s become <code>Term</code>s, and <code>Number</code>s become <code>ConstantTerm</code>s.  Any <code>AbstractTerm</code>s are unchanged. <code>AbstractString</code>s are converted to symbols before wrapping.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ts = term.((1, :a, &quot;b&quot;))
1
a(unknown)
b(unknown)

julia&gt; typeof(ts)
Tuple{ConstantTerm{Int64},Term,Term}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/terms.jl#L603-L621">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.coefnames" href="#StatsBase.coefnames"><code>StatsBase.coefnames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">coefnames(term::AbstractTerm)</code></pre><p>Return the name(s) of column(s) generated by a term.  Return value is either a <code>String</code> or an iterable of <code>String</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/terms.jl#L566-L571">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.modelcols" href="#StatsModels.modelcols"><code>StatsModels.modelcols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">modelcols(t::AbstractTerm, data)</code></pre><p>Create a numerical &quot;model columns&quot; representation of data based on an <code>AbstractTerm</code>.  <code>data</code> can either be a whole table (a property-accessible collection of iterable columns or iterable collection of property-accessible rows, as defined by <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> or a single row (in the form of a <code>NamedTuple</code> of scalar values).  Tables will be converted to a <code>NamedTuple</code> of <code>Vectors</code> (e.g., a <code>Tables.ColumnTable</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/terms.jl#L426-L435">source</a></section><section><div><pre><code class="language-none">modelcols(ts::NTuple{N, AbstractTerm}, data) where N</code></pre><p>When a tuple of terms is provided, <code>modelcols</code> broadcasts over the individual terms.  To create a single matrix, wrap the tuple in a <a href="#StatsModels.MatrixTerm"><code>MatrixTerm</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using StableRNGs; rng = StableRNG(1);

julia&gt; d = (a = [1:9;], b = rand(rng, 9), c = repeat([&quot;d&quot;,&quot;e&quot;,&quot;f&quot;], 3));

julia&gt; ts = apply_schema(term.((:a, :b, :c)), schema(d))
a(continuous)
b(continuous)
c(DummyCoding:3→2)

julia&gt; cols = modelcols(ts, d)
([1, 2, 3, 4, 5, 6, 7, 8, 9], [0.5851946422124186, 0.07733793456911231, 0.7166282400543453, 0.3203570514066232, 0.6530930076222579, 0.2366391513734556, 0.7096838914472361, 0.5577872440804086, 0.05079002172175784], [0.0 0.0; 1.0 0.0; … ; 1.0 0.0; 0.0 1.0])

julia&gt; reduce(hcat, cols)
9×4 Array{Float64,2}:
 1.0  0.585195   0.0  0.0
 2.0  0.0773379  1.0  0.0
 3.0  0.716628   0.0  1.0
 4.0  0.320357   0.0  0.0
 5.0  0.653093   1.0  0.0
 6.0  0.236639   0.0  1.0
 7.0  0.709684   0.0  0.0
 8.0  0.557787   1.0  0.0
 9.0  0.05079    0.0  1.0

julia&gt; modelcols(MatrixTerm(ts), d)
9×4 Array{Float64,2}:
 1.0  0.585195   0.0  0.0
 2.0  0.0773379  1.0  0.0
 3.0  0.716628   0.0  1.0
 4.0  0.320357   0.0  0.0
 5.0  0.653093   1.0  0.0
 6.0  0.236639   0.0  1.0
 7.0  0.709684   0.0  0.0
 8.0  0.557787   1.0  0.0
 9.0  0.05079    0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/terms.jl#L448-L493">source</a></section></article><h3 id="Higher-order-terms"><a class="docs-heading-anchor" href="#Higher-order-terms">Higher-order terms</a><a id="Higher-order-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Higher-order-terms" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StatsModels.FormulaTerm" href="#StatsModels.FormulaTerm"><code>StatsModels.FormulaTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FormulaTerm{L,R} &lt;: AbstractTerm</code></pre><p>Represents an entire formula, with a left- and right-hand side.  These can be of any type (captured by the type parameters).</p><p><strong>Fields</strong></p><ul><li><code>lhs::L</code>: The left-hand side (e.g., response)</li><li><code>rhs::R</code>: The right-hand side (e.g., predictors)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/terms.jl#L43-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.InteractionTerm" href="#StatsModels.InteractionTerm"><code>StatsModels.InteractionTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InteractionTerm{Ts} &lt;: AbstractTerm</code></pre><p>Represents an <em>interaction</em> between two or more individual terms.</p><p>Generated by combining multiple <code>AbstractTerm</code>s with <code>&amp;</code> (which is what calls to <code>&amp;</code> in a <code>@formula</code> lower to)</p><p><strong>Fields</strong></p><ul><li><code>terms::Ts</code>: the terms that participate in the interaction.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using StableRNGs; rng = StableRNG(1);

julia&gt; d = (y = rand(rng, 9), a = 1:9, b = rand(rng, 9), c = repeat([&quot;d&quot;,&quot;e&quot;,&quot;f&quot;], 3));

julia&gt; t = InteractionTerm(term.((:a, :b, :c)))
a(unknown) &amp; b(unknown) &amp; c(unknown)

julia&gt; t == term(:a) &amp; term(:b) &amp; term(:c)
true

julia&gt; t = apply_schema(t, schema(d))
a(continuous) &amp; b(continuous) &amp; c(DummyCoding:3→2)

julia&gt; modelcols(t, d)
9×2 Array{Float64,2}:
 0.0       0.0
 1.88748   0.0
 0.0       1.33701
 0.0       0.0
 0.725357  0.0
 0.0       0.126744
 0.0       0.0
 4.93994   0.0
 0.0       4.33378

julia&gt; modelcols(t.terms, d)
([1, 2, 3, 4, 5, 6, 7, 8, 9], [0.236781883208121, 0.9437409715735081, 0.4456708824294644, 0.7636794266904741, 0.14507148958283067, 0.021124039581375875, 0.15254507694061115, 0.617492416565387, 0.48153065407402607], [0.0 0.0; 1.0 0.0; … ; 1.0 0.0; 0.0 1.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/terms.jl#L130-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.FunctionTerm" href="#StatsModels.FunctionTerm"><code>StatsModels.FunctionTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FunctionTerm{Forig,Fanon,Names} &lt;: AbstractTerm</code></pre><p>Represents a call to a Julia function.  The first type parameter is the type of the function as originally specified (e.g., <code>typeof(log)</code>), while the second is the type of the anonymous function that will be applied element-wise to the data table.</p><p>The <code>FunctionTerm</code> <em>also</em> captures the arguments of the original call and parses them <em>as if</em> they were part of a special DSL call, applying the rules to expand <code>*</code>, distribute <code>&amp;</code> over <code>+</code>, and wrap symbols in <code>Term</code>s.</p><p>By storing the original function as a type parameter <em>and</em> pessimistically parsing the arguments as if they&#39;re part of a special DSL call, this allows custom syntax to be supported with minimal extra effort.  Packages can dispatch on <code>apply_schema(f::FunctionTerm{typeof(special_syntax)}, schema, ::Type{&lt;:MyModel})</code> and pull out the arguments parsed as terms from <code>f.args_parsed</code> to construct their own custom terms.</p><p><strong>Fields</strong></p><ul><li><code>forig::Forig</code>: the original function (e.g., <code>log</code>)</li><li><code>fanon::Fanon</code>: the generated anonymous function (e.g., <code>(a, b) -&gt; log(1+a+b)</code>)</li><li><code>exorig::Expr</code>: the original expression passed to <code>@formula</code></li><li><code>args_parsed::Vector</code>: the arguments of the call passed to <code>@formula</code>, each parsed <em>as if</em> the call was a &quot;special&quot; DSL call.</li></ul><p><strong>Type parameters</strong></p><ul><li><code>Forig</code>: the type of the original function (e.g., <code>typeof(log)</code>)</li><li><code>Fanon</code>: the type of the generated anonymous function</li><li><code>Names</code>: the names of the arguments to the anonymous function (as a <code>NTuple{N,Symbol}</code>)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; f = @formula(y ~ log(1 + a + b))
FormulaTerm
Response:
  y(unknown)
Predictors:
  (a,b)-&gt;log(1 + a + b)

julia&gt; typeof(f.rhs)
FunctionTerm{typeof(log),var&quot;#1#2&quot;,(:a, :b)}

julia&gt; f.rhs.forig(1 + 3 + 4)
2.0794415416798357

julia&gt; f.rhs.fanon(3, 4)
2.0794415416798357

julia&gt; modelcols(f.rhs, (a=3, b=4))
2.0794415416798357

julia&gt; modelcols(f.rhs, (a=[3, 4], b=[4, 5]))
2-element Array{Float64,1}:
 2.0794415416798357
 2.302585092994046</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/terms.jl#L59-L120">source</a></section></article><h3 id="Placeholder-terms"><a class="docs-heading-anchor" href="#Placeholder-terms">Placeholder terms</a><a id="Placeholder-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Placeholder-terms" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StatsModels.Term" href="#StatsModels.Term"><code>StatsModels.Term</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Term &lt;: AbstractTerm</code></pre><p>A placeholder for a variable in a formula where the type (and necessary data invariants) is not yet known.  This will be converted to a <a href="#StatsModels.ContinuousTerm"><code>ContinuousTerm</code></a> or <a href="#StatsModels.CategoricalTerm"><code>CategoricalTerm</code></a> by <a href="#StatsModels.apply_schema"><code>apply_schema</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>sym::Symbol</code>: The name of the data column this term refers to.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/terms.jl#L10-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.ConstantTerm" href="#StatsModels.ConstantTerm"><code>StatsModels.ConstantTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ConstantTerm{T&lt;:Number} &lt;: AbstractTerm</code></pre><p>Represents a literal number in a formula.  By default will be converted to [<code>InterceptTerm</code>] by <a href="#StatsModels.apply_schema"><code>apply_schema</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>n::T</code>: The number represented by this term.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/terms.jl#L28-L37">source</a></section></article><h3 id="Concrete-terms"><a class="docs-heading-anchor" href="#Concrete-terms">Concrete terms</a><a id="Concrete-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Concrete-terms" title="Permalink"></a></h3><p>These are all generated by <a href="#StatsModels.apply_schema"><code>apply_schema</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="StatsModels.ContinuousTerm" href="#StatsModels.ContinuousTerm"><code>StatsModels.ContinuousTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ContinuousTerm &lt;: AbstractTerm</code></pre><p>Represents a continuous variable, with a name and summary statistics.</p><p><strong>Fields</strong></p><ul><li><code>sym::Symbol</code>: The name of the variable</li><li><code>mean::T</code>: Mean</li><li><code>var::T</code>: Variance</li><li><code>min::T</code>: Minimum value</li><li><code>max::T</code>: Maximum value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/terms.jl#L194-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.CategoricalTerm" href="#StatsModels.CategoricalTerm"><code>StatsModels.CategoricalTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CategoricalTerm{C,T,N} &lt;: AbstractTerm</code></pre><p>Represents a categorical term, with a name and <a href="../contrasts/#StatsModels.ContrastsMatrix"><code>ContrastsMatrix</code></a></p><p><strong>Fields</strong></p><ul><li><code>sym::Symbol</code>: The name of the variable</li><li><code>contrasts::ContrastsMatrix</code>: A contrasts matrix that captures the unique values this variable takes on and how they are mapped onto numerical predictors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/terms.jl#L216-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.InterceptTerm" href="#StatsModels.InterceptTerm"><code>StatsModels.InterceptTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InterceptTerm{HasIntercept} &lt;: AbstractTerm</code></pre><p>Represents the presence or (explicit) absence of an &quot;intercept&quot; term in a regression model.  These terms are generated from <a href="#StatsModels.ConstantTerm"><code>ConstantTerm</code></a>s in a formula by <code>apply_schema(::ConstantTerm, schema, ::Type{&lt;:StatisticalModel})</code>. A <code>1</code> yields <code>InterceptTerm{true}</code>, and <code>0</code> or <code>-1</code> yield <code>InterceptTerm{false}</code> (which explicitly omits an intercept for models which implicitly includes one via the <a href="#StatsModels.implicit_intercept"><code>implicit_intercept</code></a> trait).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/terms.jl#L179-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShiftedArrays.lead" href="#ShiftedArrays.lead"><code>ShiftedArrays.lead</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    lead(term, nsteps::Integer)

This `@formula` term is used to introduce lead variables.
For example `lead(x,1)` effectively adds a new column containing
the value of the `x` column from the next row.
If there is no such row (e.g. because this is the last row),
then the lead column will contain `missing` for that entry.

Note: this is only a basic row-wise lead operation.
It is up to the user to ensure that data is sorted by the temporal variable,
and that observations are spaced with regular time-steps.
(Which may require adding extra-rows filled with `missing` values.)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/temporal_terms.jl#L20-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShiftedArrays.lag" href="#ShiftedArrays.lag"><code>ShiftedArrays.lag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">    lag(term, nsteps::Integer)

This `@formula` term is used to introduce lagged variables.
For example `lag(x,1)` effectively adds a new column containing
the value of the `x` column from the previous row.
If there is no such row (e.g. because this is the first row),
then the lagged column will contain `missing` for that entry.

Note: this is only a basic row-wise lag operation.
It is up to the user to ensure that data is sorted by the temporal variable,
and that observations are spaced with regular time-steps.
(Which may require adding extra-rows filled with `missing` values.)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/temporal_terms.jl#L19-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.MatrixTerm" href="#StatsModels.MatrixTerm"><code>StatsModels.MatrixTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MatrixTerm{Ts} &lt;: AbstractTerm</code></pre><p>A collection of terms that should be combined to produce a single numeric matrix.</p><p>A matrix term is created by <a href="#StatsModels.apply_schema"><code>apply_schema</code></a> from a tuple of terms using <a href="#StatsModels.collect_matrix_terms"><code>collect_matrix_terms</code></a>, which pulls out all the terms that are matrix terms as determined by the trait function <a href="#StatsModels.is_matrix_term"><code>is_matrix_term</code></a>, which is true by default for all <code>AbstractTerm</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/terms.jl#L238-L247">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.collect_matrix_terms" href="#StatsModels.collect_matrix_terms"><code>StatsModels.collect_matrix_terms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">collect_matrix_terms(ts::TupleTerm)
collect_matrix_terms(t::AbstractTerm) = collect_matrix_term((t, ))</code></pre><p>Depending on whether the component terms are matrix terms (meaning they have <a href="#StatsModels.is_matrix_term"><code>is_matrix_term(T) == true</code></a>), <code>collect_matrix_terms</code> will return</p><ol><li>A single <code>MatrixTerm</code> (if all components are matrix terms)</li><li>A tuple of the components (if none of them are matrix terms)</li><li>A tuple of terms, with all matrix terms collected into a single <code>MatrixTerm</code>  in the first element of the tuple, and the remaining non-matrix terms passed  through unchanged.</li></ol><p>By default all terms are matrix terms (that is, <code>is_matrix_term(::Type{&lt;:AbstractTerm}) = true</code>), the first case is by far the most common.  The others are provided only for convenience when dealing with specialized terms that can&#39;t be concatenated into a single model matrix, like random effects terms in <a href="https://github.com/dmbates/MixedModels.jl">MixedModels.jl</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/terms.jl#L255-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.is_matrix_term" href="#StatsModels.is_matrix_term"><code>StatsModels.is_matrix_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_matrix_term(::Type{&lt;:AbstractTerm})</code></pre><p>Does this type of term get concatenated with other matrix terms into a single model matrix?  This controls the behavior of the <a href="#StatsModels.collect_matrix_terms"><code>collect_matrix_terms</code></a>, which collects all of its arguments for which <code>is_matrix_term</code> returns <code>true</code> into a <a href="#StatsModels.MatrixTerm"><code>MatrixTerm</code></a>, and returns the rest unchanged.</p><p>Since all &quot;normal&quot; terms which describe one or more model matrix columns are matrix terms, this defaults to <code>true</code> for any <code>AbstractTerm</code>.</p><p>An example of a non-matrix term is a random effect term in <a href="https://github.com/dmbates/MixedModels.jl">MixedModels.jl</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/terms.jl#L293-L306">source</a></section></article><h3 id="Protection"><a class="docs-heading-anchor" href="#Protection">Protection</a><a id="Protection-1"></a><a class="docs-heading-anchor-permalink" href="#Protection" title="Permalink"></a></h3><p>For controlling when </p><article class="docstring"><header><a class="docstring-binding" id="StatsModels.protect" href="#StatsModels.protect"><code>StatsModels.protect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">protect(term::T)</code></pre><p>Create a <a href="#StatsModels.Protected"><code>Protected</code></a> context for interpreting <code>term</code> (and descendents) during <code>apply_schema</code>.</p><p>Outside a <a href="#StatsModels.@formula"><code>@formula</code></a>, acts as a constructor for the singleton <code>Protected{T}</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; d = (y=rand(4), a=[1:4;], b=rand(4))

julia&gt; f = @formula(y ~ 1 + protect(a+b));

julia&gt; modelmatrix(f.rhs, d)
4×2 Array{Float64,2}:
 1.0  1.48861
 1.0  2.21097
 1.0  3.95192
 1.0  4.9999

julia&gt; d.a .+ d.b
4-element Array{Float64,1}:
 1.4886128300795012
 2.210968202158536
 3.951916339835734
 4.999904658898614</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/schema.jl#L267-L296">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.unprotect" href="#StatsModels.unprotect"><code>StatsModels.unprotect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">unprotect(term)
unprotect(::Protected{T})</code></pre><p>Inside a [<code>@formula</code>], removes <a href="#StatsModels.Protected"><code>Protected</code></a> status for the argument term(s).  This allows the usual special <a href="#StatsModels.@formula"><code>@formula</code></a> interpretation of calls to <code>+</code>, <code>&amp;</code>, <code>*</code>, and <code>~</code> to be restored inside an otherwise <a href="#StatsModels.Protected"><code>Protected</code></a> context.</p><p>When called outside a <code>@formula</code>, unwraps <code>Protected{T}</code> to <code>T</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; d = (y=rand(4), a=[1.:4;], b=rand(4));

julia&gt; f = @formula(y ~ 1 - unprotect(a&amp;b));

julia&gt; modelmatrix(f, d)
4×1 Array{Float64,2}:
  0.5113871699204988
  0.5780635956829281
 -1.855749019507202
 -2.9996186355944543

julia&gt; 1 .- d.a .* d.b
4×1 Array{Float64,2}:
  0.5113871699204988
  0.5780635956829281
 -1.855749019507202
 -2.9996186355944543</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/schema.jl#L320-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.Protected" href="#StatsModels.Protected"><code>StatsModels.Protected</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct Protected{Ctx}</code></pre><p>Represent a context in which the normal special syntax and <a href="#StatsModels.apply_schema"><code>apply_schema</code></a> transformations should not apply.  This is automatically applied to the arguments of a <a href="#StatsModels.FunctionTerm"><code>FunctionTerm</code></a>, meaning that by default calls to <code>+</code>, <code>&amp;</code>, or <code>~</code> inside a <a href="#StatsModels.FunctionTerm"><code>FunctionTerm</code></a> will be interpreted as calls to the normal Julia functions, rather than term union, interaction, or formula separation.</p><p>The only special behavior with <a href="#StatsModels.apply_schema"><code>apply_schema</code></a> inside a <code>Protected</code> context is when a call to <a href="#StatsModels.unprotect"><code>unprotect</code></a> is encountered.  At that point, everything below the call to <code>unprotect</code> is treated as special formula syntax.</p><p>A <code>Protected</code> context is created inside a <a href="#StatsModels.FunctionTerm"><code>FunctionTerm</code></a> automatically, but can be manually created with a call to <a href="#StatsModels.protect"><code>protect</code></a>. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/schema.jl#L247-L264">source</a></section></article><h2 id="Schema"><a class="docs-heading-anchor" href="#Schema">Schema</a><a id="Schema-1"></a><a class="docs-heading-anchor-permalink" href="#Schema" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StatsModels.Schema" href="#StatsModels.Schema"><code>StatsModels.Schema</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StatsModels.Schema</code></pre><p>Struct that wraps a <code>Dict</code> mapping <code>Term</code>s to their concrete forms.  This exists mainly for dispatch purposes and to support possibly more sophisticated behavior in the future.</p><p>A <code>Schema</code> behaves for all intents and purposes like an immutable <code>Dict</code>, and delegates the constructor as well as <code>getindex</code>, <code>get</code>, <code>merge!</code>, <code>merge</code>, <code>keys</code>, and <code>haskey</code> to the wrapped <code>Dict</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/schema.jl#L24-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.schema" href="#StatsModels.schema"><code>StatsModels.schema</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">schema([terms::AbstractVector{&lt;:AbstractTerm}, ]data, hints::Dict{Symbol})
schema(term::AbstractTerm, data, hints::Dict{Symbol})</code></pre><p>Compute all the invariants necessary to fit a model with <code>terms</code>.  A schema is a dict that maps <code>Term</code>s to their concrete instantiations (either <code>CategoricalTerm</code>s or <code>ContinuousTerm</code>s.  &quot;Hints&quot; may optionally be supplied in the form of a <code>Dict</code> mapping term names (as <code>Symbol</code>s) to term or contrast types.  If a hint is not provided for a variable, the appropriate term type will be guessed based on the data type from the data column: any numeric data is assumed to be continuous, and any non-numeric data is assumed to be categorical.</p><p>Returns a <a href="#StatsModels.Schema"><code>StatsModels.Schema</code></a>, which is a wrapper around a <code>Dict</code> mapping <code>Term</code>s to their concrete instantiations (<code>ContinuousTerm</code> or <code>CategoricalTerm</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using StableRNGs; rng = StableRNG(1);

julia&gt; d = (x=sample(rng, [:a, :b, :c], 10), y=rand(rng, 10));

julia&gt; ts = [Term(:x), Term(:y)];

julia&gt; schema(ts, d)
StatsModels.Schema with 2 entries:
  x =&gt; x
  y =&gt; y

julia&gt; schema(ts, d, Dict(:x =&gt; HelmertCoding()))
StatsModels.Schema with 2 entries:
  x =&gt; x
  y =&gt; y

julia&gt; schema(term(:y), d, Dict(:y =&gt; CategoricalTerm))
StatsModels.Schema with 1 entry:
  y =&gt; y</code></pre><p>Note that concrete <code>ContinuousTerm</code> and <code>CategoricalTerm</code> and un-typed <code>Term</code>s print the same in a container, but when printed alone are different:</p><pre><code class="language-julia-repl">julia&gt; sch = schema(ts, d)
StatsModels.Schema with 2 entries:
  x =&gt; x
  y =&gt; y

julia&gt; term(:x)
x(unknown)

julia&gt; sch[term(:x)]
x(DummyCoding:3→2)

julia&gt; sch[term(:y)]
y(continuous)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/schema.jl#L58-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.concrete_term" href="#StatsModels.concrete_term"><code>StatsModels.concrete_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">concrete_term(t::Term, data[, hint])</code></pre><p>Create concrete term from the placeholder <code>t</code> based on a data source and optional hint.  If <code>data</code> is a table, the <code>getproperty</code> is used to extract the appropriate column.</p><p>The <code>hint</code> can be a <code>Dict{Symbol}</code> of hints, or a specific hint, a concrete term type (<code>ContinuousTerm</code> or <code>CategoricalTerm</code>), or an instance of some <code>&lt;:AbstractContrasts</code>, in which case a <code>CategoricalTerm</code> will be created using those contrasts.</p><p>If no hint is provided (or <code>hint==nothing</code>), the <code>eltype</code> of the data is used: <code>Number</code>s are assumed to be continuous, and all others are assumed to be categorical.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; concrete_term(term(:a), [1, 2, 3])
a(continuous)

julia&gt; concrete_term(term(:a), [1, 2, 3], nothing)
a(continuous)

julia&gt; concrete_term(term(:a), [1, 2, 3], CategoricalTerm)
a(DummyCoding:3→2)

julia&gt; concrete_term(term(:a), [1, 2, 3], EffectsCoding())
a(EffectsCoding:3→2)

julia&gt; concrete_term(term(:a), [1, 2, 3], Dict(:a=&gt;EffectsCoding()))
a(EffectsCoding:3→2)

julia&gt; concrete_term(term(:a), (a = [1, 2, 3], b = [0.0, 0.5, 1.0]))
a(continuous)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/schema.jl#L133-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.apply_schema" href="#StatsModels.apply_schema"><code>StatsModels.apply_schema</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">apply_schema(t, schema::StatsModels.Schema[, Mod::Type = Nothing])</code></pre><p>Return a new term that is the result of applying <code>schema</code> to term <code>t</code> with destination model (type) <code>Mod</code>.  If <code>Mod</code> is omitted, <code>Nothing</code> will be used.</p><p>When <code>t</code> is a <code>ContinuousTerm</code> or <code>CategoricalTerm</code> already, the term will be returned unchanged <em>unless</em> a matching term is found in the schema.  This allows selective re-setting of a schema to change the contrast coding or levels of a categorical term, or to change a continuous term to categorical or vice versa.</p><p>When defining behavior for custom term types, it&#39;s best to dispatch on <a href="#StatsModels.Schema"><code>StatsModels.Schema</code></a> for the second argument.  Leaving it as <code>::Any</code> will work in <em>most</em> cases, but cause method ambiguity in some.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/schema.jl#L202-L216">source</a></section><section><div><pre><code class="language-none">apply_schema(t::AbstractTerm, schema::StatsModels.FullRank, Mod::Type)</code></pre><p>Apply a schema, under the assumption that when a less-than-full rank model matrix would be produced, categorical terms should be &quot;promoted&quot; to full rank (where a categorical variable with <span>$k$</span> levels would produce <span>$k$</span> columns, instead of <span>$k-1$</span> in the standard contrast coding schemes).  This step is applied automatically when <code>Mod &lt;: StatisticalModel</code>, but other types of models can opt-in by adding a method like</p><pre><code class="language-none">StatsModels.apply_schema(t::FormulaTerm, schema::StatsModels.Schema, Mod::Type{&lt;:MyModelType}) =
    apply_schema(t, StatsModels.FullRank(schema), mod)</code></pre><p>See the section on <a href="../contrasts/#Modeling-categorical-data">Modeling categorical data</a> in the docs for more information on how promotion of categorical variables works.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/schema.jl#L443-L460">source</a></section></article><h2 id="Modeling"><a class="docs-heading-anchor" href="#Modeling">Modeling</a><a id="Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StatsBase.fit" href="#StatsBase.fit"><code>StatsBase.fit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit(Mod::Type{&lt;:StatisticalModel}, f::FormulaTerm, data, args...; 
    contrasts::Dict{Symbol}, kwargs...)</code></pre><p>Convert tabular data into a numeric response vector and predictor matrix using the formula <code>f</code>, and then <code>fit</code> the specified model type, wrapping the result in a <a href="#StatsModels.TableRegressionModel"><code>TableRegressionModel</code></a> or <a href="#StatsModels.TableStatisticalModel"><code>TableStatisticalModel</code></a> (as appropriate).</p><p>This is intended as a backstop for modeling packages that implement model types that are subtypes of <code>StatsBase.StatisticalModel</code> but do not explicitly support the full StatsModels terms-based interface.  Currently this works by creating a <a href="#StatsModels.ModelFrame"><code>ModelFrame</code></a> from the formula and data, and then converting this to a <a href="#StatsModels.ModelMatrix"><code>ModelMatrix</code></a>, but this is an internal implementation detail which may change in the near future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/statsmodel.jl#L99-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.response" href="#StatsBase.response"><code>StatsBase.response</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">response(f::FormulaTerm, data; hints=Dict(), mod=StatisticalModel)
response(mf::ModelFrame; data=mf.data)</code></pre><p>Return the response (left-hand side) of a formula generated by a data source. If a <a href="#StatsModels.ModelFrame"><code>ModelFrame</code></a> is provided instead of an <code>AbstractTerm</code>, the wrapped table is used by default.</p><p>Like <a href="#StatsBase.modelmatrix"><code>modelmatrix</code></a>, this will compute and apply a <a href="#StatsModels.Schema"><code>Schema</code></a> before calling <a href="#StatsModels.modelcols"><code>modelcols</code></a> if necessary.  The optional <code>hints</code> and <code>mod</code> keyword arguments are passed to <a href="#StatsModels.apply_schema"><code>apply_schema</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>response</code> is provided as a convenience for interactive use.  For modeling packages that wish to support a formula-based interface, it is recommended to use the <a href="#StatsModels.schema"><code>schema</code></a> – <a href="#StatsModels.apply_schema"><code>apply_schema</code></a> – <a href="#StatsModels.modelcols"><code>modelcols</code></a> pipeline directly</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/modelframe.jl#L117-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.modelmatrix" href="#StatsBase.modelmatrix"><code>StatsBase.modelmatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">modelmatrix(t::AbstractTerm, data; hints=Dict(), mod=StatisticalModel)
modelmatrix(mf::ModelFrame; data=mf.data)</code></pre><p>Return the model matrix based on a term and a data source.  If the term <code>t</code> is a <a href="#StatsModels.FormulaTerm"><code>FormulaTerm</code></a>, this uses the right-hand side (predictor terms) of the formula; otherwise all columns are generated.  If a <a href="#StatsModels.ModelFrame"><code>ModelFrame</code></a> is provided instead of an <code>AbstractTerm</code>, the wrapped table is used as the data source by default.</p><p>Like <a href="#StatsBase.response"><code>response</code></a>, this will compute and apply a <a href="#StatsModels.Schema"><code>Schema</code></a> before calling <a href="#StatsModels.modelcols"><code>modelcols</code></a> if necessary.  The optional <code>hints</code> and <code>mod</code> keyword arguments are passed to <a href="#StatsModels.apply_schema"><code>apply_schema</code></a>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>modelmatrix</code> is provided as a convenience for interactive use.  For modeling packages that wish to support a formula-based interface, it is recommended to use the <a href="#StatsModels.schema"><code>schema</code></a> – <a href="#StatsModels.apply_schema"><code>apply_schema</code></a> – <a href="#StatsModels.modelcols"><code>modelcols</code></a> pipeline directly</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/modelframe.jl#L87-L108">source</a></section></article><h3 id="Traits"><a class="docs-heading-anchor" href="#Traits">Traits</a><a id="Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Traits" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StatsModels.implicit_intercept" href="#StatsModels.implicit_intercept"><code>StatsModels.implicit_intercept</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">implicit_intercept(T::Type)
implicit_intercept(x::T) = implicit_intercept(T)</code></pre><p>Return <code>true</code> if models of type <code>T</code> should include an implicit intercept even if none is specified in the formula.  Is <code>true</code> by default for all <code>T&lt;:StatisticalModel</code>, and <code>false</code> for others.  To specify that a model type <code>T</code> includes an intercept even if one is not specified explicitly in the formula, overload this function for the corresponding type: <code>implicit_intercept(::Type{&lt;:T}) = true</code></p><p>If a model has an implicit intercept, it can be explicitly excluded by using <code>0</code> in the formula, which generates <a href="#StatsModels.InterceptTerm"><code>InterceptTerm{false}</code></a> with <a href="#StatsModels.apply_schema"><code>apply_schema</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/traits.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.drop_intercept" href="#StatsModels.drop_intercept"><code>StatsModels.drop_intercept</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">drop_intercept(T::Type)
drop_intercept(x::T) = drop_intercept(T)</code></pre><p>Define whether a given model automatically drops the intercept. Return <code>false</code> by default.  To specify that a model type <code>T</code> drops the intercept, overload this function for the  corresponding type: <code>drop_intercept(::Type{&lt;:T}) = true</code></p><p>Models that drop the intercept will be fitted without one: the intercept term will be  removed even if explicitly provided by the user. Categorical variables will be expanded  in the rank-reduced form (contrasts for <code>n</code> levels will only produce <code>n-1</code> columns).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/traits.jl#L22-L33">source</a></section></article><h3 id="Wrappers"><a class="docs-heading-anchor" href="#Wrappers">Wrappers</a><a id="Wrappers-1"></a><a class="docs-heading-anchor-permalink" href="#Wrappers" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>These are internal implementation details that are likely to change in the near future.  In particular, the <code>ModelFrame</code> and <code>ModelMatrix</code> wrappers are dispreferred in favor of using terms directly, and can in most cases be replaced by something like</p><pre><code class="language-julia"># instead of ModelMatrix(ModelFrame(f::FormulaTerm, data, model=MyModel))
sch = schema(f, data)
f = apply_schema(f, sch, MyModel)
response, predictors = modelcols(f, data)</code></pre></div></div><article class="docstring"><header><a class="docstring-binding" id="StatsModels.ModelFrame" href="#StatsModels.ModelFrame"><code>StatsModels.ModelFrame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ModelFrame(formula, data; model=StatisticalModel, contrasts=Dict())</code></pre><p>Wrapper that encapsulates a <code>FormulaTerm</code>, schema, data table, and model type.</p><p>This wrapper encapsulates all the information that&#39;s required to transform data of the same structure as the wrapped data frame into a model matrix (the <code>FormulaTerm</code>), as well as the information about how that formula term was instantiated (the schema and model type)</p><p>Creating a model frame involves first extracting the <a href="#StatsModels.schema"><code>schema</code></a> for the data (using any contrasts provided as hints), and then applying that schema with <a href="#StatsModels.apply_schema"><code>apply_schema</code></a> to the formula in the context of the provided model type.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">ModelFrame(f::FormulaTerm, data; model::Type{M} = StatisticalModel, contrasts::Dict = Dict())</code></pre><p><strong>Fields</strong></p><ul><li><code>f::FormulaTerm</code>: Formula whose left hand side is the <em>response</em> and right hand side are the <em>predictors</em>.</li><li><code>schema::Any</code>: The schema that was applied to generate <code>f</code>.</li><li><code>data::D</code>: The data table being modeled.  The only restriction is that <code>data</code>  is a table (<code>Tables.istable(data) == true</code>)</li><li><code>model::Type{M}</code>: The type of the model that will be fit from this model frame.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = (x = 1:4, y = 5:8)
julia&gt; mf = ModelFrame(@formula(y ~ 1 + x), df)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/modelframe.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.ModelMatrix" href="#StatsModels.ModelMatrix"><code>StatsModels.ModelMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ModelMatrix(mf::ModelFrame)</code></pre><p>Convert a <code>ModelFrame</code> into a numeric matrix suitable for modeling</p><p><strong>Fields</strong></p><ul><li><code>m::AbstractMatrix{&lt;:AbstractFloat}</code>: the generated numeric matrix</li><li><code>assign::Vector{Int}</code> the index of the term corresponding to each column of <code>m</code>.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia">ModelMatrix(mf::ModelFrame)
# Specify the type of the resulting matrix (default Matrix{Float64})
ModelMatrix{T &lt;: AbstractMatrix{&lt;:AbstractFloat}}(mf::ModelFrame)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/modelframe.jl#L185-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.TableStatisticalModel" href="#StatsModels.TableStatisticalModel"><code>StatsModels.TableStatisticalModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wrapper for a <code>StatisticalModel</code> that has been fit from a <code>@formula</code> and tabular data.  </p><p>Most functions from the StatsBase API are simply delegated to the wrapped model, with the exception of functions like <code>fit</code>, <code>predict</code>, and <code>coefnames</code> where the tabular nature of the data means that additional processing is required or information provided by the formula.</p><p><strong>Fields</strong></p><ul><li><code>model::M</code> the wrapped <code>StatisticalModel</code>.</li><li><code>mf::ModelFrame</code> encapsulates the formula, schema, and model type.</li><li><code>mm::ModelMatrix{T}</code> the model matrix that the model was fit from.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/statsmodel.jl#L35-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.TableRegressionModel" href="#StatsModels.TableRegressionModel"><code>StatsModels.TableRegressionModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wrapper for a <code>RegressionModel</code> that has been fit from a <code>@formula</code> and tabular data.  </p><p>Most functions from the StatsBase API are simply delegated to the wrapped model, with the exception of functions like <code>fit</code>, <code>predict</code>, and <code>coefnames</code> where the tabular nature of the data means that additional processing is required or information provided by the formula.</p><p><strong>Fields</strong></p><ul><li><code>model::M</code> the wrapped <code>RegressioModel</code>.</li><li><code>mf::ModelFrame</code> encapsulates the formula, schema, and model type.</li><li><code>mm::ModelMatrix{T}</code> the model matrix that the model was fit from.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/78b6c4b189cc155d8248c9b5dc84cf53ddc0e2f3/src/statsmodel.jl#L55-L68">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../temporal_terms/">« Temporal variables and Time Series Terms</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 20 January 2021 02:46">Wednesday 20 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
