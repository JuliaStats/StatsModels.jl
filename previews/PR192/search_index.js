var documenterSearchIndex = {"docs":
[{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"CurrentModule = StatsModels\nDocTestSetup = quote\n    using StatsModels\n    using LinearAlgebra\nend","category":"page"},{"location":"contrasts/#Modeling-categorical-data","page":"Contrast coding categorical variables","title":"Modeling categorical data","text":"","category":"section"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"To convert categorical data into a numerical representation suitable for modeling, StatsModels implements a variety of contrast coding systems. Each contrast coding system maps a categorical vector with k levels onto k-1 linearly independent model matrix columns.","category":"page"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"The following contrast coding systems are implemented:","category":"page"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"DummyCoding\nEffectsCoding\nHelmertCoding\nHypothesisCoding\nSeqDiffCoding","category":"page"},{"location":"contrasts/#How-to-specify-contrast-coding","page":"Contrast coding categorical variables","title":"How to specify contrast coding","text":"","category":"section"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"The default contrast coding system is DummyCoding.  To override this, use the contrasts argument when constructing a ModelFrame:","category":"page"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"mf = ModelFrame(@formula(y ~ 1 + x), df, contrasts = Dict(:x => EffectsCoding()))","category":"page"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"To change the contrast coding for one or more variables in place, use","category":"page"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"setcontrasts!","category":"page"},{"location":"contrasts/#StatsModels.setcontrasts!","page":"Contrast coding categorical variables","title":"StatsModels.setcontrasts!","text":"setcontrasts!(mf::ModelFrame; kwargs...)\nsetcontrasts!(mf::ModelFrame, contrasts::Dict{Symbol})\n\nUpdate the contrasts used for coding categorical variables in ModelFrame in place.  This is accomplished by computing a new schema based on the provided contrasts and the ModelFrame's data, and applying it to the ModelFrame's FormulaTerm.\n\nNote that only the ModelFrame itself is mutated: because AbstractTerms are immutable, any changes will produce a copy.\n\n\n\n\n\n","category":"function"},{"location":"contrasts/#Interface","page":"Contrast coding categorical variables","title":"Interface","text":"","category":"section"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"AbstractContrasts\nContrastsMatrix","category":"page"},{"location":"contrasts/#StatsModels.AbstractContrasts","page":"Contrast coding categorical variables","title":"StatsModels.AbstractContrasts","text":"Interface to describe contrast coding systems for categorical variables.\n\nConcrete subtypes of AbstractContrasts describe a particular way of converting a categorical data vector into numeric columns in a ModelMatrix. Each instantiation optionally includes the levels to generate columns for and the base level. If not specified these will be taken from the data when a ContrastsMatrix is generated (during ModelFrame construction).\n\nConstructors\n\nFor C <: AbstractContrast:\n\nC()                                     # levels are inferred later\nC(levels = ::Vector{Any})               # levels checked against data later\nC(base = ::Any)                         # specify base level\nC(levels = ::Vector{Any}, base = ::Any) # specify levels and base\n\nArguments\n\nlevels: Optionally, the data levels can be specified here.  This allows you to specify the order of the levels.  If specified, the levels will be checked against the levels actually present in the data when the ContrastsMatrix is constructed. Any mismatch will result in an error, because levels missing in the data would lead to empty columns in the model matrix, and levels missing from the contrasts would lead to empty or undefined rows.\nbase: The base level may also be specified.  The actual interpretation of this depends on the particular contrast type, but in general it can be thought of as a \"reference\" level.  It defaults to the first level.\n\nContrast coding systems\n\nDummyCoding - Code each non-base level as a 0-1 indicator column.\nEffectsCoding - Code each non-base level as 1, and base as -1.\nHelmertCoding - Code each non-base level as the difference from the mean of the lower levels\nSeqDiffCoding - Code for differences between sequential levels of the variable.\nHypothesisCoding - Manually specify contrasts via a hypothesis  matrix, which gives the weighting for the average response for each level\nStatsModels.ContrastsCoding - Manually specify contrasts matrix, which is directly copied into the model matrix.\n\nThe last two coding types, HypothesisCoding and StatsModels.ContrastsCoding, provide a way to manually specify a contrasts matrix. For a variable x with k levels, a contrasts matrix M is a k×k-1 matrix, that maps the k levels onto k-1 model matrix columns.  Specifically, let X be the full-rank indicator matrix for x, where X[i,j] = 1 if x[i] == levels(x)[j], and 0 otherwise. Then the model matrix columns generated by the contrasts matrix M are Y = X * M.\n\nThe hypothesis matrix is the k-1×k matrix that gives the weighted combinations of group mean responses that are represented by regression coefficients for the generated contrasts.  The contrasts matrix is the generalized pseudo-inverse (e.g. LinearAlgebra.pinv) of the hypothesis matrix. See HypothesisCoding or Schad et al. (2020) for more information.\n\nExtending\n\nThe easiest way to specify custom contrasts is with HypothesisCoding or StatsModels.ContrastsCoding.  But if you want to actually implement a custom contrast coding system, you can subtype AbstractContrasts.  This requires a constructor, a contrasts_matrix method for constructing the actual contrasts matrix that maps from levels to ModelMatrix column values, and (optionally) a termnames method:\n\nmutable struct MyCoding <: AbstractContrasts\n    ...\nend\n\ncontrasts_matrix(C::MyCoding, baseind, n) = ...\ntermnames(C::MyCoding, levels, baseind) = ...\n\nReferences\n\nSchad, D. J., Vasishth, S., Hohenstein, S., & Kliegl, R. (2020). How to capitalize on a priori contrasts in linear (mixed) models: A tutorial. Journal of Memory and Language, 110, 104038. https://doi.org/10.1016/j.jml.2019.104038\n\n\n\n\n\n","category":"type"},{"location":"contrasts/#StatsModels.ContrastsMatrix","page":"Contrast coding categorical variables","title":"StatsModels.ContrastsMatrix","text":"An instantiation of a contrast coding system for particular levels\n\nThis type is used internally for generating model matrices based on categorical data, and most users will not need to deal with it directly.  Conceptually, a ContrastsMatrix object stands for an instantiation of a contrast coding system for a particular set of categorical data levels.\n\nIf levels are specified in the AbstractContrasts, those will be used, and likewise for the base level (which defaults to the first level).\n\nConstructors\n\nContrastsMatrix(contrasts::AbstractContrasts, levels::AbstractVector)\nContrastsMatrix(contrasts_matrix::ContrastsMatrix, levels::AbstractVector)\n\nArguments\n\ncontrasts::AbstractContrasts: The contrast coding system to use.\nlevels::AbstractVector: The levels to generate contrasts for.\ncontrasts_matrix::ContrastsMatrix: Constructing a ContrastsMatrix from another will check that the levels match.  This is used, for example, in constructing a model matrix from a ModelFrame using different data.\n\n\n\n\n\n","category":"type"},{"location":"contrasts/#Contrast-coding-systems","page":"Contrast coding categorical variables","title":"Contrast coding systems","text":"","category":"section"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"DummyCoding\nEffectsCoding\nHelmertCoding\nSeqDiffCoding\nHypothesisCoding\nhypothesis_matrix","category":"page"},{"location":"contrasts/#StatsModels.DummyCoding","page":"Contrast coding categorical variables","title":"StatsModels.DummyCoding","text":"DummyCoding([base[, levels]])\nDummyCoding(; base=nothing, levels=nothing)\n\nDummy coding generates one indicator column (1 or 0) for each non-base level.\n\nIf levels are omitted or nothing, they are determined from the data by calling the levels function on the data when constructing ContrastsMatrix. If base is omitted or nothing, the first level is used as the base.\n\nColumns have non-zero mean and are collinear with an intercept column (and lower-order columns for interactions) but are orthogonal to each other. In a regression model, dummy coding leads to an intercept that is the mean of the dependent variable for base level.\n\nAlso known as \"treatment coding\" or \"one-hot encoding\".\n\nExamples\n\njulia> StatsModels.ContrastsMatrix(DummyCoding(), [\"a\", \"b\", \"c\", \"d\"]).matrix\n4×3 Array{Float64,2}:\n 0.0  0.0  0.0\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"contrasts/#StatsModels.EffectsCoding","page":"Contrast coding categorical variables","title":"StatsModels.EffectsCoding","text":"EffectsCoding([base[, levels]])\nEffectsCoding(; base=nothing, levels=nothing)\n\nEffects coding generates columns that code each non-base level as the deviation from the base level.  For each non-base level x of variable, a column is generated with 1 where variable .== x and -1 where variable .== base.\n\nEffectsCoding is like DummyCoding, but using -1 for the base level instead of 0.\n\nIf levels are omitted or nothing, they are determined from the data by calling the levels function when constructing ContrastsMatrix.  If base is omitted or nothing, the first level is used as the base.\n\nWhen all levels are equally frequent, effects coding generates model matrix columns that are mean centered (have mean 0).  For more than two levels the generated columns are not orthogonal.  In a regression model with an effects-coded variable, the intercept corresponds to the grand mean.\n\nAlso known as \"sum coding\" or \"simple coding\". Note though that the default in R and SPSS is to use the last level as the base. Here we use the first level as the base, for consistency with other coding systems.\n\nExamples\n\njulia> StatsModels.ContrastsMatrix(EffectsCoding(), [\"a\", \"b\", \"c\", \"d\"]).matrix\n4×3 Array{Float64,2}:\n -1.0  -1.0  -1.0\n  1.0   0.0   0.0\n  0.0   1.0   0.0\n  0.0   0.0   1.0\n\n\n\n\n\n","category":"type"},{"location":"contrasts/#StatsModels.HelmertCoding","page":"Contrast coding categorical variables","title":"StatsModels.HelmertCoding","text":"HelmertCoding([base[, levels]])\nHelmertCoding(; base=nothing, levels=nothing)\n\nHelmert coding codes each level as the difference from the average of the lower levels.\n\nIf levels are omitted or nothing, they are determined from the data by calling the levels function when constructing Contrastsmatrix.  If base is omitted or nothing, the first level is used as the base. For each non-base level, Helmert coding generates a columns with -1 for each of n levels below, n for that level, and 0 above.\n\nWhen all levels are equally frequent, Helmert coding generates columns that are mean-centered (mean 0) and orthogonal.\n\nExamples\n\njulia> StatsModels.ContrastsMatrix(HelmertCoding(), [\"a\", \"b\", \"c\", \"d\"]).matrix\n4×3 Array{Float64,2}:\n -1.0  -1.0  -1.0\n  1.0  -1.0  -1.0\n  0.0   2.0  -1.0\n  0.0   0.0   3.0\n\n\n\n\n\n","category":"type"},{"location":"contrasts/#StatsModels.SeqDiffCoding","page":"Contrast coding categorical variables","title":"StatsModels.SeqDiffCoding","text":"SeqDiffCoding([base[, levels]])\n\nCode each level in order to test \"sequential difference\" hypotheses, which compares each level to the level below it (starting with the second level). Specifically, the nth predictor tests the hypothesis that the difference between levels n and n+1 is zero.\n\nDifferences are computed in order of levels.  If levels are omitted or nothing, they are determined from the data by calling the levels function when constructing ContrastsMatrix. If base is omitted or nothing, the first level is used as the base.\n\nExamples\n\njulia> seqdiff = StatsModels.ContrastsMatrix(SeqDiffCoding(), [\"a\", \"b\", \"c\", \"d\"]).matrix\n4×3 Array{Float64,2}:\n -0.75  -0.5  -0.25\n  0.25  -0.5  -0.25\n  0.25   0.5  -0.25\n  0.25   0.5   0.75\n\nThe interpretation of sequential difference coding may be hard to see from the contrasts matrix itself.  The corresponding hypothesis matrix shows a clearer picture.  From the rows of the hypothesis matrix, we can see that these contrasts test the difference between the first and second levels, the second and third, and the third and fourth, respectively:\n\njulia> StatsModels.hypothesis_matrix(seqdiff)\n3×4 Array{Int64,2}:\n -1   1   0  0\n  0  -1   1  0\n  0   0  -1  1\n\n\n\n\n\n","category":"type"},{"location":"contrasts/#StatsModels.HypothesisCoding","page":"Contrast coding categorical variables","title":"StatsModels.HypothesisCoding","text":"HypothesisCoding(hypotheses::AbstractMatrix; levels=nothing, labels=nothing)\n\nSpecify how to code a categorical variable in terms of a hypothesis matrix. For a variable with k levels, this should be a k-1 \times k matrix. Each row of the matrix corresponds to a hypothesis about the mean outcomes under each of the k levels of the predictor.  The entries in the row give the weights assigned to each of these k means, and the corresponding predictor in a regression model estimates the weighted sum of these cell means.\n\nFor instance, if we have a variable which has four levels A, B, C, and D, and we want to test the hypothesis that the difference between the average outcomes for levels A and B is different from zero, the corresponding row of the hypothesis matrix would be [-1, 1, 0, 0].  Likewise, to test whether the difference between B and C is different from zero, the hypothesis vector would be [0, -1, 1, 0].  To test each \"successive difference\" hypothesis, the full hypothesis matrix would be\n\njulia> sdiff_hypothesis = [-1  1  0  0\n                            0 -1  1  0\n                            0  0 -1  1];\n\nContrasts are derived the hypothesis matrix by taking the pseudoinverse:\n\njulia> using LinearAlgebra\n\njulia> sdiff_contrasts = pinv(sdiff_hypothesis)\n4×3 Array{Float64,2}:\n -0.75  -0.5  -0.25\n  0.25  -0.5  -0.25\n  0.25   0.5  -0.25\n  0.25   0.5   0.75\n\nThe above matrix is what is produced by constructing a ContrastsMatrix from a HypothesisCoding instance:\n\njulia> StatsModels.ContrastsMatrix(HypothesisCoding(sdiff_hypothesis), [\"a\", \"b\", \"c\", \"d\"]).matrix\n4×3 Array{Float64,2}:\n -0.75  -0.5  -0.25\n  0.25  -0.5  -0.25\n  0.25   0.5  -0.25\n  0.25   0.5   0.75\n\nThe interpretation of the such \"sequential difference\" contrasts are clear when expressed as a hypothesis matrix, but it is not obvious just from looking at the contrasts matrix.  For this reason HypothesisCoding is preferred for specifying custom contrast coding schemes over ContrastsCoding.\n\nOptional arguments levels and labels give the names (in order) of the hypothesis matrix columns (corresponding to levels of the data) and rows (corresponding to the tested hypothesis).  The labels also determine the names of the model matrix columns generated by these contrasts.\n\nReferences\n\nSchad, D. J., Vasishth, S., Hohenstein, S., & Kliegl, R. (2020). How to capitalize on a priori contrasts in linear (mixed) models: A tutorial. Journal of Memory and Language, 110, 104038. https://doi.org/10.1016/j.jml.2019.104038\n\n\n\n\n\n","category":"type"},{"location":"contrasts/#StatsModels.hypothesis_matrix","page":"Contrast coding categorical variables","title":"StatsModels.hypothesis_matrix","text":"hypothesis_matrix(cmat::AbstractMatrix; intercept=needs_intercept(cm), tolerance=1e-5)\nhypothesis_matrix(contrasts::AbstractContrasts, n; baseind=1, kwargs...)\nhypothesis_matrix(cmat::ContrastsMatrix; kwargs...)\n\nCompute the hypothesis matrix for a contrasts matrix using the generalized pseudo-inverse (LinearAlgebra.pinv).  intercept determines whether a column of ones is included before taking the pseudoinverse, which is needed for contrasts where the columns are not orthogonal to the intercept (e.g., have non-zero mean).  If tolerance != 0 (the default), the hypotheses are rounded to Ints if possible and Rationals if not, using the given tolerance.  If tolerance == 0, then the hypothesis matrix is returned as-is.\n\nThe orientation of the hypothesis matrix is opposite that of the contrast matrix: each row of the contrasts matrix is a data level and each column is a predictor, whereas each row of the hypothesis matrix is the interpretation of a predictor with weights for each level given in the columns.\n\nNote that this assumes a balanced design where there are the same number of observations in every cell.  This is only important for non-orthgonal contrasts (including contrasts that are not orthogonal with the intercept).\n\nExamples\n\njulia> cmat = StatsModels.contrasts_matrix(DummyCoding(), 1, 4)\n4×3 Array{Float64,2}:\n 0.0  0.0  0.0\n 1.0  0.0  0.0\n 0.0  1.0  0.0\n 0.0  0.0  1.0\n\njulia> StatsModels.hypothesis_matrix(cmat)\n4×4 Array{Int64,2}:\n  1  0  0  0\n -1  1  0  0\n -1  0  1  0\n -1  0  0  1\n\njulia> StatsModels.hypothesis_matrix(cmat, intercept=false) # wrong without intercept!!\n3×4 Array{Int64,2}:\n 0  1  0  0\n 0  0  1  0\n 0  0  0  1\n\njulia> StatsModels.hypothesis_matrix(cmat, tolerance=0) # ugly\n4×4 Array{Float64,2}:\n  1.0  -2.23753e-16   6.91749e-18  -1.31485e-16\n -1.0   1.0          -2.42066e-16   9.93754e-17\n -1.0   4.94472e-17   1.0           9.93754e-17\n -1.0   1.04958e-16  -1.31044e-16   1.0        \n\njulia> StatsModels.hypothesis_matrix(StatsModels.ContrastsMatrix(DummyCoding(), [\"a\", \"b\", \"c\", \"d\"]))\n4×4 Array{Int64,2}:\n  1  0  0  0\n -1  1  0  0\n -1  0  1  0\n -1  0  0  1\n\n\n\n\n\n\n","category":"function"},{"location":"contrasts/#Special-internal-contrasts","page":"Contrast coding categorical variables","title":"Special internal contrasts","text":"","category":"section"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"FullDummyCoding\nContrastsCoding","category":"page"},{"location":"contrasts/#StatsModels.FullDummyCoding","page":"Contrast coding categorical variables","title":"StatsModels.FullDummyCoding","text":"FullDummyCoding()\n\nFull-rank dummy coding generates one indicator (1 or 0) column for each level, including the base level. This is sometimes known as  one-hot encoding.\n\nNot exported but included here for the sake of completeness. Needed internally for some situations where a categorical variable with k levels needs to be converted into k model matrix columns instead of the standard k-1.  This occurs when there are missing lower-order terms, as in discussed below in Categorical variables in Formulas.\n\nExamples\n\njulia> StatsModels.ContrastsMatrix(StatsModels.FullDummyCoding(), [\"a\", \"b\", \"c\", \"d\"]).matrix\n4×4 Array{Float64,2}:\n 1.0  0.0  0.0  0.0\n 0.0  1.0  0.0  0.0\n 0.0  0.0  1.0  0.0\n 0.0  0.0  0.0  1.0\n\n\n\n\n\n","category":"type"},{"location":"contrasts/#StatsModels.ContrastsCoding","page":"Contrast coding categorical variables","title":"StatsModels.ContrastsCoding","text":"StatsModels.ContrastsCoding(mat::AbstractMatrix[, levels]])\nStatsModels.ContrastsCoding(mat::AbstractMatrix[; levels=nothing])\n\nCoding by manual specification of contrasts matrix. For k levels, the contrasts must be a k by k-1 Matrix.  The contrasts in this matrix will be copied directly into the model matrix; if you want to specify your contrasts as hypotheses (i.e.,  weights assigned to each level's cell mean), you should use  HypothesisCoding instead.\n\n\n\n\n\n","category":"type"},{"location":"contrasts/#Further-details","page":"Contrast coding categorical variables","title":"Further details","text":"","category":"section"},{"location":"contrasts/#Categorical-variables-in-Formulas","page":"Contrast coding categorical variables","title":"Categorical variables in Formulas","text":"","category":"section"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"Generating model matrices from multiple variables, some of which are categorical, requires special care.  The reason for this is that rank-k-1 contrasts are appropriate for a categorical variable with k levels when it aliases other terms, making it partially redundant.  Using rank-k for such a redundant variable will generally result in a rank-deficient model matrix and a model that can't be identified.","category":"page"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"A categorical variable in a term aliases the term that remains when that variable is dropped.  For example, with categorical a:","category":"page"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"In a, the sole variable a aliases the intercept term 1.\nIn a&b, the variable a aliases the main effect term b, and vice versa.\nIn a&b&c, the variable a alises the interaction term b&c (regardless of whether b and c are categorical).","category":"page"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"If a categorical variable aliases another term that is present elsewhere in the formula, we call that variable redundant.  A variable is non-redundant when the term that it alises is not present elsewhere in the formula.  For categorical a, b, and c:","category":"page"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"In y ~ 1 + a, the a in the main effect of a aliases the intercept 1.\nIn y ~ 0 + a, a does not alias any other terms and is non-redundant.\nIn y ~ 1 + a + a&b:\nThe b in a&b is redundant because it aliases the main effect a: dropping b from a&b leaves a.\nThe a in a&b is non-redundant because it aliases b, which is not present anywhere else in the formula.","category":"page"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"When constructing a ModelFrame from a Formula, each term is checked for non-redundant categorical variables.  Any such non-redundant variables are \"promoted\" to full rank in that term by using FullDummyCoding instead of the contrasts used elsewhere for that variable.","category":"page"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"One additional complexity is introduced by promoting non-redundant variables to full rank.  For the purpose of determining redundancy, a full-rank dummy coded categorical variable implicitly introduces the term that it aliases into the formula.  Thus, in y ~ 1 + a + a&b + b&c:","category":"page"},{"location":"contrasts/","page":"Contrast coding categorical variables","title":"Contrast coding categorical variables","text":"In a&b, a aliases the main effect b, which is not explicitly present in the formula.  This makes it non-redundant and so its contrast coding is promoted to FullDummyCoding, which implicitly introduces the main effect of b.\nThen, in b&c, the variable c is now redundant because it aliases the main effect of b, and so it keeps its original contrast coding system.","category":"page"},{"location":"api/","page":"API documentation","title":"API documentation","text":"CurrentModule = StatsModels\nDocTestSetup = quote\n    using StatsModels, Random, StatsBase\n    Random.seed!(2001)\nend\nDocTestFilters = [r\"([a-z]*) => \\1\", r\"getfield\\(.*##[0-9]+#[0-9]+\"]","category":"page"},{"location":"api/#StatsModels.jl-API","page":"API documentation","title":"StatsModels.jl API","text":"","category":"section"},{"location":"api/#Formulae-and-terms","page":"API documentation","title":"Formulae and terms","text":"","category":"section"},{"location":"api/","page":"API documentation","title":"API documentation","text":"@formula\nterm\ncoefnames\nmodelcols","category":"page"},{"location":"api/#StatsModels.@formula","page":"API documentation","title":"StatsModels.@formula","text":"@formula(ex)\n\nCapture and parse a formula expression as a Formula struct.\n\nA formula is an abstract specification of a dependence between left-hand and right-hand side variables as in, e.g., a regression model.  Each side specifies at a high level how tabular data is to be converted to a numerical matrix suitable for modeling.  This specification looks something like Julia code, is represented as a Julia Expr, but uses special syntax.  The @formula macro takes an expression like y ~ 1 + a*b, transforms it according to the formula syntax rules into a lowered form (like y ~ 1 + a + b + a&b), and constructs a Formula struct which captures the original expression, the lowered expression, and the left- and right-hand-side.\n\nOperators that have special interpretations in this syntax are\n\n~ is the formula separator, where it is a binary operator (the first argument is the left-hand side, and the second is the right-hand side.\n+ concatenates variables as columns when generating a model matrix.\n& representes an interaction between two or more variables, which corresponds to a row-wise kronecker product of the individual terms (or element-wise product if all terms involved are continuous/scalar).\n* expands to all main effects and interactions: a*b is equivalent to a+b+a&b, a*b*c to a+b+c+a&b+a&c+b&c+a&b&c, etc.\n1, 0, and -1 indicate the presence (for 1) or absence (for 0 and -1) of an intercept column.\n\nThe rules that are applied are\n\nThe associative rule (un-nests nested calls to +, &, and *).\nThe distributive rule (interactions & distribute over concatenation +).\nThe * rule expands a*b to a+b+a&b (recursively).\nSubtraction is converted to addition and negation, so x-1 becomes x + -1 (applies only to subtraction of literal 1).\nSingle-argument & calls are stripped, so &(x) becomes the main effect x.\n\n\n\n\n\n","category":"macro"},{"location":"api/#StatsModels.term","page":"API documentation","title":"StatsModels.term","text":"term(x)\n\nWrap argument in an appropriate AbstractTerm type: Symbols and AbstractStrings become Terms, and Numbers become ConstantTerms.  Any AbstractTerms are unchanged. AbstractStrings are converted to symbols before wrapping.\n\nExample\n\njulia> ts = term.((1, :a, \"b\"))\n1\na(unknown)\nb(unknown)\n\njulia> typeof(ts)\nTuple{ConstantTerm{Int64},Term,Term}\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsBase.coefnames","page":"API documentation","title":"StatsBase.coefnames","text":"coefnames(term::AbstractTerm)\n\nReturn the name(s) of column(s) generated by a term.  Return value is either a String or an iterable of Strings.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsModels.modelcols","page":"API documentation","title":"StatsModels.modelcols","text":"modelcols(t::AbstractTerm, data)\n\nCreate a numerical \"model columns\" representation of data based on an AbstractTerm.  data can either be a whole table (a property-accessible collection of iterable columns or iterable collection of property-accessible rows, as defined by Tables.jl or a single row (in the form of a NamedTuple of scalar values).  Tables will be converted to a NamedTuple of Vectors (e.g., a Tables.ColumnTable).\n\n\n\n\n\nmodelcols(ts::NTuple{N, AbstractTerm}, data) where N\n\nWhen a tuple of terms is provided, modelcols broadcasts over the individual  terms.  To create a single matrix, wrap the tuple in a MatrixTerm.\n\nExample\n\njulia> using StableRNGs; rng = StableRNG(1);\n\njulia> d = (a = [1:9;], b = rand(rng, 9), c = repeat([\"d\",\"e\",\"f\"], 3));\n\njulia> ts = apply_schema(term.((:a, :b, :c)), schema(d))\na(continuous) \nb(continuous)\nc(DummyCoding:3→2)\n\njulia> cols = modelcols(ts, d)\n([1, 2, 3, 4, 5, 6, 7, 8, 9], [0.5851946422124186, 0.07733793456911231, 0.7166282400543453, 0.3203570514066232, 0.6530930076222579, 0.2366391513734556, 0.7096838914472361, 0.5577872440804086, 0.05079002172175784], [0.0 0.0; 1.0 0.0; … ; 1.0 0.0; 0.0 1.0])\n\njulia> reduce(hcat, cols)\n9×4 Array{Float64,2}:\n 1.0  0.585195   0.0  0.0\n 2.0  0.0773379  1.0  0.0\n 3.0  0.716628   0.0  1.0\n 4.0  0.320357   0.0  0.0\n 5.0  0.653093   1.0  0.0\n 6.0  0.236639   0.0  1.0\n 7.0  0.709684   0.0  0.0\n 8.0  0.557787   1.0  0.0\n 9.0  0.05079    0.0  1.0\n\njulia> modelcols(MatrixTerm(ts), d)\n9×4 Array{Float64,2}:\n 1.0  0.585195   0.0  0.0\n 2.0  0.0773379  1.0  0.0\n 3.0  0.716628   0.0  1.0\n 4.0  0.320357   0.0  0.0\n 5.0  0.653093   1.0  0.0\n 6.0  0.236639   0.0  1.0\n 7.0  0.709684   0.0  0.0\n 8.0  0.557787   1.0  0.0\n 9.0  0.05079    0.0  1.0\n\n\n\n\n\n","category":"function"},{"location":"api/#Higher-order-terms","page":"API documentation","title":"Higher-order terms","text":"","category":"section"},{"location":"api/","page":"API documentation","title":"API documentation","text":"FormulaTerm\nInteractionTerm\nFunctionTerm","category":"page"},{"location":"api/#StatsModels.FormulaTerm","page":"API documentation","title":"StatsModels.FormulaTerm","text":"FormulaTerm{L,R} <: AbstractTerm\n\nRepresents an entire formula, with a left- and right-hand side.  These can be of any type (captured by the type parameters).  \n\nFields\n\nlhs::L: The left-hand side (e.g., response)\nrhs::R: The right-hand side (e.g., predictors)\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsModels.InteractionTerm","page":"API documentation","title":"StatsModels.InteractionTerm","text":"InteractionTerm{Ts} <: AbstractTerm\n\nRepresents an interaction between two or more individual terms.  \n\nGenerated by combining multiple AbstractTerms with & (which is what calls to & in a @formula lower to)\n\nFields\n\nterms::Ts: the terms that participate in the interaction.\n\nExample\n\njulia> using StableRNGs; rng = StableRNG(1);\n\njulia> d = (y = rand(rng, 9), a = 1:9, b = rand(rng, 9), c = repeat([\"d\",\"e\",\"f\"], 3));\n\njulia> t = InteractionTerm(term.((:a, :b, :c)))\na(unknown) & b(unknown) & c(unknown)\n\njulia> t == term(:a) & term(:b) & term(:c)\ntrue\n\njulia> t = apply_schema(t, schema(d))\na(continuous) & b(continuous) & c(DummyCoding:3→2)\n\njulia> modelcols(t, d)\n9×2 Array{Float64,2}:\n 0.0       0.0\n 1.88748   0.0\n 0.0       1.33701\n 0.0       0.0\n 0.725357  0.0\n 0.0       0.126744\n 0.0       0.0\n 4.93994   0.0\n 0.0       4.33378\n\njulia> modelcols(t.terms, d)\n([1, 2, 3, 4, 5, 6, 7, 8, 9], [0.236781883208121, 0.9437409715735081, 0.4456708824294644, 0.7636794266904741, 0.14507148958283067, 0.021124039581375875, 0.15254507694061115, 0.617492416565387, 0.48153065407402607], [0.0 0.0; 1.0 0.0; … ; 1.0 0.0; 0.0 1.0])\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsModels.FunctionTerm","page":"API documentation","title":"StatsModels.FunctionTerm","text":"FunctionTerm{Forig,Fanon,Names} <: AbstractTerm\n\nRepresents a call to a Julia function.  The first type parameter is the type of the function as originally specified (e.g., typeof(log)), while the second is the type of the anonymous function that will be applied element-wise to the data table.\n\nThe FunctionTerm also captures the arguments of the original call and parses them as if they were part of a special DSL call, applying the rules to expand *, distribute & over +, and wrap symbols in Terms.  \n\nBy storing the original function as a type parameter and pessimistically parsing the arguments as if they're part of a special DSL call, this allows custom syntax to be supported with minimal extra effort.  Packages can dispatch on apply_schema(f::FunctionTerm{typeof(special_syntax)}, schema, ::Type{<:MyModel}) and pull out the arguments parsed as terms from f.args_parsed to construct their own custom terms.\n\nFields\n\nforig::Forig: the original function (e.g., log)\nfanon::Fanon: the generated anonymous function (e.g., (a, b) -> log(1+a+b))\nexorig::Expr: the original expression passed to @formula\nargs_parsed::Vector: the arguments of the call passed to @formula, each  parsed as if the call was a \"special\" DSL call.\n\nType parameters\n\nForig: the type of the original function (e.g., typeof(log))\nFanon: the type of the generated anonymous function\nNames: the names of the arguments to the anonymous function (as a NTuple{N,Symbol})\n\nExample\n\njulia> f = @formula(y ~ log(1 + a + b))\nFormulaTerm\nResponse:\n  y(unknown)\nPredictors:\n  (a,b)->log(1 + a + b)\n\njulia> typeof(f.rhs)\nFunctionTerm{typeof(log),var\"#1#2\",(:a, :b)}\n\njulia> f.rhs.forig(1 + 3 + 4)\n2.0794415416798357\n\njulia> f.rhs.fanon(3, 4)\n2.0794415416798357\n\njulia> modelcols(f.rhs, (a=3, b=4))\n2.0794415416798357\n\njulia> modelcols(f.rhs, (a=[3, 4], b=[4, 5]))\n2-element Array{Float64,1}:\n 2.0794415416798357\n 2.302585092994046 \n\n\n\n\n\n","category":"type"},{"location":"api/#Placeholder-terms","page":"API documentation","title":"Placeholder terms","text":"","category":"section"},{"location":"api/","page":"API documentation","title":"API documentation","text":"Term\nConstantTerm","category":"page"},{"location":"api/#StatsModels.Term","page":"API documentation","title":"StatsModels.Term","text":"Term <: AbstractTerm\n\nA placeholder for a variable in a formula where the type (and necessary data invariants) is not yet known.  This will be converted to a ContinuousTerm or CategoricalTerm by apply_schema.\n\nFields\n\nsym::Symbol: The name of the data column this term refers to.\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsModels.ConstantTerm","page":"API documentation","title":"StatsModels.ConstantTerm","text":"ConstantTerm{T<:Number} <: AbstractTerm\n\nRepresents a literal number in a formula.  By default will be converted to [InterceptTerm] by apply_schema.\n\nFields\n\nn::T: The number represented by this term.\n\n\n\n\n\n","category":"type"},{"location":"api/#Concrete-terms","page":"API documentation","title":"Concrete terms","text":"","category":"section"},{"location":"api/","page":"API documentation","title":"API documentation","text":"These are all generated by apply_schema.","category":"page"},{"location":"api/","page":"API documentation","title":"API documentation","text":"ContinuousTerm\nCategoricalTerm\nInterceptTerm\nlead\nlag\nMatrixTerm\ncollect_matrix_terms\nis_matrix_term","category":"page"},{"location":"api/#StatsModels.ContinuousTerm","page":"API documentation","title":"StatsModels.ContinuousTerm","text":"ContinuousTerm <: AbstractTerm\n\nRepresents a continuous variable, with a name and summary statistics.\n\nFields\n\nsym::Symbol: The name of the variable\nmean::T: Mean\nvar::T: Variance\nmin::T: Minimum value\nmax::T: Maximum value\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsModels.CategoricalTerm","page":"API documentation","title":"StatsModels.CategoricalTerm","text":"CategoricalTerm{C,T,N} <: AbstractTerm\n\nRepresents a categorical term, with a name and ContrastsMatrix\n\nFields\n\nsym::Symbol: The name of the variable\ncontrasts::ContrastsMatrix: A contrasts matrix that captures the unique  values this variable takes on and how they are mapped onto numerical  predictors.\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsModels.InterceptTerm","page":"API documentation","title":"StatsModels.InterceptTerm","text":"InterceptTerm{HasIntercept} <: AbstractTerm\n\nRepresents the presence or (explicit) absence of an \"intercept\" term in a regression model.  These terms are generated from ConstantTerms in a formula by apply_schema(::ConstantTerm, schema, ::Type{<:StatisticalModel}). A 1 yields InterceptTerm{true}, and 0 or -1 yield InterceptTerm{false} (which explicitly omits an intercept for models which implicitly includes one via the implicit_intercept trait).\n\n\n\n\n\n","category":"type"},{"location":"api/#ShiftedArrays.lead","page":"API documentation","title":"ShiftedArrays.lead","text":"    lead(term, nsteps::Integer)\n\nThis `@formula` term is used to introduce lead variables.\nFor example `lead(x,1)` effectively adds a new column containing\nthe value of the `x` column from the next row.\nIf there is no such row (e.g. because this is the last row),\nthen the lead column will contain `missing` for that entry.\n\nNote: this is only a basic row-wise lead operation.\nIt is up to the user to ensure that data is sorted by the temporal variable,\nand that observations are spaced with regular time-steps.\n(Which may require adding extra-rows filled with `missing` values.)\n\n\n\n\n\n","category":"function"},{"location":"api/#ShiftedArrays.lag","page":"API documentation","title":"ShiftedArrays.lag","text":"    lag(term, nsteps::Integer)\n\nThis `@formula` term is used to introduce lagged variables.\nFor example `lag(x,1)` effectively adds a new column containing\nthe value of the `x` column from the previous row.\nIf there is no such row (e.g. because this is the first row),\nthen the lagged column will contain `missing` for that entry.\n\nNote: this is only a basic row-wise lag operation.\nIt is up to the user to ensure that data is sorted by the temporal variable,\nand that observations are spaced with regular time-steps.\n(Which may require adding extra-rows filled with `missing` values.)\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsModels.MatrixTerm","page":"API documentation","title":"StatsModels.MatrixTerm","text":"MatrixTerm{Ts} <: AbstractTerm\n\nA collection of terms that should be combined to produce a single numeric matrix.\n\nA matrix term is created by apply_schema from a tuple of terms using  collect_matrix_terms, which pulls out all the terms that are matrix terms as determined by the trait function is_matrix_term, which is  true by default for all AbstractTerms.\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsModels.collect_matrix_terms","page":"API documentation","title":"StatsModels.collect_matrix_terms","text":"collect_matrix_terms(ts::TupleTerm)\ncollect_matrix_terms(t::AbstractTerm) = collect_matrix_term((t, ))\n\nDepending on whether the component terms are matrix terms (meaning they have is_matrix_term(T) == true), collect_matrix_terms will return\n\nA single MatrixTerm (if all components are matrix terms)\nA tuple of the components (if none of them are matrix terms)\nA tuple of terms, with all matrix terms collected into a single MatrixTerm  in the first element of the tuple, and the remaining non-matrix terms passed  through unchanged.\n\nBy default all terms are matrix terms (that is, is_matrix_term(::Type{<:AbstractTerm}) = true), the first case is by far the most common.  The others are provided only for convenience when dealing with specialized terms that can't be concatenated into a single model matrix, like random effects terms in MixedModels.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsModels.is_matrix_term","page":"API documentation","title":"StatsModels.is_matrix_term","text":"is_matrix_term(::Type{<:AbstractTerm})\n\nDoes this type of term get concatenated with other matrix terms into a single model matrix?  This controls the behavior of the collect_matrix_terms, which collects all of its arguments for which is_matrix_term returns true into a MatrixTerm, and returns the rest unchanged.\n\nSince all \"normal\" terms which describe one or more model matrix columns are matrix terms, this defaults to true for any AbstractTerm.\n\nAn example of a non-matrix term is a random effect term in MixedModels.jl.\n\n\n\n\n\n","category":"function"},{"location":"api/#Schema","page":"API documentation","title":"Schema","text":"","category":"section"},{"location":"api/","page":"API documentation","title":"API documentation","text":"Schema\nschema\nconcrete_term\napply_schema","category":"page"},{"location":"api/#StatsModels.Schema","page":"API documentation","title":"StatsModels.Schema","text":"StatsModels.Schema\n\nStruct that wraps a Dict mapping Terms to their concrete forms.  This exists mainly for dispatch purposes and to support possibly more sophisticated behavior in the future.\n\nA Schema behaves for all intents and purposes like an immutable Dict, and delegates the constructor as well as getindex, get, merge!, merge, keys, and haskey to the wrapped Dict.\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsModels.schema","page":"API documentation","title":"StatsModels.schema","text":"schema([terms::AbstractVector{<:AbstractTerm}, ]data, hints::Dict{Symbol})\nschema(term::AbstractTerm, data, hints::Dict{Symbol})\n\nCompute all the invariants necessary to fit a model with terms.  A schema is a dict that maps Terms to their concrete instantiations (either CategoricalTerms or ContinuousTerms.  \"Hints\" may optionally be supplied in the form of a Dict mapping term names (as Symbols) to term or contrast types.  If a hint is not provided for a variable,  the appropriate term type will be guessed based on the data type from the data column: any numeric data is assumed to be continuous, and any non-numeric data is assumed to be categorical.\n\nReturns a StatsModels.Schema, which is a wrapper around a Dict mapping Terms to their concrete instantiations (ContinuousTerm or CategoricalTerm).\n\nExample\n\njulia> using StableRNGs; rng = StableRNG(1);\n\njulia> d = (x=sample(rng, [:a, :b, :c], 10), y=rand(rng, 10));\n\njulia> ts = [Term(:x), Term(:y)];\n\njulia> schema(ts, d)\nStatsModels.Schema with 2 entries:\n  x => x\n  y => y\n\njulia> schema(ts, d, Dict(:x => HelmertCoding()))\nStatsModels.Schema with 2 entries:\n  x => x\n  y => y\n\njulia> schema(term(:y), d, Dict(:y => CategoricalTerm))\nStatsModels.Schema with 1 entry:\n  y => y\n\nNote that concrete ContinuousTerm and CategoricalTerm and un-typed Terms print the  same in a container, but when printed alone are different:\n\njulia> sch = schema(ts, d)\nStatsModels.Schema with 2 entries:\n  x => x\n  y => y\n\njulia> term(:x)\nx(unknown)\n\njulia> sch[term(:x)]\nx(DummyCoding:3→2)\n\njulia> sch[term(:y)]\ny(continuous)\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsModels.concrete_term","page":"API documentation","title":"StatsModels.concrete_term","text":"concrete_term(t::Term, data[, hint])\n\nCreate concrete term from the placeholder t based on a data source and optional hint.  If data is a table, the getproperty is used to extract the appropriate column.\n\nThe hint can be a Dict{Symbol} of hints, or a specific hint, a concrete term type (ContinuousTerm or CategoricalTerm), or an instance of some <:AbstractContrasts, in which case a CategoricalTerm will be created using those contrasts.\n\nIf no hint is provided (or hint==nothing), the eltype of the data is used: Numbers are assumed to be continuous, and all others are assumed to be categorical.\n\nExample\n\njulia> concrete_term(term(:a), [1, 2, 3])\na(continuous)\n\njulia> concrete_term(term(:a), [1, 2, 3], nothing)\na(continuous)\n\njulia> concrete_term(term(:a), [1, 2, 3], CategoricalTerm)\na(DummyCoding:3→2)\n\njulia> concrete_term(term(:a), [1, 2, 3], EffectsCoding())\na(EffectsCoding:3→2)\n\njulia> concrete_term(term(:a), [1, 2, 3], Dict(:a=>EffectsCoding()))\na(EffectsCoding:3→2)\n\njulia> concrete_term(term(:a), (a = [1, 2, 3], b = [0.0, 0.5, 1.0]))\na(continuous)\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsModels.apply_schema","page":"API documentation","title":"StatsModels.apply_schema","text":"apply_schema(t, schema::StatsModels.Schema[, Mod::Type = Nothing])\n\nReturn a new term that is the result of applying schema to term t with destination model (type) Mod.  If Mod is omitted, Nothing will be used.\n\nWhen t is a ContinuousTerm or CategoricalTerm already, the term will be returned  unchanged unless a matching term is found in the schema.  This allows  selective re-setting of a schema to change the contrast coding or levels of a  categorical term, or to change a continuous term to categorical or vice versa.\n\nWhen defining behavior for custom term types, it's best to dispatch on StatsModels.Schema for the second argument.  Leaving it as ::Any will work in most cases, but cause method ambiguity in some.\n\n\n\n\n\napply_schema(t::AbstractTerm, schema::StatsModels.FullRank, Mod::Type)\n\nApply a schema, under the assumption that when a less-than-full rank model matrix would be produced, categorical terms should be \"promoted\" to full rank (where a categorical variable with k levels would produce k columns, instead of k-1 in the standard contrast coding schemes).  This step is applied automatically when Mod <: StatisticalModel, but other types of models can opt-in by adding a method like\n\nStatsModels.apply_schema(t::FormulaTerm, schema::StatsModels.Schema, Mod::Type{<:MyModelType}) =\n    apply_schema(t, StatsModels.FullRank(schema), mod)\n\nSee the section on Modeling categorical data in the docs for more information on how promotion of categorical variables works.\n\n\n\n\n\n","category":"function"},{"location":"api/#Modeling","page":"API documentation","title":"Modeling","text":"","category":"section"},{"location":"api/","page":"API documentation","title":"API documentation","text":"fit\nresponse\nmodelmatrix","category":"page"},{"location":"api/#StatsBase.fit","page":"API documentation","title":"StatsBase.fit","text":"fit(Mod::Type{<:StatisticalModel}, f::FormulaTerm, data, args...; \n    contrasts::Dict{Symbol}, kwargs...)\n\nConvert tabular data into a numeric response vector and predictor matrix using the formula f, and then fit the specified model type, wrapping the result in a TableRegressionModel or TableStatisticalModel (as appropriate).\n\nThis is intended as a backstop for modeling packages that implement model types that are subtypes of StatsBase.StatisticalModel but do not explicitly support the full StatsModels terms-based interface.  Currently this works by creating a ModelFrame from the formula and data, and then converting this to a ModelMatrix, but this is an internal implementation detail which may change in the near future.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsBase.response","page":"API documentation","title":"StatsBase.response","text":"response(f::FormulaTerm, data; hints=Dict(), mod=StatisticalModel)\nresponse(mf::ModelFrame; data=mf.data)\n\nReturn the response (left-hand side) of a formula generated by a data source. If a ModelFrame is provided instead of an AbstractTerm, the wrapped table is used by default.\n\nLike modelmatrix, this will compute and apply a Schema before calling modelcols if necessary.  The optional hints and mod keyword arguments are passed to apply_schema.\n\nnote: Note\nresponse is provided as a convenience for interactive use.  For modeling packages that wish to support a formula-based interface, it is recommended to use the schema – apply_schema – modelcols pipeline directly\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsBase.modelmatrix","page":"API documentation","title":"StatsBase.modelmatrix","text":"modelmatrix(t::AbstractTerm, data; hints=Dict(), mod=StatisticalModel)\nmodelmatrix(mf::ModelFrame; data=mf.data)\n\nReturn the model matrix based on a term and a data source.  If the term t is a FormulaTerm, this uses the right-hand side (predictor terms) of the formula; otherwise all columns are generated.  If a ModelFrame is provided instead of an AbstractTerm, the wrapped table is used as the data source by default.\n\nLike response, this will compute and apply a Schema before calling modelcols if necessary.  The optional hints and mod keyword arguments are passed to apply_schema.\n\nnote: Note\nmodelmatrix is provided as a convenience for interactive use.  For modeling packages that wish to support a formula-based interface, it is recommended to use the schema – apply_schema – modelcols pipeline directly\n\n\n\n\n\n","category":"function"},{"location":"api/#Traits","page":"API documentation","title":"Traits","text":"","category":"section"},{"location":"api/","page":"API documentation","title":"API documentation","text":"StatsModels.implicit_intercept\nStatsModels.drop_intercept","category":"page"},{"location":"api/#StatsModels.implicit_intercept","page":"API documentation","title":"StatsModels.implicit_intercept","text":"implicit_intercept(T::Type)\nimplicit_intercept(x::T) = implicit_intercept(T)\n\nReturn true if models of type T should include an implicit intercept even if none is specified in the formula.  Is true by default for all T<:StatisticalModel, and false for others.  To specify that a model type T includes an intercept even if one is not specified explicitly in the formula, overload this function for the corresponding type: implicit_intercept(::Type{<:T}) = true\n\nIf a model has an implicit intercept, it can be explicitly excluded by using 0 in the formula, which generates InterceptTerm{false} with apply_schema.\n\n\n\n\n\n","category":"function"},{"location":"api/#StatsModels.drop_intercept","page":"API documentation","title":"StatsModels.drop_intercept","text":"drop_intercept(T::Type)\ndrop_intercept(x::T) = drop_intercept(T)\n\nDefine whether a given model automatically drops the intercept. Return false by default.  To specify that a model type T drops the intercept, overload this function for the  corresponding type: drop_intercept(::Type{<:T}) = true\n\nModels that drop the intercept will be fitted without one: the intercept term will be  removed even if explicitly provided by the user. Categorical variables will be expanded  in the rank-reduced form (contrasts for n levels will only produce n-1 columns).\n\n\n\n\n\n","category":"function"},{"location":"api/#Wrappers","page":"API documentation","title":"Wrappers","text":"","category":"section"},{"location":"api/","page":"API documentation","title":"API documentation","text":"warning: Warning\nThese are internal implementation details that are likely to change in the near future.  In particular, the ModelFrame and ModelMatrix wrappers are dispreferred in favor of using terms directly, and can in most cases be replaced by something like# instead of ModelMatrix(ModelFrame(f::FormulaTerm, data, model=MyModel))\nsch = schema(f, data)\nf = apply_schema(f, sch, MyModel)\nresponse, predictors = modelcols(f, data)","category":"page"},{"location":"api/","page":"API documentation","title":"API documentation","text":"ModelFrame\nModelMatrix\nStatsModels.TableStatisticalModel\nStatsModels.TableRegressionModel","category":"page"},{"location":"api/#StatsModels.ModelFrame","page":"API documentation","title":"StatsModels.ModelFrame","text":"ModelFrame(formula, data; model=StatisticalModel, contrasts=Dict())\n\nWrapper that encapsulates a FormulaTerm, schema, data table, and model type.\n\nThis wrapper encapsulates all the information that's required to transform data of the same structure as the wrapped data frame into a model matrix (the FormulaTerm), as well as the information about how that formula term was instantiated (the schema and model type)\n\nCreating a model frame involves first extracting the schema for the data (using any contrasts provided as hints), and then applying that schema with apply_schema to the formula in the context of the provided model type.\n\nConstructors\n\nModelFrame(f::FormulaTerm, data; model::Type{M} = StatisticalModel, contrasts::Dict = Dict())\n\nFields\n\nf::FormulaTerm: Formula whose left hand side is the response and right hand side are the predictors.\nschema::Any: The schema that was applied to generate f.\ndata::D: The data table being modeled.  The only restriction is that data  is a table (Tables.istable(data) == true)\nmodel::Type{M}: The type of the model that will be fit from this model frame.\n\nExamples\n\njulia> df = (x = 1:4, y = 5:8)\njulia> mf = ModelFrame(@formula(y ~ 1 + x), df)\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsModels.ModelMatrix","page":"API documentation","title":"StatsModels.ModelMatrix","text":"ModelMatrix(mf::ModelFrame)\n\nConvert a ModelFrame into a numeric matrix suitable for modeling\n\nFields\n\nm::AbstractMatrix{<:AbstractFloat}: the generated numeric matrix\nassign::Vector{Int} the index of the term corresponding to each column of m.\n\nConstructors\n\nModelMatrix(mf::ModelFrame)\n# Specify the type of the resulting matrix (default Matrix{Float64})\nModelMatrix{T <: AbstractMatrix{<:AbstractFloat}}(mf::ModelFrame)\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsModels.TableStatisticalModel","page":"API documentation","title":"StatsModels.TableStatisticalModel","text":"Wrapper for a StatisticalModel that has been fit from a @formula and tabular data.  \n\nMost functions from the StatsBase API are simply delegated to the wrapped model, with the exception of functions like fit, predict, and coefnames where the tabular nature of the data means that additional processing is required or information provided by the formula.\n\nFields\n\nmodel::M the wrapped StatisticalModel.\nmf::ModelFrame encapsulates the formula, schema, and model type.\nmm::ModelMatrix{T} the model matrix that the model was fit from.\n\n\n\n\n\n","category":"type"},{"location":"api/#StatsModels.TableRegressionModel","page":"API documentation","title":"StatsModels.TableRegressionModel","text":"Wrapper for a RegressionModel that has been fit from a @formula and tabular data.  \n\nMost functions from the StatsBase API are simply delegated to the wrapped model, with the exception of functions like fit, predict, and coefnames where the tabular nature of the data means that additional processing is required or information provided by the formula.\n\nFields\n\nmodel::M the wrapped RegressioModel.\nmf::ModelFrame encapsulates the formula, schema, and model type.\nmm::ModelMatrix{T} the model matrix that the model was fit from.\n\n\n\n\n\n","category":"type"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"CurrentModule = StatsModels\nDocTestSetup = quote\n    using StatsModels\nend","category":"page"},{"location":"formula/#Modeling-tabular-data","page":"Modeling tabular data","title":"Modeling tabular data","text":"","category":"section"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"Most statistical models require that data be represented as a Matrix-like collection of a single numeric type.  Much of the data we want to model, however, is tabular data, where data is represented as a collection of fields with possibly heterogeneous types.  One of the primary goals of StatsModels is to make it simpler to transform tabular data into matrix format suitable for statistical modeling.","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"At the moment, \"tabular data\" means a Tables.jl table, which will be materialized as a Tables.ColumnTable (a NamedTuple of column vectors).  Work on first-class support for streaming/row-oriented tables is ongoing.","category":"page"},{"location":"formula/#The-@formula-language","page":"Modeling tabular data","title":"The @formula language","text":"","category":"section"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"StatsModels implements the @formula domain-specific language for describing table-to-matrix transformations.  This language is designed to be familiar to users of other statistical software, while also taking advantage of Julia's unique strengths to be fast and flexible.","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"A basic formula is composed of individual terms—symbols which refer to data columns, or literal numbers 0 or 1—combined by +, &, *, and (at the top level) ~.","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"note: Note\nThe @formula macro must be called with parentheses to ensure that the formula is parsed properly.","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"Here is an example of the @formula in action:","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"julia> using StatsModels, DataFrames\n\njulia> using StableRNGs; rng = StableRNG(1);\n\njulia> f = @formula(y ~ 1 + a + b + c + b&c)\nFormulaTerm\nResponse:\n  y(unknown)\nPredictors:\n  1\n  a(unknown)\n  b(unknown)\n  c(unknown)\n  b(unknown) & c(unknown)\n\njulia> df = DataFrame(y = rand(rng, 9), a = 1:9, b = rand(rng, 9), c = repeat([\"d\",\"e\",\"f\"], 3))\n9×4 DataFrame\n Row │ y          a      b         c\n     │ Float64    Int64  Float64   String\n─────┼────────────────────────────────────\n   1 │ 0.585195       1  0.236782  d\n   2 │ 0.0773379      2  0.943741  e\n   3 │ 0.716628       3  0.445671  f\n   4 │ 0.320357       4  0.763679  d\n   5 │ 0.653093       5  0.145071  e\n   6 │ 0.236639       6  0.021124  f\n   7 │ 0.709684       7  0.152545  d\n   8 │ 0.557787       8  0.617492  e\n   9 │ 0.05079        9  0.481531  f\n\njulia> f = apply_schema(f, schema(f, df))\nFormulaTerm\nResponse:\n  y(continuous)\nPredictors:\n  1\n  a(continuous)\n  b(continuous)\n  c(DummyCoding:3→2)\n  b(continuous) & c(DummyCoding:3→2)\n\njulia> resp, pred = modelcols(f, df);\n\njulia> pred\n9×7 Array{Float64,2}:\n 1.0  1.0  0.236782  0.0  0.0  0.0       0.0\n 1.0  2.0  0.943741  1.0  0.0  0.943741  0.0\n 1.0  3.0  0.445671  0.0  1.0  0.0       0.445671\n 1.0  4.0  0.763679  0.0  0.0  0.0       0.0\n 1.0  5.0  0.145071  1.0  0.0  0.145071  0.0\n 1.0  6.0  0.021124  0.0  1.0  0.0       0.021124\n 1.0  7.0  0.152545  0.0  0.0  0.0       0.0\n 1.0  8.0  0.617492  1.0  0.0  0.617492  0.0\n 1.0  9.0  0.481531  0.0  1.0  0.0       0.481531\n\njulia> coefnames(f)\n(\"y\", [\"(Intercept)\", \"a\", \"b\", \"c: e\", \"c: f\", \"b & c: e\", \"b & c: f\"])\n","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"Let's break down the formula expression y ~ 1 + a + b + c + b&c:","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"At the top level is the formula separator ~, which separates the left-hand (or response) variable y from the right-hand size (or predictor) variables on the right 1 + a + b + c + b&c.","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"The left-hand side has one term y which means that the response variable is the column from the data named :y.  The response can be accessed with the analogous response(f, df) function.","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"note: Note\nTo make a \"one-sided\" formula (with no response), put a 0 on the left-hand side, like @formula(0 ~ 1 + a + b).","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"The right hand side is made up of a number of different terms, separated by +: 1 + a + b + c + b&c.  Each term corresponds to one or more columns in the generated model matrix: ","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"The first term 1 generates a constant or \"intercept\" column full of 1.0s.\nThe next two terms a and b correspond to columns from the data table called :a, :b, which both hold numeric data (Float64 and Int respectively).  By default, numerical columns are assumed to correspond to continuous terms, and are converted to Float64 and copied to the model matrix.\nThe term c corresponds to the :c column in the table, which is not numeric, so it has been contrast coded: there are three unique values or levels, and the default coding scheme (DummyCoding) generates an indicator variable for each level after the first (e.g., df[:c] .== \"b\" and df[:c] .== \"a\").\nThe last term b&c is an interaction term, and generates model matrix columns for each pair of columns generated by the b and c terms. Columns are combined with element-wise multiplication.  Since b generates only a single column and c two, b&c generates two columns, equivalent to df[:b] .* (df[:c] .== \"b\") and df[:b] .* (df[:c] .== \"c\").","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"Because we often want to include both \"main effects\" (b and c) and interactions (b&c) of multiple variables, within a @formula the * operator denotes this \"main effects and interactions\" operation:","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"julia> @formula(y ~ 1 + a + b*c)\nFormulaTerm\nResponse:\n  y(unknown)\nPredictors:\n  1\n  a(unknown)\n  b(unknown)\n  c(unknown)\n  b(unknown) & c(unknown)","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"Also note that the interaction operators & and * are distributive with the term separator +:","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"julia> @formula(y ~ 1 + (a + b) & c)\nFormulaTerm\nResponse:\n  y(unknown)\nPredictors:\n  1\n  a(unknown) & c(unknown)\n  b(unknown) & c(unknown)","category":"page"},{"location":"formula/#Julia-functions-in-a-@formula","page":"Modeling tabular data","title":"Julia functions in a @formula","text":"","category":"section"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"Any calls to Julia functions that don't have special meaning (or are part of an extension provided by a modeling package) are treated like normal Julia code, and evaluated elementwise:","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"julia> modelmatrix(@formula(y ~ 1 + a + log(1+a)), df)\n9×3 Array{Float64,2}:\n 1.0  1.0  0.693147\n 1.0  2.0  1.09861\n 1.0  3.0  1.38629\n 1.0  4.0  1.60944\n 1.0  5.0  1.79176\n 1.0  6.0  1.94591\n 1.0  7.0  2.07944\n 1.0  8.0  2.19722\n 1.0  9.0  2.30259","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"Note that the expression 1 + a is treated differently as part of the formula than in the call to log, where it's interpreted as normal addition.","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"This even applies to custom functions.  For instance, if for some reason you wanted to include a regressor based on a String column that encoded whether any character in a string was after 'e' in the alphabet, you could do","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"julia> gt_e(s) = any(c > 'e' for c in s)\ngt_e (generic function with 1 method)\n\njulia> modelmatrix(@formula(y ~ 1 + gt_e(c)), df)\n9×2 Array{Float64,2}:\n 1.0  0.0\n 1.0  0.0\n 1.0  1.0\n 1.0  0.0\n 1.0  0.0\n 1.0  1.0\n 1.0  0.0\n 1.0  0.0\n 1.0  1.0\n","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"Julia functions like this are evaluated elementwise when the numeric arrays are created for the response and model matrix.  This makes it easy to fit models to transformed data lazily, without creating temporary columns in your table. For instance, to fit a linear regression to a log-transformed response:","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"julia> using GLM\n\njulia> lm(@formula(log(y) ~ 1 + a + b), df)\nStatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}\n\n:(log(y)) ~ 1 + a + b\n\nCoefficients:\n──────────────────────────────────────────────────────────────────────────\n                  Coef.  Std. Error      t  Pr(>|t|)  Lower 95%  Upper 95%\n──────────────────────────────────────────────────────────────────────────\n(Intercept)   0.0698025    0.928295   0.08    0.9425  -2.20165    2.34126\na            -0.105669     0.128107  -0.82    0.4410  -0.419136   0.207797\nb            -1.63199      1.12678   -1.45    0.1977  -4.38911    1.12513\n──────────────────────────────────────────────────────────────────────────\n\njulia> df.log_y = log.(df.y);\n\njulia> lm(@formula(log_y ~ 1 + a + b), df)            # equivalent\nStatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}\n\nlog_y ~ 1 + a + b\n\nCoefficients:\n──────────────────────────────────────────────────────────────────────────\n                  Coef.  Std. Error      t  Pr(>|t|)  Lower 95%  Upper 95%\n──────────────────────────────────────────────────────────────────────────\n(Intercept)   0.0698025    0.928295   0.08    0.9425  -2.20165    2.34126\na            -0.105669     0.128107  -0.82    0.4410  -0.419136   0.207797\nb            -1.63199      1.12678   -1.45    0.1977  -4.38911    1.12513\n──────────────────────────────────────────────────────────────────────────\n","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"The no-op function identity can be used to block the normal formula-specific interpretation of +, *, and &:","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"julia> modelmatrix(@formula(y ~ 1 + b + identity(1+b)), df)\n9×3 Array{Float64,2}:\n 1.0  0.236782  1.23678\n 1.0  0.943741  1.94374\n 1.0  0.445671  1.44567\n 1.0  0.763679  1.76368\n 1.0  0.145071  1.14507\n 1.0  0.021124  1.02112\n 1.0  0.152545  1.15255\n 1.0  0.617492  1.61749\n 1.0  0.481531  1.48153","category":"page"},{"location":"formula/#Constructing-a-formula-programmatically","page":"Modeling tabular data","title":"Constructing a formula programmatically","text":"","category":"section"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"A formula can be constructed at runtime by creating Terms and combining them with the formula operators +, &, and ~:","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"julia> Term(:y) ~ ConstantTerm(1) + Term(:a) + Term(:b) + Term(:a) & Term(:b)\nFormulaTerm\nResponse:\n  y(unknown)\nPredictors:\n  1\n  a(unknown)\n  b(unknown)\n  a(unknown) & b(unknown)","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"warning: Warning\nEven though the @formula macro supports arbitrary julia functions, runtime (programmatic) formula construction does not.  This is because to resolve a symbol giving a function's name into the actual function itself, it's necessary to eval.  In practice this is not often an issue, except in cases where a package provides special syntax by overloading a function (like | for MixedModels.jl, or absorb for Econometrics.jl).  In these cases, you should use the corresponding constructors for the actual terms themselves (e.g., RanefTerm and FixedEffectsTerm respectively), as long as the packages have implemented support for them.","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"The term function constructs a term of the appropriate type from symbols or strings (Term) and numbers (ConstantTerm), which makes it easy to  work with collections of mixed type:","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"julia> ts = term.((1, :a, \"b\"))\n1\na(unknown)\nb(unknown)","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"These can then be combined with standard reduction techniques:","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"julia> f1 = term(:y) ~ foldl(+, ts)\nFormulaTerm\nResponse:\n  y(unknown)\nPredictors:\n  1\n  a(unknown)\n  b(unknown)\n\njulia> f2 = term(:y) ~ sum(ts)\nFormulaTerm\nResponse:\n  y(unknown)\nPredictors:\n  1\n  a(unknown)\n  b(unknown)\n\njulia> f1 == f2 == @formula(y ~ 1 + a + b)\ntrue\n","category":"page"},{"location":"formula/#Fitting-a-model-from-a-formula","page":"Modeling tabular data","title":"Fitting a model from a formula","text":"","category":"section"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"The main use of @formula is to streamline specifying and fitting statistical models based on tabular data.  From the user's perspective, this is done by fit methods that take a FormulaTerm and a table instead of numeric matrices.","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"As an example, we'll simulate some data from a linear regression model with an interaction term, a continuous predictor, a categorical predictor, and the interaction of the two, and then fit a GLM.LinearModel to recover the simulated coefficients.","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"julia> using GLM, DataFrames, StatsModels\n\njulia> using StableRNGs; rng = StableRNG(1);\n\njulia> data = DataFrame(a = rand(rng, 100), b = repeat([\"d\", \"e\", \"f\", \"g\"], 25));\n\njulia> X = StatsModels.modelmatrix(@formula(y ~ 1 + a*b).rhs, data);\n\njulia> β_true = 1:8;\n\njulia> ϵ = randn(rng, 100)*0.1;\n\njulia> data.y = X*β_true .+ ϵ;\n\njulia> mod = fit(LinearModel, @formula(y ~ 1 + a*b), data)\nStatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}\n\ny ~ 1 + a + b + a & b\n\nCoefficients:\n───────────────────────────────────────────────────────────────────────\n               Coef.  Std. Error      t  Pr(>|t|)  Lower 95%  Upper 95%\n───────────────────────────────────────────────────────────────────────\n(Intercept)  1.01518   0.0400546  25.34    <1e-42   0.935626    1.09473\na            1.97476   0.0701427  28.15    <1e-46   1.83545     2.11407\nb: e         3.01269   0.0571186  52.74    <1e-69   2.89925     3.12614\nb: f         4.01918   0.065827   61.06    <1e-75   3.88844     4.14992\nb: g         4.99176   0.0593715  84.08    <1e-88   4.87385     5.10968\na & b: e     5.98288   0.0954641  62.67    <1e-76   5.79328     6.17248\na & b: f     6.98622   0.107871   64.76    <1e-77   6.77197     7.20046\na & b: g     7.92541   0.109873   72.13    <1e-82   7.70719     8.14362\n───────────────────────────────────────────────────────────────────────\n","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"Internally, this is accomplished in three steps:","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"The expression passed to @formula is lowered to term constructors combined by ~, +, and &, which evaluate to create terms for the whole formula and any interaction terms.\nA schema is extracted from the data, which determines whether each variable is continuous or categorical and extracts the summary statistics of each variable (mean/variance/min/max or unique levels respectively).  This schema is then applied to the formula with apply_schema(term, schema, ::Type{Model}), which returns a new formula with each placeholder Term replaced with a concrete ContinuousTerm or CategoricalTerm as appropriate.  This is also the stage where any custom syntax is applied (see the section on extending the @formula language for more details).\nNumeric arrays are generated for the response and predictors from the full table using modelcols(term, data).","category":"page"},{"location":"formula/","page":"Modeling tabular data","title":"Modeling tabular data","text":"The ModelFrame and ModelMatrix types can still be used to do this transformation, but this is only to preserve some backwards compatibility. Package authors who would like to include support for fitting models from a @formula are strongly encouraged to directly use schema, apply_schema, and modelcols to handle the table-to-matrix transformations they need.","category":"page"},{"location":"temporal_terms/#Temporal-Terms-(Lag/Lead)","page":"Temporal variables and Time Series Terms","title":"Temporal Terms (Lag/Lead)","text":"","category":"section"},{"location":"temporal_terms/","page":"Temporal variables and Time Series Terms","title":"Temporal variables and Time Series Terms","text":"When working with time series data it is common to want to access past or future values of your predictors. These are called lagged (past) or lead (future) variables.","category":"page"},{"location":"temporal_terms/","page":"Temporal variables and Time Series Terms","title":"Temporal variables and Time Series Terms","text":"StatsModels supports basic lead and lag functionality:","category":"page"},{"location":"temporal_terms/","page":"Temporal variables and Time Series Terms","title":"Temporal variables and Time Series Terms","text":"lag(x, n) accesses data for variable x from n rows (time steps) ago.\nlead(x, n) accesses data for variable x from n rows (time steps) ahead.","category":"page"},{"location":"temporal_terms/","page":"Temporal variables and Time Series Terms","title":"Temporal variables and Time Series Terms","text":"In both cases, n can be omitted, and it defaults to 1 row. missing is used for any entries that are lagged or lead out of the table.","category":"page"},{"location":"temporal_terms/","page":"Temporal variables and Time Series Terms","title":"Temporal variables and Time Series Terms","text":"Note that this is a purely structural lead/lag term: it is unaware of any time index of the data. It is up to the user to ensure the data is sorted, and following a regular time interval, which may require inserting additional rows containing missings  to fill in gaps in irregular data.","category":"page"},{"location":"temporal_terms/","page":"Temporal variables and Time Series Terms","title":"Temporal variables and Time Series Terms","text":"Below is a simple example:","category":"page"},{"location":"temporal_terms/","page":"Temporal variables and Time Series Terms","title":"Temporal variables and Time Series Terms","text":"julia> using StatsModels, DataFrames\n\njulia> df = DataFrame(y=1:5, x=2:2:10)\n5×2 DataFrame\n Row │ y      x\n     │ Int64  Int64\n─────┼──────────────\n   1 │     1      2\n   2 │     2      4\n   3 │     3      6\n   4 │     4      8\n   5 │     5     10\n\njulia> f = @formula(y ~ x + lag(x, 2) + lead(x, 2))\nFormulaTerm\nResponse:\n  y(unknown)\nPredictors:\n  x(unknown)\n  (x)->lag(x, 2)\n  (x)->lead(x, 2)\n\njulia> f = apply_schema(f, schema(f, df))\nFormulaTerm\nResponse:\n  y(continuous)\nPredictors:\n  x(continuous)\n  lag(x, 2)\n  lead(x, 2)\n\njulia> modelmatrix(f, df)\n5×3 reshape(::Array{Union{Missing, Int64},2}, 5, 3) with eltype Union{Missing, Int64}:\n  2   missing   6\n  4   missing   8\n  6  2         10\n  8  4           missing\n 10  6           missing","category":"page"},{"location":"temporal_terms/#Programmatic-construction-of-lead-and-lag-terms","page":"Temporal variables and Time Series Terms","title":"Programmatic construction of lead and lag terms","text":"","category":"section"},{"location":"temporal_terms/","page":"Temporal variables and Time Series Terms","title":"Temporal variables and Time Series Terms","text":"StatsModels.jl provides methods for lead and lag that allow LeadLagTerms to be constructed programmatically (at run time).  See the section on Constructing a formula programmatically for more information.  For a short example, you can produce the same formula as above without the @formula macro like this:","category":"page"},{"location":"temporal_terms/","page":"Temporal variables and Time Series Terms","title":"Temporal variables and Time Series Terms","text":"julia> y, x = term(:y), term(:x);\n\njulia> f2 = y ~ x + lag(x, 2) + lead(x, 2)\nFormulaTerm\nResponse:\n  y(unknown)\nPredictors:\n  x(unknown)\n  lag(x, 2)\n  lead(x, 2)\n\njulia> f2 = apply_schema(f2, schema(f2, df))\nFormulaTerm\nResponse:\n  y(continuous)\nPredictors:\n  x(continuous)\n  lag(x, 2)\n  lead(x, 2)\n\njulia> modelmatrix(f2, df)\n5×3 reshape(::Array{Union{Missing, Int64},2}, 5, 3) with eltype Union{Missing, Int64}:\n  2   missing   6       \n  4   missing   8       \n  6  2         10       \n  8  4           missing\n 10  6           missing","category":"page"},{"location":"#StatsModels-Documentation","page":"Introduction","title":"StatsModels Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides common abstractions and utilities for specifying, fitting, and evaluating statistical models.  The goal is to provide an API for package developers implementing different kinds of statistical models (see the GLM package for example), and utilities that are generally useful for both users and developers when dealing with statistical models and tabular data.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Formula notation for transforming tabular data into numerical arrays for modeling.\nMechanisms for extending the @formula notation in external modeling packages.\nContrast coding for categorical data\nTypes and API for fitting and working with statistical models, extending StatsBase.jl's API to tabular data.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Note\nMuch of this package was formerly part of DataFrames.jl and historically only handled tabular data in the form of a DataFrame, but currently supports any table that supports the minimal Tables.jl interface.  It's thus a relatively light dependency.","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"DocTestSetup = quote\n    using StatsModels\nend\nDocTestFilters = [r\"([a-z]*) => \\1\"]","category":"page"},{"location":"internals/#Internals-and-extending-the-formula-DSL","page":"Internals and extending the @formula","title":"Internals and extending the formula DSL","text":"","category":"section"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"This section is intended to help package developers understand the internals of how a @formula becomes a numerical matrix, in order to use, manipulate, and even extend the DSL.  The Julia @formula is designed to be as extensible as possible through the normal Julian mechanisms of multiple dispatch.","category":"page"},{"location":"internals/#The-lifecycle-of-a-@formula","page":"Internals and extending the @formula","title":"The lifecycle of a @formula","text":"","category":"section"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"A formula goes through a number of stages, starting as an expression that's passed to the @formula macro and ending up generating a numeric matrix when ultimately combined with a tabular data source:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"\"Syntax time\" when only the surface syntax is available, when the @formula macro is invoked.\n\"Schema time\" incorporates information about data invariants (types of each variable, levels of categorical variables, summary statistics for continuous variables) and the overall structure of the data, during the invocation of schema.\n\"Semantics time\" incorporates information about the model type (context), and custom terms, during the call to apply_schema.\n\"Data time\" when the actual data values themselves are available.","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"For in-memory (columnar) tables, there is not much difference between \"data time\" and \"schema time\" in practice, but in principle it's important to distinguish between these when dealing with truly streaming data, or large data stores where calculating invariants of the data may be expensive.","category":"page"},{"location":"internals/#Syntax-time-(@formula)","page":"Internals and extending the @formula","title":"Syntax time (@formula)","text":"","category":"section"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"The @formula macro does syntactic transformations of the formula expression. At this point, only the expression itself is available, and there's no way to know whether a term corresponds to a continuous or categorical variable.","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"For standard formulae, this amounts to applying the syntactic rules for the DSL operators (expanding * and applying the distributive and associative rules), and wrapping each symbol in a Term constructor:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> @macroexpand @formula(y ~ 1 + a*b)\n:(Term(:y) ~ ConstantTerm(1) + Term(:a) + Term(:b) + Term(:a) & Term(:b))","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"Note that much of the action happens outside the @formula macro, when the expression returned by the @formula macro is evaluated.  At this point, the Terms are combined to create higher-order terms via overloaded methods for ~, +, and &:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> using StatsModels;\n\njulia> dump(Term(:a) & Term(:b))\nInteractionTerm{Tuple{Term,Term}}\n  terms: Tuple{Term,Term}\n    1: Term\n      sym: Symbol a\n    2: Term\n      sym: Symbol b\n\njulia> dump(Term(:a) + Term(:b))\nTuple{Term,Term}\n  1: Term\n    sym: Symbol a\n  2: Term\n    sym: Symbol b\n\njulia> dump(Term(:y) ~ Term(:a))\nFormulaTerm{Term,Term}\n  lhs: Term\n    sym: Symbol y\n  rhs: Term\n    sym: Symbol a","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"note: Note\nAs always, you can introspect which method is called withjulia> @which Term(:a) & Term(:b)\n&(terms::AbstractTerm...) in StatsModels at /home/dave/.julia/dev/StatsModels/src/terms.jl:399","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"The reason that the actual construction of higher-order terms is done after the macro is expanded is that it makes it much easier to create a formula programmatically:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> f = Term(:y) ~ sum(term.([1, :a, :b, :c]))\nFormulaTerm\nResponse:\n  y(unknown)\nPredictors:\n  1\n  a(unknown)\n  b(unknown)\n  c(unknown)\n\njulia> f == @formula(y ~ 1 + a + b + c)\ntrue","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"The major exception to this is that non-DSL calls must be specified using the @formula macro.  The reason for this is that non-DSL calls are \"captured\" and turned into anonymous functions that can be evaluated elementwise, which has to happen at compile time.  For instance, the call to log in @formula(y ~ log(a+b)) is converted into the anonymous function (a,b) -> log(a+b).","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"Internally a lot of the work at syntax time is done by the parse! function.","category":"page"},{"location":"internals/#Schema-time-(schema)","page":"Internals and extending the @formula","title":"Schema time (schema)","text":"","category":"section"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"The next phase of life for a formula requires some information about the data it will be used with.  This is represented by a schema, a mapping from placeholder Terms to concrete terms—like ContinuousTerm CategoricalTerm—which represent all the summary information about a data column necessary to create a model matrix from that column.","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"There are a number of ways to construct a schema, ranging from fully automatic to fully manual.","category":"page"},{"location":"internals/#Fully-automatic:-schema","page":"Internals and extending the @formula","title":"Fully automatic: schema","text":"","category":"section"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"The most convenient way to automatically compute a schema is with the schema function.  By default, it will create a schema for every column in the data:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> using DataFrames    # for pretty printing---any Table will do\n\njulia> using StableRNGs; rng = StableRNG(1);\n\njulia> df = DataFrame(y = rand(rng, 9), a = 1:9, b = rand(rng, 9), c = repeat([\"a\",\"b\",\"c\"], 3))\n9×4 DataFrame\n Row │ y          a      b         c\n     │ Float64    Int64  Float64   String\n─────┼────────────────────────────────────\n   1 │ 0.585195       1  0.236782  a\n   2 │ 0.0773379      2  0.943741  b\n   3 │ 0.716628       3  0.445671  c\n   4 │ 0.320357       4  0.763679  a\n   5 │ 0.653093       5  0.145071  b\n   6 │ 0.236639       6  0.021124  c\n   7 │ 0.709684       7  0.152545  a\n   8 │ 0.557787       8  0.617492  b\n   9 │ 0.05079        9  0.481531  c\n\njulia> schema(df)\nStatsModels.Schema with 4 entries:\n  y => y\n  a => a\n  b => b\n  c => c","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"However, if a term (including a FormulaTerm) is provided, the schema will be computed based only on the necessary variables:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> schema(@formula(y ~ 1 + a), df)\nStatsModels.Schema with 2 entries:\n  y => y\n  a => a\n\njulia> schema(Term(:a) + Term(:b), df)\nStatsModels.Schema with 2 entries:\n  a => a\n  b => b","category":"page"},{"location":"internals/#Fully-manual:-term-constructors","page":"Internals and extending the @formula","title":"Fully manual: term constructors","text":"","category":"section"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"While schema is a convenient way to generate a schema automatically from a data source, in some cases it may be preferable to create a schema manually.  In particular, schema peforms a complete sweep through the data, and if your dataset is very large or truly streaming (online), then this may be undesirable.  In such cases, you can construct a schema from instances of the relevant concrete terms (ContinuousTerm or CategoricalTerm), in a number of ways.","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"The constructors for concrete terms provide the maximum level of control.  A ContinuousTerm stores values for the mean, standard deviation, minimum, and maximum, while a CategoricalTerm stores the StatsModels.ContrastsMatrix that defines the mapping from levels to predictors, and these need to be manually supplied to the constructors:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"warning: Warning\nThe format of the invariants stored in a term are implementation details and subject to change.","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> cont_a = ContinuousTerm(:a, 0., 1., -1., 1.)\na(continuous)\n\njulia> cat_b = CategoricalTerm(:b, StatsModels.ContrastsMatrix(DummyCoding(), [:a, :b, :c]))\nb(DummyCoding:3→2)","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"The Term-concrete term pairs can then be passed to the StatsModels.Schema constructor (a wrapper for the underlying Dict{Term,AbstractTerm}):","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> sch1 = StatsModels.Schema(term(:a) => cont_a, term(:b) => cat_b)\nStatsModels.Schema with 2 entries:\n  a => a\n  b => b","category":"page"},{"location":"internals/#Semi-automatic:-data-subsets","page":"Internals and extending the @formula","title":"Semi-automatic: data subsets","text":"","category":"section"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"A slightly more convenient method for generating a schema is provided by the concrete_term internal function, which extracts invariants from a data column and returns a concrete type.  This can be used to generate concrete terms from data vectors constructed to have the same invariants that you care about in your actual data (e.g., the same unique values for categorical data, and the same minimum/maximum values or the same mean/variance for continuous):","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> cont_a2 = concrete_term(term(:a), [-1., 1.])\na(continuous)\n\njulia> cat_b2 = concrete_term(term(:b), [:a, :b, :c])\nb(DummyCoding:3→2)\n\njulia> sch2 = StatsModels.Schema(term(:a) => cont_a2, term(:b) => cat_b2)\nStatsModels.Schema with 2 entries:\n  a => a\n  b => b","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"Finally, you could also call schema on a NamedTuple of vectors (e.g., a Tables.ColumnTable) with the necessary invariants:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> sch3 = schema((a=[-1., 1], b=[:a, :b, :c]))\nStatsModels.Schema with 2 entries:\n  a => a\n  b => b","category":"page"},{"location":"internals/#Semantics-time-(apply_schema)","page":"Internals and extending the @formula","title":"Semantics time (apply_schema)","text":"","category":"section"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"The next stage of life for a formula happens when semantic information is available, which includes the schema of the data to be transformed as well as the context, or the type of model that will be fit.  This stage is implemented by apply_schema.  Among other things, this instantiates placeholder terms:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"Terms become ContinuousTerms or CategoricalTerms\nConstantTerms become InterceptTerms\nTuples of terms become MatrixTerms where appropriate to explicitly indicate they should be concatenated into a single model matrix\nAny model-specific (context-specific) interpretation of the terms is made, including transforming calls to functions that have special meaning in particular contexts into their special term types (see the section on Extending @formula syntax below)","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> f = @formula(y ~ 1 + a + b * c)\nFormulaTerm\nResponse:\n  y(unknown)\nPredictors:\n  1\n  a(unknown)\n  b(unknown)\n  c(unknown)\n  b(unknown) & c(unknown)\n\njulia> typeof(f)\nFormulaTerm{Term,Tuple{ConstantTerm{Int64},Term,Term,Term,InteractionTerm{Tuple{Term,Term}}}}\n\njulia> f = apply_schema(f, schema(f, df))\nFormulaTerm\nResponse:\n  y(continuous)\nPredictors:\n  1\n  a(continuous)\n  b(continuous)\n  c(DummyCoding:3→2)\n  b(continuous) & c(DummyCoding:3→2)\n\njulia> typeof(f)\nFormulaTerm{ContinuousTerm{Float64},MatrixTerm{Tuple{InterceptTerm{true},ContinuousTerm{Float64},ContinuousTerm{Float64},CategoricalTerm{DummyCoding,String,2},InteractionTerm{Tuple{ContinuousTerm{Float64},CategoricalTerm{DummyCoding,String,2}}}}}}","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"This transformation is done by calling apply_schema(term, schema, modeltype) recursively on each term (the modeltype defaults to StatisticalModel when fitting a statistical model, and Nothing if apply_schema is called with only two arguments).  Because apply_schema dispatches on the term, schema, and model type, this stage allows generic context-aware transformations, based on both the source (schema) and the destination (model type).  This is the primary mechanisms by which the formula DSL can be extended (see below for more details)","category":"page"},{"location":"internals/#Data-time-(modelcols)","page":"Internals and extending the @formula","title":"Data time (modelcols)","text":"","category":"section"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"At the end of \"schema time\", a formula encapsulates all the information needed to convert a table into a numeric model matrix.  That is, it is ready for \"data time\".  The main API method is modelcols, which when applied to a FormulaTerm returns a tuple of the numeric forms for the left- (response) and right-hand (predictor) sides.","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> resp, pred = modelcols(f, df);\n\njulia> resp\n9-element Array{Float64,1}:\n 0.5851946422124186\n 0.07733793456911231\n 0.7166282400543453\n 0.3203570514066232\n 0.6530930076222579\n 0.2366391513734556\n 0.7096838914472361\n 0.5577872440804086\n 0.05079002172175784\n\njulia> pred\n9×7 Array{Float64,2}:\n 1.0  1.0  0.236782  0.0  0.0  0.0       0.0\n 1.0  2.0  0.943741  1.0  0.0  0.943741  0.0\n 1.0  3.0  0.445671  0.0  1.0  0.0       0.445671\n 1.0  4.0  0.763679  0.0  0.0  0.0       0.0\n 1.0  5.0  0.145071  1.0  0.0  0.145071  0.0\n 1.0  6.0  0.021124  0.0  1.0  0.0       0.021124\n 1.0  7.0  0.152545  0.0  0.0  0.0       0.0\n 1.0  8.0  0.617492  1.0  0.0  0.617492  0.0\n 1.0  9.0  0.481531  0.0  1.0  0.0       0.481531\n","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"modelcols can also take a single row from a table, as a NamedTuple:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> using Tables\n\njulia> modelcols(f, first(Tables.rowtable(df)))\n(0.5851946422124186, [1.0, 1.0, 0.236781883208121, 0.0, 0.0, 0.0, 0.0])\n","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"Any AbstractTerm can be passed to modelcols with a table, which returns one or more numeric arrays:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> t = f.rhs.terms[end]\nb(continuous) & c(DummyCoding:3→2)\n\njulia> modelcols(t, df)\n9×2 Array{Float64,2}:\n 0.0       0.0\n 0.943741  0.0\n 0.0       0.445671\n 0.0       0.0\n 0.145071  0.0\n 0.0       0.021124\n 0.0       0.0\n 0.617492  0.0\n 0.0       0.481531\n","category":"page"},{"location":"internals/#extending","page":"Internals and extending the @formula","title":"Extending @formula syntax","text":"","category":"section"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"Package authors may want to create additional syntax to the @formula DSL so their users can conveniently specify particular kinds of models.  StatsModels.jl provides mechanisms for such extensions that do not rely on compile time \"macro magic\", but on standard julian mechanisms of multiple dispatch.","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"Extensions have three components:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"Syntax: the Julia function which is given special meaning inside a formula.\nContext: the model type(s) where this extension applies\nBehavior: how tabular data is transformed under this extension","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"These correspond to the stages summarized above (syntax time, schema time, and data time)","category":"page"},{"location":"internals/#An-example-of-custom-syntax:-poly","page":"Internals and extending the @formula","title":"An example of custom syntax: poly","text":"","category":"section"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"As an example, we'll add syntax for specifying a polynomial regression model, which fits a regression using polynomial basis functions of a continuous predictor.","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"The first step is to specify the syntax we're going to use.  While it's possible to use an existing function, the best practice is to define a new function to make dispatch less ambiguous.","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"using StatsBase\n# syntax: best practice to define a _new_ function\npoly(x, n) = x^n\n\n# type of model where syntax applies: here this applies to any model type\nconst POLY_CONTEXT = Any\n\n# struct for behavior\nstruct PolyTerm{T,D} <: AbstractTerm\n    term::T\n    deg::D\nend\n\nBase.show(io::IO, p::PolyTerm) = print(io, \"poly($(p.term), $(p.deg))\")\n\n# for `poly` use at run-time (outside @formula), return a schema-less PolyTerm\npoly(t::Symbol, d::Int) = PolyTerm(term(t), term(d))\n\n# for `poly` use inside @formula: create a schemaless PolyTerm and apply_schema\nfunction StatsModels.apply_schema(t::FunctionTerm{typeof(poly)},\n                                  sch::StatsModels.Schema,\n                                  Mod::Type{<:POLY_CONTEXT})\n    apply_schema(PolyTerm(t.args_parsed...), sch, Mod)\nend\n\n# apply_schema to internal Terms and check for proper types\nfunction StatsModels.apply_schema(t::PolyTerm,\n                                  sch::StatsModels.Schema,\n                                  Mod::Type{<:POLY_CONTEXT})\n    term = apply_schema(t.term, sch, Mod)\n    isa(term, ContinuousTerm) ||\n        throw(ArgumentError(\"PolyTerm only works with continuous terms (got $term)\"))\n    isa(t.deg, ConstantTerm) ||\n        throw(ArgumentError(\"PolyTerm degree must be a number (got $t.deg)\"))\n    PolyTerm(term, t.deg.n)\nend\n\nfunction StatsModels.modelcols(p::PolyTerm, d::NamedTuple)\n    col = modelcols(p.term, d)\n    reduce(hcat, [col.^n for n in 1:p.deg])\nend\n\n# the basic terms contained within a PolyTerm (for schema extraction)\nStatsModels.terms(p::PolyTerm) = terms(p.term)\n# names variables from the data that a PolyTerm relies on\nStatsModels.termvars(p::PolyTerm) = StatsModels.termvars(p.term)\n# number of columns in the matrix this term produces\nStatsModels.width(p::PolyTerm) = p.deg\n\nStatsBase.coefnames(p::PolyTerm) = coefnames(p.term) .* \"^\" .* string.(1:p.deg)\n\n# output\n\n","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"Now, we can use poly in a formula:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> data = DataFrame(y = rand(rng, 4), a = rand(rng, 4), b = [1:4;])\n4×3 DataFrame\n Row │ y         a         b\n     │ Float64   Float64   Int64\n─────┼───────────────────────────\n   1 │ 0.752223  0.757746      1\n   2 │ 0.314815  0.419294      2\n   3 │ 0.858522  0.412607      3\n   4 │ 0.698713  0.454589      4\n\njulia> f = @formula(y ~ 1 + poly(b, 2) * a)\nFormulaTerm\nResponse:\n  y(unknown)\nPredictors:\n  1\n  (b)->poly(b, 2)\n  a(unknown)\n  (b)->poly(b, 2) & a(unknown)\n\njulia> f = apply_schema(f, schema(data))\nFormulaTerm\nResponse:\n  y(continuous)\nPredictors:\n  1\n  poly(b, 2)\n  a(continuous)\n  poly(b, 2) & a(continuous)\n\njulia> modelcols(f.rhs, data)\n4×6 Array{Float64,2}:\n 1.0  1.0   1.0  0.757746  0.757746  0.757746\n 1.0  2.0   4.0  0.419294  0.838587  1.67717\n 1.0  3.0   9.0  0.412607  1.23782   3.71347\n 1.0  4.0  16.0  0.454589  1.81836   7.27343\n\njulia> coefnames(f.rhs)\n6-element Array{String,1}:\n \"(Intercept)\"\n \"b^1\"\n \"b^2\"\n \"a\"\n \"b^1 & a\"\n \"b^2 & a\"\n","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"And in a linear regression, with simulated data where there is an effect of a^1 and of b^2 (but not a^2 or b^1):","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> using GLM\n\njulia> sim_dat = DataFrame(a=rand(rng, 100).-0.5, b=randn(rng, 100).-0.5);\n\njulia> sim_dat.y = randn(rng, 100) .+ 1 .+ 2*sim_dat.a .+ 3*sim_dat.b.^2;\n\njulia> fit(LinearModel, @formula(y ~ 1 + poly(a,2) + poly(b,2)), sim_dat)\nStatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}\n\ny ~ 1 + poly(a, 2) + poly(b, 2)\n\nCoefficients:\n──────────────────────────────────────────────────────────────────────────\n                 Coef.  Std. Error      t  Pr(>|t|)   Lower 95%  Upper 95%\n──────────────────────────────────────────────────────────────────────────\n(Intercept)   0.89288    0.181485    4.92    <1e-5    0.532586    1.25317\na^1           2.73324    0.349194    7.83    <1e-11   2.04001     3.42648\na^2          -1.0114     1.34262    -0.75    0.4531  -3.67684     1.65404\nb^1           0.214424   0.136868    1.57    0.1205  -0.0572944   0.486142\nb^2           3.15133    0.0811794  38.82    <1e-59   2.99016     3.31249\n──────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"internals/#extend-runtime","page":"Internals and extending the @formula","title":"Making special syntax \"runtime friendly\"","text":"","category":"section"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"When used from the @formula macro, special syntax relies on dispatching on the FunctionTerm{MyFunction} type.  But when creating a formula at runtime without the @formula macro, FunctionTerms aren't available, and so care must be taken to make sure you provide a runtime replacement.  The example for poly above shows how to do this, but we spell it out here in more detail.","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"The first step is to make sure you can create a schema-less instance of the AbstractTerm that implements your special syntax behavior.  For the poly example, that means we need to be able to create a PolyTerm(term(column_name), term(poly_degree)).  In order to do this, the types of the term and deg fields aren't specified but are parameters of the PolyTerm type.","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"The second step is to provide a runtime method for the special syntax function (poly), which accepts arguments in form that's convenient at runtime.  For this example, we've defined poly(s::Symbol, i::Int) = PolyTerm(term(s), term(i)):","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> pt = poly(:a, 3)\npoly(a, 3)\n\njulia> typeof(pt) # contains schema-less `Term`\nPolyTerm{Term,ConstantTerm{Int64}}","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"note: Note\nThe functions like poly should be exported by the package that provides the special syntax for two reasons.  First, it makes run-time term  construction more convenient.  Second, because of how the @formula macro generates code, the function that represents special syntax must be available in the namespace where @formula is called.  This is because calls to arbitrary functions f are lowered to FunctionTerm{typeof(f)}.","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"Now we can programmatically construct PolyTerms at run-time:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> my_col = :a; my_degree = 3;\n\njulia> poly(my_col, my_degree)\npoly(a, 3)\n\njulia> poly.([:a, :b], my_degree)\n2-element Array{PolyTerm{Term,ConstantTerm{Int64}},1}:\n poly(a, 3)\n poly(b, 3)","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"These run-time PolyTerms are \"schema-less\" though, and to be able to construct a model matrix from them we need to have a way to apply a schema.  Thus, the third and final step is to provide an apply_schema method that upgrades a schema-less instance to one with a schema (i.e., one that can be used with modelcols).  For example, we've specified apply_schema(pt::PolyTerm, ...) which calls apply_schema on the wrapped pt.term, returning a new PolyTerm with the instantiated result:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> pt = apply_schema(PolyTerm(term(:b), term(2)),\n                         schema(data),\n                         StatisticalModel)\npoly(b, 2)\n\njulia> typeof(pt) # now holds a `ContinuousTerm`\nPolyTerm{ContinuousTerm{Float64},Int64}\n\njulia> modelcols(pt, data)\n4×2 Array{Int64,2}:\n 1   1\n 2   4\n 3   9\n 4  16","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"Now with these methods in place, we can run exactly the same polynomial regression as above (which used @formula(y ~ 1 + poly(a, 2) + poly(b, 2)), but with the predictor names and the polynomial degree stored in variables:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> poly_vars = (:a, :b); poly_deg = 2;\n\njulia> poly_formula = term(:y) ~ term(1) + poly.(poly_vars, poly_deg)\nFormulaTerm\nResponse:\n  y(unknown)\nPredictors:\n  1\n  poly(a, 2)\n  poly(b, 2)\n\njulia> fit(LinearModel, poly_formula, sim_dat)\nStatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}\n\ny ~ 1 + poly(a, 2) + poly(b, 2)\n\nCoefficients:\n──────────────────────────────────────────────────────────────────────────\n                 Coef.  Std. Error      t  Pr(>|t|)   Lower 95%  Upper 95%\n──────────────────────────────────────────────────────────────────────────\n(Intercept)   0.89288    0.181485    4.92    <1e-5    0.532586    1.25317\na^1           2.73324    0.349194    7.83    <1e-11   2.04001     3.42648\na^2          -1.0114     1.34262    -0.75    0.4531  -3.67684     1.65404\nb^1           0.214424   0.136868    1.57    0.1205  -0.0572944   0.486142\nb^2           3.15133    0.0811794  38.82    <1e-59   2.99016     3.31249\n──────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"internals/#Defining-the-context-where-special-syntax-applies","page":"Internals and extending the @formula","title":"Defining the context where special syntax applies","text":"","category":"section"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"The third argument to apply_schema determines the contexts in which the special poly syntax applies.","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"For instance, it's possible to block interpretation of the poly syntax as special in certain contexts by adding additional (more specific) methods.  If for some reason we wanted to block PolyTerms being generated for GLM.LinearModel, then we just need to add the appropriate method:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> StatsModels.apply_schema(t::FunctionTerm{typeof(poly)},\n                                sch::StatsModels.Schema,\n                                Mod::Type{GLM.LinearModel}) = t","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"Now in the context of a LinearModel, the poly is interpreted as a call to the \"vanilla\" function defined first, which just raises its first argument to the designated power:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> f = apply_schema(@formula(y ~ 1 + poly(b,2) * a),\n                        schema(data),\n                        GLM.LinearModel)\nFormulaTerm\nResponse:\n  y(continuous)\nPredictors:\n  1\n  (b)->poly(b, 2)\n  a(continuous)\n  (b)->poly(b, 2) & a(continuous)\n\njulia> modelcols(f.rhs, data)\n4×4 Array{Float64,2}:\n 1.0   1.0  0.757746  0.757746\n 1.0   4.0  0.419294  1.67717\n 1.0   9.0  0.412607  3.71347\n 1.0  16.0  0.454589  7.27343\n\njulia> coefnames(f.rhs)\n4-element Array{String,1}:\n \"(Intercept)\"\n \"poly(b, 2)\"\n \"a\"\n \"poly(b, 2) & a\"\n","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"But by using a different context (e.g., the related but more general GLM.GeneralizedLinearModel) we get the custom interpretation:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> f2 = apply_schema(@formula(y ~ 1 + poly(b,2) * a),\n                         schema(data),\n                         GLM.GeneralizedLinearModel)\nFormulaTerm\nResponse:\n  y(continuous)\nPredictors:\n  1\n  poly(b, 2)\n  a(continuous)\n  poly(b, 2) & a(continuous)\n\njulia> modelcols(f2.rhs, data)\n4×6 Array{Float64,2}:\n 1.0  1.0   1.0  0.757746  0.757746  0.757746\n 1.0  2.0   4.0  0.419294  0.838587  1.67717\n 1.0  3.0   9.0  0.412607  1.23782   3.71347\n 1.0  4.0  16.0  0.454589  1.81836   7.27343\n\njulia> coefnames(f2.rhs)\n6-element Array{String,1}:\n \"(Intercept)\"\n \"b^1\"\n \"b^2\"\n \"a\"\n \"b^1 & a\"\n \"b^2 & a\"","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"The definitions of these methods control how models of each type are fit from a formula with a call to poly:","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"julia> sim_dat = DataFrame(b=randn(rng, 100));\n\njulia> sim_dat.y = randn(rng, 100) .+ 1 .+ 2*sim_dat.b .+ 3*sim_dat.b.^2;\n\njulia> fit(LinearModel, @formula(y ~ 1 + poly(b,2)), sim_dat)\nStatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}\n\ny ~ 1 + :(poly(b, 2))\n\nCoefficients:\n───────────────────────────────────────────────────────────────────────\n               Coef.  Std. Error      t  Pr(>|t|)  Lower 95%  Upper 95%\n───────────────────────────────────────────────────────────────────────\n(Intercept)  1.28118    0.324615   3.95    0.0001   0.636991    1.92537\npoly(b, 2)   2.95861    0.174347  16.97    <1e-30   2.61262     3.30459\n───────────────────────────────────────────────────────────────────────\n\njulia> fit(GeneralizedLinearModel, @formula(y ~ 1 + poly(b,2)), sim_dat, Normal())\nStatsModels.TableRegressionModel{GeneralizedLinearModel{GLM.GlmResp{Array{Float64,1},Normal{Float64},IdentityLink},GLM.DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}\n\ny ~ 1 + poly(b, 2)\n\nCoefficients:\n────────────────────────────────────────────────────────────────────────\n                Coef.  Std. Error      z  Pr(>|z|)  Lower 95%  Upper 95%\n────────────────────────────────────────────────────────────────────────\n(Intercept)  0.906356   0.132613    6.83    <1e-11    0.64644    1.16627\nb^1          2.03194    0.0908937  22.36    <1e-99    1.85379    2.21008\nb^2          3.02886    0.0707228  42.83    <1e-99    2.89025    3.16748\n────────────────────────────────────────────────────────────────────────\n","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"(a GeneralizeLinearModel with a Normal distribution is equivalent to a LinearModel)","category":"page"},{"location":"internals/#Summary","page":"Internals and extending the @formula","title":"Summary","text":"","category":"section"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"\"Custom syntax\" means that calls to a particular function in a formula are not interpreted as normal Julia code, but rather as a particular (possibly special) kind of term.","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"Custom syntax is a combination of syntax (Julia function) and term (subtype of AbstractTerm).  This syntax applies in a particular context (schema plus model type, designated via a method of apply_schema), transforming a FunctionTerm{syntax} into another (often custom) term type. This custom term type then specifies special behavior at data time (via a method for modelcols).","category":"page"},{"location":"internals/","page":"Internals and extending the @formula","title":"Internals and extending the @formula","text":"Finally, note that it's easy for a package to intercept the formula terms and manipulate them directly as well, before calling apply_schema or modelcols.  This gives packages great flexibility in how they interpret formula terms.","category":"page"}]
}
