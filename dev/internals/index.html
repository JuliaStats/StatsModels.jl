<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Internals and extending the @formula · StatsModels.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>StatsModels.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../formula/">Modeling tabular data</a></li><li class="current"><a class="toctext" href>Internals and extending the <code>@formula</code></a><ul class="internal"><li><a class="toctext" href="#The-lifecycle-of-a-@formula-1">The lifecycle of a <code>@formula</code></a></li><li><a class="toctext" href="#Extending-@formula-syntax-1">Extending <code>@formula</code> syntax</a></li></ul></li><li><a class="toctext" href="../contrasts/">Contrast coding categorical variables</a></li><li><a class="toctext" href="../api/">API documentation</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Internals and extending the <code>@formula</code></a></li></ul><a class="edit-page" href="https://github.com/JuliaStats/StatsModels.jl/blob/master/docs/src/internals.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Internals and extending the @formula</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Internals-and-extending-the-formula-DSL-1" href="#Internals-and-extending-the-formula-DSL-1">Internals and extending the formula DSL</a></h1><p>This section is intended to help <strong>package developers</strong> understand the internals of how a <code>@formula</code> becomes a numerical matrix, in order to use, manipulate, and even extend the DSL.  The Julia <code>@formula</code> is designed to be as extensible as possible through the normal Julian mechanisms of multiple dispatch.</p><h2><a class="nav-anchor" id="The-lifecycle-of-a-@formula-1" href="#The-lifecycle-of-a-@formula-1">The lifecycle of a <code>@formula</code></a></h2><p>A formula goes through a number of stages, starting as an expression that&#39;s passed to the <code>@formula</code> macro and ending up generating a numeric matrix when ultimately combined with a tabular data source:</p><ol><li>&quot;Syntax time&quot; when only the surface syntax is available</li><li>&quot;Schema time&quot; incorporates information about <strong>data invariants</strong> (types of each variable, levels of categorical variables, summary statistics for continuous variables) and the <strong>model type</strong>.</li><li>&quot;Data time&quot; when the actual data values themselves are available.</li></ol><p>For in-memory (columnar) tables, there is not much difference between &quot;data time&quot; and &quot;schema time&quot; in practice, but in principle it&#39;s important to distinguish between these when dealing with truly streaming data, or large data stores where calculating invariants of the data may be expensive.</p><h3><a class="nav-anchor" id="Syntax-time-1" href="#Syntax-time-1">Syntax time</a></h3><p>The <code>@formula</code> macro does syntactic transformations of the formula expression. At this point, <em>only</em> the expression itself is available, and there&#39;s no way to know whether a term corresponds to a continuous or categorical variable.</p><p>For standard formulae, this amounts to applying the syntactic rules for the DSL operators (expanding <code>*</code> and applying the distributive and associative rules), and wrapping each symbol in a <code>Term</code> constructor:</p><pre><code class="language-julia-repl">julia&gt; @macroexpand @formula(y ~ 1 + a*b)
:(Term(:y) ~ ConstantTerm(1) + Term(:a) + Term(:b) + Term(:a) &amp; Term(:b))</code></pre><p>Note that much of the action happens <em>outside</em> the <code>@formula</code> macro, when the expression returned by the <code>@formula</code> macro is evaluated.  At this point, the <code>Term</code>s are combined to create higher-order terms via overloaded methods for <code>~</code>, <code>+</code>, and <code>&amp;</code>:</p><pre><code class="language-julia-repl">julia&gt; using StatsModels;

julia&gt; dump(Term(:a) &amp; Term(:b))
InteractionTerm{Tuple{Term,Term}}
  terms: Tuple{Term,Term}
    1: Term
      sym: Symbol a
    2: Term
      sym: Symbol b

julia&gt; dump(Term(:a) + Term(:b))
Tuple{Term,Term}
  1: Term
    sym: Symbol a
  2: Term
    sym: Symbol b

julia&gt; dump(Term(:y) ~ Term(:a))
FormulaTerm{Term,Term}
  lhs: Term
    sym: Symbol y
  rhs: Term
    sym: Symbol a</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>As always, you can introspect which method is called with</p><pre><code class="language-julia">julia&gt; @which Term(:a) &amp; Term(:b)
&amp;(terms::AbstractTerm...) in StatsModels at /home/dave/.julia/dev/StatsModels/src/terms.jl:399</code></pre></div></div><p>The reason that the actual construction of higher-order terms is done after the macro is expanded is that it makes it much easier to create a formula programatically:</p><pre><code class="language-julia-repl">julia&gt; f = Term(:y) ~ sum(term.([1, :a, :b, :c]))
FormulaTerm
Response:
  y(unknown)
Predictors:
  1
  a(unknown)
  b(unknown)
  c(unknown)

julia&gt; f == @formula(y ~ 1 + a + b + c)
true</code></pre><p>The major exception to this is that non-DSL calls <strong>must</strong> be specified using the <code>@formula</code> macro.  The reason for this is that non-DSL calls are &quot;captured&quot; and turned into anonymous functions that can be evaluated elementwise, which has to happen at compile time.  For instance, the call to <code>log</code> in <code>@formula(y ~ log(a+b))</code> is converted into the anonymous function <code>(a,b) -&gt; log(a+b)</code>.</p><h3><a class="nav-anchor" id="Schema-time-1" href="#Schema-time-1">Schema time</a></h3><p>The next phase of life for a formula begins when a <em>schema</em> for the data becomes available.  A schema is a mapping from data columns to a concrete term type–-either a <code>ContinuousTerm</code> or a <code>CategoricalTerm</code>–-which represents all the summary information about a data column necessary to create a model matrix from that column.</p><p>A schema is computed with the <code>schema</code> function.  By default, it will create a schema for every column in the data:</p><pre><code class="language-julia-repl">julia&gt; using DataFrames    # for pretty printing---any Table will do

julia&gt; df = DataFrame(y = rand(9), a = 1:9, b = rand(9), c = repeat([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], 3))
9×4 DataFrame
│ Row │ y          │ a     │ b         │ c      │
│     │ Float64    │ Int64 │ Float64   │ String │
├─────┼────────────┼───────┼───────────┼────────┤
│ 1   │ 0.236033   │ 1     │ 0.986666  │ a      │
│ 2   │ 0.346517   │ 2     │ 0.555751  │ b      │
│ 3   │ 0.312707   │ 3     │ 0.437108  │ c      │
│ 4   │ 0.00790928 │ 4     │ 0.424718  │ a      │
│ 5   │ 0.488613   │ 5     │ 0.773223  │ b      │
│ 6   │ 0.210968   │ 6     │ 0.28119   │ c      │
│ 7   │ 0.951916   │ 7     │ 0.209472  │ a      │
│ 8   │ 0.999905   │ 8     │ 0.251379  │ b      │
│ 9   │ 0.251662   │ 9     │ 0.0203749 │ c      │

julia&gt; schema(df)
Dict{Any,Any} with 4 entries:
  y =&gt; y
  a =&gt; a
  b =&gt; b
  c =&gt; c</code></pre><p>However, if a term (including a <code>FormulaTerm</code>) is provided, the schema will be computed based only on the necessary variables:</p><pre><code class="language-julia-repl">julia&gt; schema(@formula(y ~ 1 + a), df)
Dict{Any,Any} with 2 entries:
  y =&gt; y
  a =&gt; a

julia&gt; schema(Term(:a) + Term(:b), df)
Dict{Any,Any} with 2 entries:
  a =&gt; a
  b =&gt; b</code></pre><p>Once a schema is computed, it&#39;s <em>applied</em> to the formula with <a href="../api/#StatsModels.apply_schema"><code>apply_schema</code></a>.  Among other things, this <em>instantiates</em> placeholder terms:</p><ul><li><code>Term</code>s become <code>ContinuousTerm</code>s or <code>CategoricalTerm</code>s</li><li><code>ConstantTerm</code>s become <code>InterceptTerm</code>s</li><li>Tuples of terms become <a href="../api/#StatsModels.MatrixTerm"><code>MatrixTerm</code></a>s where appropriate to explicitly indicate they should be concatenated into a single model matrix</li></ul><pre><code class="language-julia-repl">julia&gt; f = @formula(y ~ 1 + a + b * c)
FormulaTerm
Response:
  y(unknown)
Predictors:
  1
  a(unknown)
  b(unknown)
  c(unknown)
  b(unknown) &amp; c(unknown)

julia&gt; typeof(f)
FormulaTerm{Term,Tuple{ConstantTerm{Int64},Term,Term,Term,InteractionTerm{Tuple{Term,Term}}}}

julia&gt; f = apply_schema(f, schema(f, df))
FormulaTerm
Response:
  y(continuous)
Predictors:
  1
  a(continuous)
  b(continuous)
  c(DummyCoding:3→2)
  b(continuous) &amp; c(DummyCoding:3→2)

julia&gt; typeof(f)
FormulaTerm{ContinuousTerm{Float64},MatrixTerm{Tuple{InterceptTerm{true},ContinuousTerm{Float64},ContinuousTerm{Float64},CategoricalTerm{DummyCoding,String,2},InteractionTerm{Tuple{ContinuousTerm{Float64},CategoricalTerm{DummyCoding,String,2}}}}}}</code></pre><p>This transformation is done by calling <code>apply_schema(term, schema, modeltype)</code> recursively on each term (the <code>modeltype</code> defaults to <code>StatisticalModel</code> when fitting a statistical model, and <code>Nothing</code> if <code>apply_schema</code> is called with only two arguments).  Because <code>apply_schema</code> dispatches on the term, schema, and model type, this stage allows generic context-aware transformations, based on <em>both</em> the source (schema) <em>and</em> the destination (model type).  This is the primary mechanisms by which the formula DSL can be extended (<a href="#Extending-@formula-syntax-1">see below</a> for more details)</p><h3><a class="nav-anchor" id="Data-time-1" href="#Data-time-1">Data time</a></h3><p>At the end of &quot;schema time&quot;, a formula encapsulates all the information needed to convert a table into a numeric model matrix.  That is, it is ready for &quot;data time&quot;.  The main API method is <a href="../api/#StatsModels.modelcols"><code>modelcols</code></a>, which when applied to a <code>FormulaTerm</code> returns a tuple of the numeric forms for the left- (response) and right-hand (predictor) sides.</p><pre><code class="language-julia-repl">julia&gt; resp, pred = modelcols(f, df);

julia&gt; resp
9-element Array{Float64,1}:
 0.23603334566204692
 0.34651701419196046
 0.3127069683360675
 0.00790928339056074
 0.4886128300795012
 0.21096820215853596
 0.951916339835734
 0.9999046588986136
 0.25166218303197185

julia&gt; pred
9×7 Array{Float64,2}:
 1.0  1.0  0.986666   0.0  0.0  0.0       0.0
 1.0  2.0  0.555751   1.0  0.0  0.555751  0.0
 1.0  3.0  0.437108   0.0  1.0  0.0       0.437108
 1.0  4.0  0.424718   0.0  0.0  0.0       0.0
 1.0  5.0  0.773223   1.0  0.0  0.773223  0.0
 1.0  6.0  0.28119    0.0  1.0  0.0       0.28119
 1.0  7.0  0.209472   0.0  0.0  0.0       0.0
 1.0  8.0  0.251379   1.0  0.0  0.251379  0.0
 1.0  9.0  0.0203749  0.0  1.0  0.0       0.0203749
</code></pre><p><code>modelcols</code> can also take a single row from a table, as a <code>NamedTuple</code>:</p><pre><code class="language-julia-repl">julia&gt; using Tables

julia&gt; modelcols(f, first(Tables.rowtable(df)))
(0.23603334566204692, [1.0, 1.0, 0.986666, 0.0, 0.0, 0.0, 0.0])
</code></pre><p>Any <code>AbstractTerm</code> can be passed to <code>modelcols</code> with a table, which returns one or more numeric arrays:</p><pre><code class="language-julia-repl">julia&gt; t = f.rhs.terms[end]
b(continuous) &amp; c(DummyCoding:3→2)

julia&gt; modelcols(t, df)
9×2 Array{Float64,2}:
 0.0       0.0
 0.555751  0.0
 0.0       0.437108
 0.0       0.0
 0.773223  0.0
 0.0       0.28119
 0.0       0.0
 0.251379  0.0
 0.0       0.0203749
</code></pre><h2><a class="nav-anchor" id="Extending-@formula-syntax-1" href="#Extending-@formula-syntax-1">Extending <code>@formula</code> syntax</a></h2><p>Package authors may want to create additional syntax to the <code>@formula</code> DSL so their users can conveniently specify particular kinds of models.  StatsModels.jl provides mechanisms for such extensions that do <em>not</em> rely on compile time &quot;macro magic&quot;, but on standard julian mechanisms of multiple dispatch.</p><p>Extensions have three components:</p><ol><li><strong>Syntax</strong>: the Julia function which is given special meaning inside a formula.</li><li><strong>Context</strong>: the model type(s) where this extension applies</li><li><strong>Behavior</strong>: how tabular data is transformed under this extension</li></ol><p>These correspond to the stages summarized above (syntax time, schema time, and data time)</p><p>As an example, we&#39;ll add syntax for specifying a <a href="https://en.wikipedia.org/wiki/Polynomial_regression">polynomial regression</a> model, which fits a regression using polynomial basis functions of a continuous predictor.</p><p>The first step is to specify the <strong>syntax</strong> we&#39;re going to use.  While it&#39;s possible to use an existing function, the best practice is to define a new function to make dispatch less ambiguous.</p><pre><code class="language-julia">using StatsBase
# syntax: best practice to define a _new_ function
poly(x, n) = x^n

# type of model where syntax applies: here this applies to any model type
const POLY_CONTEXT = Any

# struct for behavior
struct PolyTerm &lt;: AbstractTerm
    term::ContinuousTerm
    deg::Int
end

Base.show(io::IO, p::PolyTerm) = print(io, &quot;poly($(p.term), $(p.deg))&quot;)

function StatsModels.apply_schema(t::FunctionTerm{typeof(poly)}, sch, Mod::Type{&lt;:POLY_CONTEXT})
    term = apply_schema(t.args_parsed[1], sch, Mod)
    isa(term, ContinuousTerm) ||
        throw(ArgumentError(&quot;PolyTerm only works with continuous terms (got $term)&quot;))
    deg = t.args_parsed[2]
    isa(deg, ConstantTerm) ||
        throw(ArgumentError(&quot;PolyTerm degree must be a number (got $deg)&quot;))
    PolyTerm(term, deg.n)
end

function StatsModels.modelcols(p::PolyTerm, d::NamedTuple)
    col = modelcols(p.term, d)
    reduce(hcat, [col.^n for n in 1:p.deg])
end

StatsModels.width(p::PolyTerm) = p.deg

StatsBase.coefnames(p::PolyTerm) = coefnames(p.term) .* &quot;^&quot; .* string.(1:p.deg)

# output

</code></pre><p>Now, we can use <code>poly</code> in a formula:</p><pre><code class="language-julia-repl">julia&gt; data = DataFrame(y = rand(4), a = rand(4), b = [1:4;])
4×3 DataFrame
│ Row │ y          │ a        │ b     │
│     │ Float64    │ Float64  │ Int64 │
├─────┼────────────┼──────────┼───────┤
│ 1   │ 0.236033   │ 0.488613 │ 1     │
│ 2   │ 0.346517   │ 0.210968 │ 2     │
│ 3   │ 0.312707   │ 0.951916 │ 3     │
│ 4   │ 0.00790928 │ 0.999905 │ 4     │

julia&gt; f = @formula(y ~ 1 + poly(b, 2) * a)
FormulaTerm
Response:
  y(unknown)
Predictors:
  1
  (b)-&gt;poly(b, 2)
  a(unknown)
  (b)-&gt;poly(b, 2) &amp; a(unknown)

julia&gt; f = apply_schema(f, schema(data))
FormulaTerm
Response:
  y(continuous)
Predictors:
  1
  poly(b, 2)
  a(continuous)
  poly(b, 2) &amp; a(continuous)

julia&gt; modelcols(f.rhs, data)
4×6 Array{Float64,2}:
 1.0  1.0   1.0  0.488613  0.488613   0.488613
 1.0  2.0   4.0  0.210968  0.421936   0.843873
 1.0  3.0   9.0  0.951916  2.85575    8.56725
 1.0  4.0  16.0  0.999905  3.99962   15.9985

julia&gt; coefnames(f.rhs)
6-element Array{String,1}:
 &quot;(Intercept)&quot;
 &quot;b^1&quot;
 &quot;b^2&quot;
 &quot;a&quot;
 &quot;b^1 &amp; a&quot;
 &quot;b^2 &amp; a&quot;
</code></pre><p>It&#39;s also possible to <em>block</em> interpretation of the <code>poly</code> syntax as special in certain contexts by adding additional (more specific) methods.  For instance, we could block <code>PolyTerm</code>s being generated for <code>GLM.LinearModel</code>:</p><pre><code class="language-julia-repl">julia&gt; using GLM

julia&gt; StatsModels.apply_schema(t::FunctionTerm{typeof(poly)},
                                sch,
                                Mod::Type{GLM.LinearModel}) = t</code></pre><p>Now the <code>poly</code> is interpreted by default as the &quot;vanilla&quot; function defined first, which just raises its first argument to the designated power:</p><pre><code class="language-julia-repl">julia&gt; f = apply_schema(@formula(y ~ 1 + poly(b,2) * a),
                        schema(data),
                        GLM.LinearModel)
FormulaTerm
Response:
  y(continuous)
Predictors:
  1
  (b)-&gt;poly(b, 2)
  a(continuous)
  (b)-&gt;poly(b, 2) &amp; a(continuous)

julia&gt; modelcols(f.rhs, data)
4×4 Array{Float64,2}:
 1.0   1.0  0.488613   0.488613
 1.0   4.0  0.210968   0.843873
 1.0   9.0  0.951916   8.56725
 1.0  16.0  0.999905  15.9985

julia&gt; coefnames(f.rhs)
4-element Array{String,1}:
 &quot;(Intercept)&quot;
 &quot;poly(b, 2)&quot;
 &quot;a&quot;
 &quot;poly(b, 2) &amp; a&quot;
</code></pre><p>But by using a different context (e.g., the related but more general <code>GLM.GeneralizedLinearModel</code>) we get the custom interpretation:</p><pre><code class="language-julia-repl">julia&gt; f2 = apply_schema(@formula(y ~ 1 + poly(b,2) * a),
                         schema(data),
                         GLM.GeneralizedLinearModel)
FormulaTerm
Response:
  y(continuous)
Predictors:
  1
  poly(b, 2)
  a(continuous)
  poly(b, 2) &amp; a(continuous)

julia&gt; modelcols(f2.rhs, data)
4×6 Array{Float64,2}:
 1.0  1.0   1.0  0.488613  0.488613   0.488613
 1.0  2.0   4.0  0.210968  0.421936   0.843873
 1.0  3.0   9.0  0.951916  2.85575    8.56725
 1.0  4.0  16.0  0.999905  3.99962   15.9985

julia&gt; coefnames(f2.rhs)
6-element Array{String,1}:
 &quot;(Intercept)&quot;
 &quot;b^1&quot;
 &quot;b^2&quot;
 &quot;a&quot;
 &quot;b^1 &amp; a&quot;
 &quot;b^2 &amp; a&quot;</code></pre><p>The definitions of these methods control how models of each type are <em>fit</em> from a formula with a call to <code>poly</code>:</p><pre><code class="language-julia-repl">julia&gt; sim_dat = DataFrame(b=randn(100));

julia&gt; sim_dat[:y] = randn(100) .+ 1 .+ 2*sim_dat[:b] .+ 3*sim_dat[:b].^2;

julia&gt; fit(LinearModel, @formula(y ~ 1 + poly(b,2)), sim_dat)
StatsModels.TableRegressionModel{LinearModel{LmResp{Array{Float64,1}},DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}

y ~ 1 + :(poly(b, 2))

Coefficients:
             Estimate Std.Error t value Pr(&gt;|t|)
(Intercept)  0.911363  0.310486 2.93528   0.0042
poly(b, 2)    2.94442  0.191024 15.4139   &lt;1e-27

julia&gt; fit(GeneralizedLinearModel, @formula(y ~ 1 + poly(b,2)), sim_dat, Normal())
StatsModels.TableRegressionModel{GeneralizedLinearModel{GlmResp{Array{Float64,1},Normal{Float64},IdentityLink},DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}

y ~ 1 + poly(b, 2)

Coefficients:
             Estimate Std.Error z value Pr(&gt;|z|)
(Intercept)  0.829374  0.131582  6.3031    &lt;1e-9
b^1           2.13096  0.100552 21.1926   &lt;1e-98
b^2            3.1132 0.0813107 38.2877   &lt;1e-99
</code></pre><p>(a <code>GeneralizeLinearModel</code> with a <code>Normal</code> distribution is equivalent to a <code>LinearModel</code>)</p><h3><a class="nav-anchor" id="Summary-1" href="#Summary-1">Summary</a></h3><p>&quot;Custom syntax&quot; means that calls to a particular function in a formula are not interpreted as normal Julia code, but rather as a particular (possibly special) kind of term.</p><p>Custom syntax is a combination of <strong>syntax</strong> (Julia function) and <strong>term</strong> (subtype of <code>AbstractTerm</code>).  This syntax applies in a particular <strong>context</strong> (schema plus model type, designated via a method of <a href="../api/#StatsModels.apply_schema"><code>apply_schema</code></a>), transforming a <code>FunctionTerm{syntax}</code> into another (often custom) term type. This custom term type then specifies special <strong>behavior</strong> at data time (via a method for <a href="../api/#StatsModels.modelcols"><code>modelcols</code></a>).</p><p>Finally, note that it&#39;s easy for a package to intercept the formula terms and manipulate them directly as well, before calling <code>apply_schema</code> or <code>modelcols</code>.  This gives packages great flexibility in how they interpret formula terms.</p><footer><hr/><a class="previous" href="../formula/"><span class="direction">Previous</span><span class="title">Modeling tabular data</span></a><a class="next" href="../contrasts/"><span class="direction">Next</span><span class="title">Contrast coding categorical variables</span></a></footer></article></body></html>
