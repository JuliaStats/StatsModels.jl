<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Contrast coding categorical variables · StatsModels.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>StatsModels.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../formula/">Modeling tabular data</a></li><li><a class="toctext" href="../internals/">Internals and extending the <code>@formula</code></a></li><li class="current"><a class="toctext" href>Contrast coding categorical variables</a><ul class="internal"><li><a class="toctext" href="#How-to-specify-contrast-coding-1">How to specify contrast coding</a></li><li><a class="toctext" href="#Interface-1">Interface</a></li><li><a class="toctext" href="#Contrast-coding-systems-1">Contrast coding systems</a></li><li><a class="toctext" href="#Further-details-1">Further details</a></li></ul></li><li><a class="toctext" href="../temporal_terms/">Temporal variables and Time Series Terms</a></li><li><a class="toctext" href="../api/">API documentation</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Contrast coding categorical variables</a></li></ul><a class="edit-page" href="https://github.com/JuliaStats/StatsModels.jl/blob/master/docs/src/contrasts.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Contrast coding categorical variables</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Modeling-categorical-data-1" href="#Modeling-categorical-data-1">Modeling categorical data</a></h1><p>To convert categorical data into a numerical representation suitable for modeling, <code>StatsModels</code> implements a variety of <strong>contrast coding systems</strong>. Each contrast coding system maps a categorical vector with <span>$k$</span> levels onto <span>$k-1$</span> linearly independent model matrix columns.</p><p>The following contrast coding systems are implemented:</p><ul><li><a href="#StatsModels.DummyCoding"><code>DummyCoding</code></a></li><li><a href="#StatsModels.EffectsCoding"><code>EffectsCoding</code></a></li><li><a href="#StatsModels.HelmertCoding"><code>HelmertCoding</code></a></li><li><a href="#StatsModels.ContrastsCoding"><code>ContrastsCoding</code></a></li></ul><h2><a class="nav-anchor" id="How-to-specify-contrast-coding-1" href="#How-to-specify-contrast-coding-1">How to specify contrast coding</a></h2><p>The default contrast coding system is <code>DummyCoding</code>.  To override this, use the <code>contrasts</code> argument when constructing a <code>ModelFrame</code>:</p><pre><code class="language-julia">mf = ModelFrame(@formula(y ~ 1 + x), df, contrasts = Dict(:x =&gt; EffectsCoding()))</code></pre><p>To change the contrast coding for one or more variables in place, use</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.setcontrasts!" href="#StatsModels.setcontrasts!"><code>StatsModels.setcontrasts!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">setcontrasts!(mf::ModelFrame; kwargs...)
setcontrasts!(mf::ModelFrame, contrasts::Dict{Symbol})</code></pre><p>Update the contrasts used for coding categorical variables in <a href="../api/#StatsModels.ModelFrame"><code>ModelFrame</code></a> in place.  This is accomplished by computing a new schema based on the provided contrasts and the <code>ModelFrame</code>&#39;s data, and applying it to the <code>ModelFrame</code>&#39;s <code>FormulaTerm</code>.</p><p>Note that only the <code>ModelFrame</code> itself is mutated: because <code>AbstractTerm</code>s are immutable, any changes will produce a copy.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/47b351dccb246bbc303c00bf075e98f6ecb205e6/src/modelframe.jl#L117-L129">source</a></section><h2><a class="nav-anchor" id="Interface-1" href="#Interface-1">Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.AbstractContrasts" href="#StatsModels.AbstractContrasts"><code>StatsModels.AbstractContrasts</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Interface to describe contrast coding systems for categorical variables.</p><p>Concrete subtypes of <code>AbstractContrasts</code> describe a particular way of converting a categorical data vector into numeric columns in a <code>ModelMatrix</code>. Each instantiation optionally includes the levels to generate columns for and the base level. If not specified these will be taken from the data when a <code>ContrastsMatrix</code> is generated (during <code>ModelFrame</code> construction).</p><p><strong>Constructors</strong></p><p>For <code>C &lt;: AbstractContrast</code>:</p><pre><code class="language-julia">C()                                     # levels are inferred later
C(levels = ::Vector{Any})               # levels checked against data later
C(base = ::Any)                         # specify base level
C(levels = ::Vector{Any}, base = ::Any) # specify levels and base</code></pre><p><strong>Arguments</strong></p><ul><li><code>levels</code>: Optionally, the data levels can be specified here.  This allows you to specify the order of the levels.  If specified, the levels will be checked against the levels actually present in the data when the <code>ContrastsMatrix</code> is constructed. Any mismatch will result in an error, because levels missing in the data would lead to empty columns in the model matrix, and levels missing from the contrasts would lead to empty or undefined rows.</li><li><code>base</code>: The base level may also be specified.  The actual interpretation of this depends on the particular contrast type, but in general it can be thought of as a &quot;reference&quot; level.  It defaults to the first level.</li></ul><p><strong>Contrast coding systems</strong></p><ul><li><a href="#StatsModels.DummyCoding"><code>DummyCoding</code></a> - Code each non-base level as a 0-1 indicator column.</li><li><a href="#StatsModels.EffectsCoding"><code>EffectsCoding</code></a> - Code each non-base level as 1, and base as -1.</li><li><a href="#StatsModels.HelmertCoding"><code>HelmertCoding</code></a> - Code each non-base level as the difference from the mean of the lower levels</li><li><a href="#StatsModels.ContrastsCoding"><code>ContrastsCoding</code></a> - Manually specify contrasts matrix</li></ul><p>The last coding type, <code>ContrastsCoding</code>, provides a way to manually specify a contrasts matrix. For a variable <code>x</code> with <code>k</code> levels, a contrasts matrix <code>M</code> is a <code>k×k-1</code> matrix, that maps the <code>k</code> levels onto <code>k-1</code> model matrix columns. Specifically, let <code>X</code> be the full-rank indicator matrix for <code>x</code>, where <code>X[i,j] = 1</code> if <code>x[i] == levels(x)[j]</code>, and 0 otherwise. Then the model matrix columns generated by the contrasts matrix <code>M</code> are <code>Y = X * M</code>.</p><p><strong>Extending</strong></p><p>The easiest way to specify custom contrasts is with <code>ContrastsCoding</code>.  But if you want to actually implement a custom contrast coding system, you can subtype <code>AbstractContrasts</code>.  This requires a constructor, a <code>contrasts_matrix</code> method for constructing the actual contrasts matrix that maps from levels to <code>ModelMatrix</code> column values, and (optionally) a <code>termnames</code> method:</p><pre><code class="language-julia">mutable struct MyCoding &lt;: AbstractContrasts
    ...
end

contrasts_matrix(C::MyCoding, baseind, n) = ...
termnames(C::MyCoding, levels, baseind) = ...</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/47b351dccb246bbc303c00bf075e98f6ecb205e6/src/contrasts.jl#L16-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.ContrastsMatrix" href="#StatsModels.ContrastsMatrix"><code>StatsModels.ContrastsMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>An instantiation of a contrast coding system for particular levels</p><p>This type is used internally for generating model matrices based on categorical data, and <strong>most users will not need to deal with it directly</strong>.  Conceptually, a <code>ContrastsMatrix</code> object stands for an instantiation of a contrast coding <em>system</em> for a particular set of categorical <em>data levels</em>.</p><p>If levels are specified in the <code>AbstractContrasts</code>, those will be used, and likewise for the base level (which defaults to the first level).</p><p><strong>Constructors</strong></p><pre><code class="language-julia">ContrastsMatrix(contrasts::AbstractContrasts, levels::AbstractVector)
ContrastsMatrix(contrasts_matrix::ContrastsMatrix, levels::AbstractVector)</code></pre><p><strong>Arguments</strong></p><ul><li><code>contrasts::AbstractContrasts</code>: The contrast coding system to use.</li><li><code>levels::AbstractVector</code>: The levels to generate contrasts for.</li><li><code>contrasts_matrix::ContrastsMatrix</code>: Constructing a <code>ContrastsMatrix</code> from another will check that the levels match.  This is used, for example, in constructing a model matrix from a <code>ModelFrame</code> using different data.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/47b351dccb246bbc303c00bf075e98f6ecb205e6/src/contrasts.jl#L111-L137">source</a></section><h2><a class="nav-anchor" id="Contrast-coding-systems-1" href="#Contrast-coding-systems-1">Contrast coding systems</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.DummyCoding" href="#StatsModels.DummyCoding"><code>StatsModels.DummyCoding</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DummyCoding([base[, levels]])</code></pre><p>Dummy coding generates one indicator column (1 or 0) for each non-base level.</p><p>Columns have non-zero mean and are collinear with an intercept column (and lower-order columns for interactions) but are orthogonal to each other. In a regression model, dummy coding leads to an intercept that is the mean of the dependent variable for base level.</p><p>Also known as &quot;treatment coding&quot; or &quot;one-hot encoding&quot;.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; StatsModels.ContrastsMatrix(DummyCoding(), [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]).matrix
4×3 Array{Float64,2}:
 0.0  0.0  0.0
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/47b351dccb246bbc303c00bf075e98f6ecb205e6/src/contrasts.jl#L263-L285">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.EffectsCoding" href="#StatsModels.EffectsCoding"><code>StatsModels.EffectsCoding</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">EffectsCoding([base[, levels]])</code></pre><p>Effects coding generates columns that code each non-base level as the deviation from the base level.  For each non-base level <code>x</code> of <code>variable</code>, a column is generated with 1 where <code>variable .== x</code> and -1 where <code>variable .== base</code>.</p><p><code>EffectsCoding</code> is like <code>DummyCoding</code>, but using -1 for the base level instead of 0.</p><p>When all levels are equally frequent, effects coding generates model matrix columns that are mean centered (have mean 0).  For more than two levels the generated columns are not orthogonal.  In a regression model with an effects-coded variable, the intercept corresponds to the grand mean.</p><p>Also known as &quot;sum coding&quot; or &quot;simple coding&quot;. Note though that the default in R and SPSS is to use the <em>last</em> level as the base. Here we use the <em>first</em> level as the base, for consistency with other coding systems.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; StatsModels.ContrastsMatrix(EffectsCoding(), [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]).matrix
4×3 Array{Float64,2}:
 -1.0  -1.0  -1.0
  1.0   0.0   0.0
  0.0   1.0   0.0
  0.0   0.0   1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/47b351dccb246bbc303c00bf075e98f6ecb205e6/src/contrasts.jl#L292-L323">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.HelmertCoding" href="#StatsModels.HelmertCoding"><code>StatsModels.HelmertCoding</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">HelmertCoding([base[, levels]])</code></pre><p>Helmert coding codes each level as the difference from the average of the lower levels.</p><p>For each non-base level, Helmert coding generates a columns with -1 for each of n levels below, n for that level, and 0 above.</p><p>When all levels are equally frequent, Helmert coding generates columns that are mean-centered (mean 0) and orthogonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; StatsModels.ContrastsMatrix(HelmertCoding(), [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]).matrix
4×3 Array{Float64,2}:
 -1.0  -1.0  -1.0
  1.0  -1.0  -1.0
  0.0   2.0  -1.0
  0.0   0.0   3.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/47b351dccb246bbc303c00bf075e98f6ecb205e6/src/contrasts.jl#L333-L355">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.ContrastsCoding" href="#StatsModels.ContrastsCoding"><code>StatsModels.ContrastsCoding</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ContrastsCoding(mat::Matrix[, base[, levels]])</code></pre><p>Coding by manual specification of contrasts matrix. For k levels, the contrasts must be a k by k-1 Matrix.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/47b351dccb246bbc303c00bf075e98f6ecb205e6/src/contrasts.jl#L370-L375">source</a></section><h3><a class="nav-anchor" id="Special-internal-contrasts-1" href="#Special-internal-contrasts-1">Special internal contrasts</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.FullDummyCoding" href="#StatsModels.FullDummyCoding"><code>StatsModels.FullDummyCoding</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FullDummyCoding()</code></pre><p>Full-rank dummy coding generates one indicator (1 or 0) column for each level, <strong>including</strong> the base level. This is sometimes known as  <a href="https://en.wikipedia.org/wiki/One-hot">one-hot encoding</a>.</p><p>Not exported but included here for the sake of completeness. Needed internally for some situations where a categorical variable with <span>$k$</span> levels needs to be converted into <span>$k$</span> model matrix columns instead of the standard <span>$k-1$</span>.  This occurs when there are missing lower-order terms, as in discussed below in <a href="#Categorical-variables-in-Formulas-1">Categorical variables in Formulas</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; StatsModels.ContrastsMatrix(StatsModels.FullDummyCoding(), [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]).matrix
4×4 Array{Float64,2}:
 1.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0
 0.0  0.0  1.0  0.0
 0.0  0.0  0.0  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/47b351dccb246bbc303c00bf075e98f6ecb205e6/src/contrasts.jl#L227-L250">source</a></section><h2><a class="nav-anchor" id="Further-details-1" href="#Further-details-1">Further details</a></h2><h3><a class="nav-anchor" id="Categorical-variables-in-Formulas-1" href="#Categorical-variables-in-Formulas-1">Categorical variables in <code>Formula</code>s</a></h3><p>Generating model matrices from multiple variables, some of which are categorical, requires special care.  The reason for this is that rank-<span>$k-1$</span> contrasts are appropriate for a categorical variable with <span>$k$</span> levels when it <em>aliases</em> other terms, making it <em>partially redundant</em>.  Using rank-<span>$k$</span> for such a redundant variable will generally result in a rank-deficient model matrix and a model that can&#39;t be identified.</p><p>A categorical variable in a term <em>aliases</em> the term that remains when that variable is dropped.  For example, with categorical <code>a</code>:</p><ul><li>In <code>a</code>, the sole variable <code>a</code> aliases the intercept term <code>1</code>.</li><li>In <code>a&amp;b</code>, the variable <code>a</code> aliases the main effect term <code>b</code>, and vice versa.</li><li>In <code>a&amp;b&amp;c</code>, the variable <code>a</code> alises the interaction term <code>b&amp;c</code> (regardless of whether <code>b</code> and <code>c</code> are categorical).</li></ul><p>If a categorical variable aliases another term that is present elsewhere in the formula, we call that variable <em>redundant</em>.  A variable is <em>non-redundant</em> when the term that it alises is <em>not</em> present elsewhere in the formula.  For categorical <code>a</code>, <code>b</code>, and <code>c</code>:</p><ul><li>In <code>y ~ 1 + a</code>, the <code>a</code> in the main effect of <code>a</code> aliases the intercept <code>1</code>.</li><li>In <code>y ~ 0 + a</code>, <code>a</code> does not alias any other terms and is <em>non-redundant</em>.</li><li>In <code>y ~ 1 + a + a&amp;b</code>:<ul><li>The <code>b</code> in <code>a&amp;b</code> is redundant because it aliases the main effect <code>a</code>: dropping <code>b</code> from <code>a&amp;b</code> leaves <code>a</code>.</li><li>The <code>a</code> in <code>a&amp;b</code> is <em>non-redundant</em> because it aliases <code>b</code>, which is not present anywhere else in the formula.</li></ul></li></ul><p>When constructing a <code>ModelFrame</code> from a <code>Formula</code>, each term is checked for non-redundant categorical variables.  Any such non-redundant variables are &quot;promoted&quot; to full rank in that term by using <a href="#StatsModels.FullDummyCoding"><code>FullDummyCoding</code></a> instead of the contrasts used elsewhere for that variable.</p><p>One additional complexity is introduced by promoting non-redundant variables to full rank.  For the purpose of determining redundancy, a full-rank dummy coded categorical variable <em>implicitly</em> introduces the term that it aliases into the formula.  Thus, in <code>y ~ 1 + a + a&amp;b + b&amp;c</code>:</p><ul><li>In <code>a&amp;b</code>, <code>a</code> aliases the main effect <code>b</code>, which is not explicitly present in the formula.  This makes it non-redundant and so its contrast coding is promoted to <code>FullDummyCoding</code>, which <em>implicitly</em> introduces the main effect of <code>b</code>.</li><li>Then, in <code>b&amp;c</code>, the variable <code>c</code> is now <em>redundant</em> because it aliases the main effect of <code>b</code>, and so it keeps its original contrast coding system.</li></ul><footer><hr/><a class="previous" href="../internals/"><span class="direction">Previous</span><span class="title">Internals and extending the <code>@formula</code></span></a><a class="next" href="../temporal_terms/"><span class="direction">Next</span><span class="title">Temporal variables and Time Series Terms</span></a></footer></article></body></html>
