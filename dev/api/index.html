<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API documentation · StatsModels.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">StatsModels.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../formula/">Modeling tabular data</a></li><li><a class="tocitem" href="../internals/">Internals and extending the <code>@formula</code></a></li><li><a class="tocitem" href="../contrasts/">Contrast coding categorical variables</a></li><li><a class="tocitem" href="../temporal_terms/">Temporal variables and Time Series Terms</a></li><li class="is-active"><a class="tocitem" href>API documentation</a><ul class="internal"><li><a class="tocitem" href="#Formulae-and-terms"><span>Formulae and terms</span></a></li><li><a class="tocitem" href="#Schema"><span>Schema</span></a></li><li><a class="tocitem" href="#Modeling"><span>Modeling</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API documentation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API documentation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaStats/StatsModels.jl/blob/master/docs/src/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="StatsModels.jl-API"><a class="docs-heading-anchor" href="#StatsModels.jl-API">StatsModels.jl API</a><a id="StatsModels.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#StatsModels.jl-API" title="Permalink"></a></h1><h2 id="Formulae-and-terms"><a class="docs-heading-anchor" href="#Formulae-and-terms">Formulae and terms</a><a id="Formulae-and-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Formulae-and-terms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StatsModels.@formula" href="#StatsModels.@formula"><code>StatsModels.@formula</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@formula(ex)</code></pre><p>Capture and parse a formula expression as a <code>Formula</code> struct.</p><p>A formula is an abstract specification of a dependence between <em>left-hand</em> and <em>right-hand</em> side variables as in, e.g., a regression model.  Each side specifies at a high level how tabular data is to be converted to a numerical matrix suitable for modeling.  This specification looks something like Julia code, is represented as a Julia <code>Expr</code>, but uses special syntax.  The <code>@formula</code> macro takes an expression like <code>y ~ 1 + a*b</code>, transforms it according to the formula syntax rules into a lowered form (like <code>y ~ 1 + a + b + a&amp;b</code>), and constructs a <code>Formula</code> struct which captures the original expression, the lowered expression, and the left- and right-hand-side.</p><p>Operators that have special interpretations in this syntax are</p><ul><li><code>~</code> is the formula separator, where it is a binary operator (the first argument is the left-hand side, and the second is the right-hand side.</li><li><code>+</code> concatenates variables as columns when generating a model matrix.</li><li><code>&amp;</code> represents an <em>interaction</em> between two or more variables, which corresponds to a row-wise kronecker product of the individual terms (or element-wise product if all terms involved are continuous/scalar).</li><li><code>*</code> expands to all main effects and interactions: <code>a*b</code> is equivalent to <code>a+b+a&amp;b</code>, <code>a*b*c</code> to <code>a+b+c+a&amp;b+a&amp;c+b&amp;c+a&amp;b&amp;c</code>, etc.</li><li><code>1</code>, <code>0</code>, and <code>-1</code> indicate the presence (for <code>1</code>) or absence (for <code>0</code> and <code>-1</code>) of an intercept column.</li></ul><p>The rules that are applied are</p><ul><li>The associative rule (un-nests nested calls to <code>+</code>, <code>&amp;</code>, and <code>*</code>).</li><li>The distributive rule (interactions <code>&amp;</code> distribute over concatenation <code>+</code>).</li><li>The <code>*</code> rule expands <code>a*b</code> to <code>a+b+a&amp;b</code> (recursively).</li><li>Subtraction is converted to addition and negation, so <code>x-1</code> becomes <code>x + -1</code> (applies only to subtraction of literal 1).</li><li>Single-argument <code>&amp;</code> calls are stripped, so <code>&amp;(x)</code> becomes the main effect <code>x</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/formula.jl#L23-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.term" href="#StatsModels.term"><code>StatsModels.term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">term(x)</code></pre><p>Wrap argument in an appropriate <code>AbstractTerm</code> type: <code>Symbol</code>s and <code>AbstractString</code>s become <code>Term</code>s, and <code>Number</code>s become <code>ConstantTerm</code>s.  Any <code>AbstractTerm</code>s are unchanged. <code>AbstractString</code>s are converted to symbols before wrapping.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ts = term.((1, :a, &quot;b&quot;))
1
a(unknown)
b(unknown)

julia&gt; typeof(ts)
Tuple{ConstantTerm{Int64}, Term, Term}</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/terms.jl#L678-L696">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.coefnames" href="#StatsAPI.coefnames"><code>StatsAPI.coefnames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">coefnames(model::StatisticalModel)</code></pre><p>Return the names of the coefficients.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.modelcols" href="#StatsModels.modelcols"><code>StatsModels.modelcols</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modelcols(t::AbstractTerm, data)</code></pre><p>Create a numerical &quot;model columns&quot; representation of data based on an <code>AbstractTerm</code>.  <code>data</code> can either be a whole table (a property-accessible collection of iterable columns or iterable collection of property-accessible rows, as defined by <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> or a single row (in the form of a <code>NamedTuple</code> of scalar values).  Tables will be converted to a <code>NamedTuple</code> of <code>Vectors</code> (e.g., a <code>Tables.ColumnTable</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/terms.jl#L427-L436">source</a></section><section><div><pre><code class="nohighlight hljs">modelcols(ts::NTuple{N, AbstractTerm}, data) where N</code></pre><p>When a tuple of terms is provided, <code>modelcols</code> broadcasts over the individual terms.  To create a single matrix, wrap the tuple in a <a href="#StatsModels.MatrixTerm"><code>MatrixTerm</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using StableRNGs; rng = StableRNG(1);

julia&gt; d = (a = [1:9;], b = rand(rng, 9), c = repeat([&quot;d&quot;,&quot;e&quot;,&quot;f&quot;], 3));

julia&gt; ts = apply_schema(term.((:a, :b, :c)), schema(d))
a(continuous)
b(continuous)
c(DummyCoding:3→2)

julia&gt; cols = modelcols(ts, d)
([1, 2, 3, 4, 5, 6, 7, 8, 9], [0.5851946422124186, 0.07733793456911231, 0.7166282400543453, 0.3203570514066232, 0.6530930076222579, 0.2366391513734556, 0.7096838914472361, 0.5577872440804086, 0.05079002172175784], [0.0 0.0; 1.0 0.0; … ; 1.0 0.0; 0.0 1.0])

julia&gt; reduce(hcat, cols)
9×4 Matrix{Float64}:
 1.0  0.585195   0.0  0.0
 2.0  0.0773379  1.0  0.0
 3.0  0.716628   0.0  1.0
 4.0  0.320357   0.0  0.0
 5.0  0.653093   1.0  0.0
 6.0  0.236639   0.0  1.0
 7.0  0.709684   0.0  0.0
 8.0  0.557787   1.0  0.0
 9.0  0.05079    0.0  1.0

julia&gt; modelcols(MatrixTerm(ts), d)
9×4 Matrix{Float64}:
 1.0  0.585195   0.0  0.0
 2.0  0.0773379  1.0  0.0
 3.0  0.716628   0.0  1.0
 4.0  0.320357   0.0  0.0
 5.0  0.653093   1.0  0.0
 6.0  0.236639   0.0  1.0
 7.0  0.709684   0.0  0.0
 8.0  0.557787   1.0  0.0
 9.0  0.05079    0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/terms.jl#L449-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.termnames" href="#StatsModels.termnames"><code>StatsModels.termnames</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">termnames(model::StatisticalModel)</code></pre><p>Return the names of terms used in the formula of <code>model</code>.</p><p>This is a convenience method for <code>termnames(formula(model))</code>, which returns a two-tuple of <code>termnames</code> applied to the left and right hand sides of the formula.</p><p>For <code>RegressionModel</code>s with only continuous predictors, this is the same as <code>(responsename(model), coefnames(model))</code> and <code>coefnames(formula(model))</code>.</p><p>For models with categorical predictors, the returned names reflect the variable name and not the coefficients resulting from the choice of contrast coding.</p><p>See also <a href="#StatsAPI.coefnames"><code>coefnames</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/terms.jl#L586-L602">source</a></section><section><div><pre><code class="nohighlight hljs">termnames(t::FormulaTerm)</code></pre><p>Return a two-tuple of <code>termnames</code> applied to the left and right hand sides of the formula.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Until <code>apply_schema</code> has been called, literal <code>1</code> in formulae is interpreted as <code>ConstantTerm(1)</code> and will thus appear as <code>&quot;1&quot;</code> in the returned term names.</p></div></div><pre><code class="language-julia-repl hljs">julia&gt; termnames(@formula(y ~ 1 + x * y + (1+x|g)))
(&quot;y&quot;, [&quot;1&quot;, &quot;x&quot;, &quot;y&quot;, &quot;x &amp; y&quot;, &quot;(1 + x) | g&quot;])</code></pre><p>Similarly, formulae with an implicit intercept will not have a <code>&quot;1&quot;</code> in their variable names, because the implicit intercept does not exist until <code>apply_schema</code> is called (and may not exist for certain model contexts).</p><pre><code class="language-julia-repl hljs">julia&gt; termnames(@formula(y ~ x * y + (1+x|g)))
(&quot;y&quot;, [&quot;x&quot;, &quot;y&quot;, &quot;x &amp; y&quot;, &quot;(1 + x) | g&quot;])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/terms.jl#L605-L629">source</a></section><section><div><pre><code class="nohighlight hljs">termnames(term::AbstractTerm)</code></pre><p>Return the name of the statistical variable associated with a term.</p><p>Return value is either a <code>String</code>, an iterable of <code>String</code>s or the empty vector  if there is no associated variable (e.g. <code>termnames(InterceptTerm{false}())</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/terms.jl#L632-L639">source</a></section></article><h3 id="Higher-order-terms"><a class="docs-heading-anchor" href="#Higher-order-terms">Higher-order terms</a><a id="Higher-order-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Higher-order-terms" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StatsModels.FormulaTerm" href="#StatsModels.FormulaTerm"><code>StatsModels.FormulaTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FormulaTerm{L,R} &lt;: AbstractTerm</code></pre><p>Represents an entire formula, with a left- and right-hand side.  These can be of any type (captured by the type parameters).</p><p><strong>Fields</strong></p><ul><li><code>lhs::L</code>: The left-hand side (e.g., response)</li><li><code>rhs::R</code>: The right-hand side (e.g., predictors)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/terms.jl#L43-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.InteractionTerm" href="#StatsModels.InteractionTerm"><code>StatsModels.InteractionTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InteractionTerm{Ts} &lt;: AbstractTerm</code></pre><p>Represents an <em>interaction</em> between two or more individual terms.</p><p>Generated by combining multiple <code>AbstractTerm</code>s with <code>&amp;</code> (which is what calls to <code>&amp;</code> in a <code>@formula</code> lower to)</p><p><strong>Fields</strong></p><ul><li><code>terms::Ts</code>: the terms that participate in the interaction.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using StableRNGs; rng = StableRNG(1);

julia&gt; d = (y = rand(rng, 9), a = 1:9, b = rand(rng, 9), c = repeat([&quot;d&quot;,&quot;e&quot;,&quot;f&quot;], 3));

julia&gt; t = InteractionTerm(term.((:a, :b, :c)))
a(unknown) &amp; b(unknown) &amp; c(unknown)

julia&gt; t == term(:a) &amp; term(:b) &amp; term(:c)
true

julia&gt; t = apply_schema(t, schema(d))
a(continuous) &amp; b(continuous) &amp; c(DummyCoding:3→2)

julia&gt; modelcols(t, d)
9×2 Matrix{Float64}:
 0.0       0.0
 1.88748   0.0
 0.0       1.33701
 0.0       0.0
 0.725357  0.0
 0.0       0.126744
 0.0       0.0
 4.93994   0.0
 0.0       4.33378

julia&gt; modelcols(t.terms, d)
([1, 2, 3, 4, 5, 6, 7, 8, 9], [0.236781883208121, 0.9437409715735081, 0.4456708824294644, 0.7636794266904741, 0.14507148958283067, 0.021124039581375875, 0.15254507694061115, 0.617492416565387, 0.48153065407402607], [0.0 0.0; 1.0 0.0; … ; 1.0 0.0; 0.0 1.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/terms.jl#L123-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.FunctionTerm" href="#StatsModels.FunctionTerm"><code>StatsModels.FunctionTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FunctionTerm{F,Args} &lt;: AbstractTerm</code></pre><p>Represents a call to a Julia function.  The first type parameter is the type of the captured function (e.g., <code>typeof(log)</code>), and the second is the type of the captured arguments (e.g., a <code>Vector</code> of <code>AbstractTerm</code>s).</p><p>Nested function calls are captured as further <code>FunctionTerm</code>s.</p><p><strong>Fields</strong></p><ul><li><code>f::F</code>: the captured function (e.g., <code>log</code>)</li><li><code>args::Args</code>: the arguments of the call passed to <code>@formula</code>, each captured as an <code>AbstractTerm</code>.  Usually this is a <code>Vector{&lt;:AbstractTerm}</code>.</li><li><code>exorig::Expr</code>: the original expression passed to <code>@formula</code></li></ul><p><strong>Type parameters</strong></p><ul><li><code>F</code>: the type of the captured function (e.g., <code>typeof(log)</code>)</li><li><code>Args</code>: the type of container of captured arguments.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; f = @formula(y ~ log(1 + a + b))
FormulaTerm
Response:
  y(unknown)
Predictors:
  (a,b)-&gt;log(1 + a + b)

julia&gt; typeof(f.rhs)
FunctionTerm{typeof(log), Vector{FunctionTerm{typeof(+), Vector{AbstractTerm}}}}

julia&gt; typeof(only(f.rhs.args))
FunctionTerm{typeof(+), Vector{AbstractTerm}}

julia&gt; only(f.rhs.args).args
3-element Vector{AbstractTerm}:
 1
 a(unknown)
 b(unknown)

julia&gt; f.rhs.f(1 + 3 + 4)
2.0794415416798357

julia&gt; modelcols(f.rhs, (a=3, b=4))
2.0794415416798357

julia&gt; modelcols(f.rhs, (a=[3, 4], b=[4, 5]))
2-element Vector{Float64}:
 2.0794415416798357
 2.302585092994046</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/terms.jl#L59-L113">source</a></section></article><h3 id="Placeholder-terms"><a class="docs-heading-anchor" href="#Placeholder-terms">Placeholder terms</a><a id="Placeholder-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Placeholder-terms" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StatsModels.Term" href="#StatsModels.Term"><code>StatsModels.Term</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Term &lt;: AbstractTerm</code></pre><p>A placeholder for a variable in a formula where the type (and necessary data invariants) is not yet known.  This will be converted to a <a href="#StatsModels.ContinuousTerm"><code>ContinuousTerm</code></a> or <a href="#StatsModels.CategoricalTerm"><code>CategoricalTerm</code></a> by <a href="#StatsModels.apply_schema"><code>apply_schema</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>sym::Symbol</code>: The name of the data column this term refers to.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/terms.jl#L10-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.ConstantTerm" href="#StatsModels.ConstantTerm"><code>StatsModels.ConstantTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ConstantTerm{T&lt;:Number} &lt;: AbstractTerm</code></pre><p>Represents a literal number in a formula.  By default will be converted to [<code>InterceptTerm</code>] by <a href="#StatsModels.apply_schema"><code>apply_schema</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>n::T</code>: The number represented by this term.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/terms.jl#L28-L37">source</a></section></article><h3 id="Concrete-terms"><a class="docs-heading-anchor" href="#Concrete-terms">Concrete terms</a><a id="Concrete-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Concrete-terms" title="Permalink"></a></h3><p>These are all generated by <a href="#StatsModels.apply_schema"><code>apply_schema</code></a>.</p><article class="docstring"><header><a class="docstring-binding" id="StatsModels.ContinuousTerm" href="#StatsModels.ContinuousTerm"><code>StatsModels.ContinuousTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ContinuousTerm &lt;: AbstractTerm</code></pre><p>Represents a continuous variable, with a name and summary statistics.</p><p><strong>Fields</strong></p><ul><li><code>sym::Symbol</code>: The name of the variable</li><li><code>mean::T</code>: Mean</li><li><code>var::T</code>: Variance</li><li><code>min::T</code>: Minimum value</li><li><code>max::T</code>: Maximum value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/terms.jl#L187-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.CategoricalTerm" href="#StatsModels.CategoricalTerm"><code>StatsModels.CategoricalTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CategoricalTerm{C,T,N} &lt;: AbstractTerm</code></pre><p>Represents a categorical term, with a name and <a href="../contrasts/#StatsModels.ContrastsMatrix"><code>ContrastsMatrix</code></a></p><p><strong>Fields</strong></p><ul><li><code>sym::Symbol</code>: The name of the variable</li><li><code>contrasts::ContrastsMatrix</code>: A contrasts matrix that captures the unique values this variable takes on and how they are mapped onto numerical predictors.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/terms.jl#L209-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.InterceptTerm" href="#StatsModels.InterceptTerm"><code>StatsModels.InterceptTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InterceptTerm{HasIntercept} &lt;: AbstractTerm</code></pre><p>Represents the presence or (explicit) absence of an &quot;intercept&quot; term in a regression model.  These terms are generated from <a href="#StatsModels.ConstantTerm"><code>ConstantTerm</code></a>s in a formula by <code>apply_schema(::ConstantTerm, schema, ::Type{&lt;:StatisticalModel})</code>. A <code>1</code> yields <code>InterceptTerm{true}</code>, and <code>0</code> or <code>-1</code> yield <code>InterceptTerm{false}</code> (which explicitly omits an intercept for models which implicitly includes one via the <a href="#StatsModels.implicit_intercept"><code>implicit_intercept</code></a> trait).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/terms.jl#L172-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShiftedArrays.lead" href="#ShiftedArrays.lead"><code>ShiftedArrays.lead</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    lead(term, nsteps::Integer)

This `@formula` term is used to introduce lead variables.
For example `lead(x,1)` effectively adds a new column containing
the value of the `x` column from the next row.
If there is no such row (e.g. because this is the last row),
then the lead column will contain `missing` for that entry.

Note: this is only a basic row-wise lead operation.
It is up to the user to ensure that data is sorted by the temporal variable,
and that observations are spaced with regular time-steps.
(Which may require adding extra-rows filled with `missing` values.)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/temporal_terms.jl#L20-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="ShiftedArrays.lag" href="#ShiftedArrays.lag"><code>ShiftedArrays.lag</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">    lag(term, nsteps::Integer)

This `@formula` term is used to introduce lagged variables.
For example `lag(x,1)` effectively adds a new column containing
the value of the `x` column from the previous row.
If there is no such row (e.g. because this is the first row),
then the lagged column will contain `missing` for that entry.

Note: this is only a basic row-wise lag operation.
It is up to the user to ensure that data is sorted by the temporal variable,
and that observations are spaced with regular time-steps.
(Which may require adding extra-rows filled with `missing` values.)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/temporal_terms.jl#L19-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.MatrixTerm" href="#StatsModels.MatrixTerm"><code>StatsModels.MatrixTerm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MatrixTerm{Ts} &lt;: AbstractTerm</code></pre><p>A collection of terms that should be combined to produce a single numeric matrix.</p><p>A matrix term is created by <a href="#StatsModels.apply_schema"><code>apply_schema</code></a> from a tuple of terms using <a href="#StatsModels.collect_matrix_terms"><code>collect_matrix_terms</code></a>, which pulls out all the terms that are matrix terms as determined by the trait function <a href="#StatsModels.is_matrix_term"><code>is_matrix_term</code></a>, which is true by default for all <code>AbstractTerm</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/terms.jl#L231-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.collect_matrix_terms" href="#StatsModels.collect_matrix_terms"><code>StatsModels.collect_matrix_terms</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">collect_matrix_terms(ts::TupleTerm)
collect_matrix_terms(t::AbstractTerm) = collect_matrix_term((t, ))</code></pre><p>Depending on whether the component terms are matrix terms (meaning they have <a href="#StatsModels.is_matrix_term"><code>is_matrix_term(T) == true</code></a>), <code>collect_matrix_terms</code> will return</p><ol><li>A single <code>MatrixTerm</code> (if all components are matrix terms)</li><li>A tuple of the components (if none of them are matrix terms)</li><li>A tuple of terms, with all matrix terms collected into a single <code>MatrixTerm</code>  in the first element of the tuple, and the remaining non-matrix terms passed  through unchanged.</li></ol><p>By default all terms are matrix terms (that is, <code>is_matrix_term(::Type{&lt;:AbstractTerm}) = true</code>), the first case is by far the most common.  The others are provided only for convenience when dealing with specialized terms that can&#39;t be concatenated into a single model matrix, like random effects terms in <a href="https://github.com/dmbates/MixedModels.jl">MixedModels.jl</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/terms.jl#L248-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.is_matrix_term" href="#StatsModels.is_matrix_term"><code>StatsModels.is_matrix_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">is_matrix_term(::Type{&lt;:AbstractTerm})</code></pre><p>Does this type of term get concatenated with other matrix terms into a single model matrix?  This controls the behavior of the <a href="#StatsModels.collect_matrix_terms"><code>collect_matrix_terms</code></a>, which collects all of its arguments for which <code>is_matrix_term</code> returns <code>true</code> into a <a href="#StatsModels.MatrixTerm"><code>MatrixTerm</code></a>, and returns the rest unchanged.</p><p>Since all &quot;normal&quot; terms which describe one or more model matrix columns are matrix terms, this defaults to <code>true</code> for any <code>AbstractTerm</code>.</p><p>An example of a non-matrix term is a random effect term in <a href="https://github.com/dmbates/MixedModels.jl">MixedModels.jl</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/terms.jl#L286-L299">source</a></section></article><h3 id="Protection"><a class="docs-heading-anchor" href="#Protection">Protection</a><a id="Protection-1"></a><a class="docs-heading-anchor-permalink" href="#Protection" title="Permalink"></a></h3><p>For more fine-grained control over whether function calls are treated as normal Julia calls (&quot;protected&quot; and captured as <code>FunctionTerm</code>s) or as <code>@formula</code> syntax (&quot;unprotected&quot;).</p><article class="docstring"><header><a class="docstring-binding" id="StatsModels.protect" href="#StatsModels.protect"><code>StatsModels.protect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">protect(term::T)</code></pre><p>Create a <a href="#StatsModels.Protected"><code>Protected</code></a> context for interpreting <code>term</code> (and descendents) during <code>apply_schema</code>.</p><p>Outside a <a href="#StatsModels.@formula"><code>@formula</code></a>, acts as a constructor for the singleton <code>Protected{T}</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = (y=rand(4), a=[1:4;], b=rand(4));

julia&gt; f = @formula(y ~ 1 + protect(a+b));

julia&gt; modelmatrix(f.rhs, d)
4×2 Matrix{Float64}:
 1.0  1.91493
 1.0  2.19281
 1.0  3.77018
 1.0  4.78052

julia&gt; d.a .+ d.b
4-element Vector{Float64}:
 1.9149290036628313
 2.1928081162458755
 3.7701803478856664
 4.7805192636751865</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/schema.jl#L290-L319">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.unprotect" href="#StatsModels.unprotect"><code>StatsModels.unprotect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">unprotect(term)
unprotect(::Protected{T})</code></pre><p>Inside a [<code>@formula</code>], removes <a href="#StatsModels.Protected"><code>Protected</code></a> status for the argument term(s).  This allows the <a href="#StatsModels.@formula"><code>@formula</code></a>-specific interpretation of calls to <code>+</code>, <code>&amp;</code>, <code>*</code>, and <code>~</code> to be restored inside an otherwise <a href="#StatsModels.Protected"><code>Protected</code></a> context.</p><p>When called outside a <code>@formula</code>, unwraps <code>Protected{T}</code> to <code>T</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; d = (y=rand(4), a=[1.:4;], b=rand(4));

julia&gt; f = @formula(y ~ 1 - unprotect(a&amp;b));

julia&gt; modelmatrix(f, d)
4×1 Matrix{Float64}:
  0.08507099633716864
  0.6143837675082491
 -1.310541043656999
 -2.1220770547007453

julia&gt; 1 .- d.a .* d.b
4-element Vector{Float64}:
  0.08507099633716864
  0.6143837675082491
 -1.310541043656999
 -2.1220770547007453</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/schema.jl#L343-L375">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.@support_unprotect" href="#StatsModels.@support_unprotect"><code>StatsModels.@support_unprotect</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">StatsModels.@support_unprotect f sch_types...</code></pre><p>Generate methods necessary for function <code>f</code> to support <a href="#StatsModels.unprotect"><code>unprotect</code></a> inside of a <code>@formula</code> with a schema of types <code>sch_types</code>.  If not specified, <code>sch_types</code> defaults to <code>Schema, FullRank</code> (the two schema types defined in StatsModels itself).</p><p>Any function call that occurs as a child of a protected call is also protected by default.  In order to support <em>unprotecting</em> functions/operators that work directly on <code>Term</code>s (like the built-in &quot;special&quot; operators <code>+</code>, <code>&amp;</code>, <code>*</code>, and <code>~</code>), we need to add methods for <code>apply_schema(::FunctionTerm{typeof(f)}, ...)</code> that calls <code>f</code> on the captured arguments before further schema application.</p><p>This macro generates the necessary method for <code>f</code>.  For this to do something reasonable, a few conditions must be met:</p><ol><li><p>Methods must exist for <code>f(args::AbstractTerm...)</code> matching the specific signatures that users provide when calling <code>f</code> in <code>@formula</code> (and usually, returns an <code>AbstractTerm</code> of some kind).</p></li><li><p>The custom term type returned by <code>new_term = f(args::AbstractTerm...)</code> needs to do something reasonable when <code>modelcols</code> is called on it.</p></li><li><p>The thing returned by <code>modelcols(new_term, data)</code> needs to be something that can be consumed as input to whatever the parent call was for <code>f</code> in the original formula expression.</p></li></ol><p>To take a concrete example, if we have a function <code>g</code> that can do something meaningful with the output of <code>modelcols(::InteractionTerm, ...)</code>, then when a user provides something like</p><pre><code class="nohighlight hljs">@formula(g(unprotect(a &amp; b)))</code></pre><p>that gets lowered to</p><pre><code class="nohighlight hljs">FunctionTerm(g, [FuntionTerm(&amp;, [Term(:a), Term(:b)], ...)], ...)</code></pre><p>and we need to convert it to something like</p><pre><code class="nohighlight hljs">FuntionTerm(g, [Term(:a) &amp; Term(:b)], ...)</code></pre><p>during schema application, which is what the method generated by <code>@support_unprotect &amp;</code> does.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/schema.jl#L546-L590">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.Protected" href="#StatsModels.Protected"><code>StatsModels.Protected</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Protected{Ctx}</code></pre><p>Represent a context in which <code>@formula</code> DSL syntax (e.g. <code>&amp;</code> to construct <a href="#StatsModels.InteractionTerm"><code>InteractionTerm</code></a> rather than bitwise-and) and <a href="#StatsModels.apply_schema"><code>apply_schema</code></a> transformations should not apply.  This is automatically applied to the arguments of a <a href="#StatsModels.FunctionTerm"><code>FunctionTerm</code></a>, meaning that by default calls to <code>+</code>, <code>&amp;</code>, or <code>~</code> inside a <a href="#StatsModels.FunctionTerm"><code>FunctionTerm</code></a> will be interpreted as calls to the normal Julia functions, rather than term union, interaction, or formula separation.</p><p>The only special behavior with <a href="#StatsModels.apply_schema"><code>apply_schema</code></a> inside a <code>Protected</code> context is when a call to <a href="#StatsModels.unprotect"><code>unprotect</code></a> is encountered.  At that point, everything below the call to <code>unprotect</code> is treated as formula-specific syntax.</p><p>A <code>Protected</code> context is created inside a <a href="#StatsModels.FunctionTerm"><code>FunctionTerm</code></a> automatically, but can be manually created with a call to <a href="#StatsModels.protect"><code>protect</code></a>. ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/schema.jl#L268-L286">source</a></section></article><h2 id="Schema"><a class="docs-heading-anchor" href="#Schema">Schema</a><a id="Schema-1"></a><a class="docs-heading-anchor-permalink" href="#Schema" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StatsModels.Schema" href="#StatsModels.Schema"><code>StatsModels.Schema</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StatsModels.Schema</code></pre><p>Struct that wraps a <code>Dict</code> mapping <code>Term</code>s to their concrete forms.  This exists mainly for dispatch purposes and to support possibly more sophisticated behavior in the future.</p><p>A <code>Schema</code> behaves for all intents and purposes like an immutable <code>Dict</code>, and delegates the constructor as well as <code>getindex</code>, <code>get</code>, <code>merge!</code>, <code>merge</code>, <code>keys</code>, and <code>haskey</code> to the wrapped <code>Dict</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/schema.jl#L24-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.schema" href="#StatsModels.schema"><code>StatsModels.schema</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">schema([terms::AbstractVector{&lt;:AbstractTerm}, ]data, hints::Dict{Symbol})
schema(term::AbstractTerm, data, hints::Dict{Symbol})</code></pre><p>Compute all the invariants necessary to fit a model with <code>terms</code>.  A schema is a dict that maps <code>Term</code>s to their concrete instantiations (either <code>CategoricalTerm</code>s or <code>ContinuousTerm</code>s.  &quot;Hints&quot; may optionally be supplied in the form of a <code>Dict</code> mapping term names (as <code>Symbol</code>s) to term or contrast types.  If a hint is not provided for a variable, the appropriate term type will be guessed based on the data type from the data column: any numeric data is assumed to be continuous, and any non-numeric data is assumed to be categorical.</p><p>Returns a <a href="#StatsModels.Schema"><code>StatsModels.Schema</code></a>, which is a wrapper around a <code>Dict</code> mapping <code>Term</code>s to their concrete instantiations (<code>ContinuousTerm</code> or <code>CategoricalTerm</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using StableRNGs; rng = StableRNG(1);

julia&gt; d = (x=sample(rng, [:a, :b, :c], 10), y=rand(rng, 10));

julia&gt; ts = [Term(:x), Term(:y)];

julia&gt; schema(ts, d)
StatsModels.Schema with 2 entries:
  x =&gt; x
  y =&gt; y

julia&gt; schema(ts, d, Dict(:x =&gt; HelmertCoding()))
StatsModels.Schema with 2 entries:
  x =&gt; x
  y =&gt; y

julia&gt; schema(term(:y), d, Dict(:y =&gt; CategoricalTerm))
StatsModels.Schema with 1 entry:
  y =&gt; y</code></pre><p>Note that concrete <code>ContinuousTerm</code> and <code>CategoricalTerm</code> and un-typed <code>Term</code>s print the same in a container, but when printed alone are different:</p><pre><code class="language-julia-repl hljs">julia&gt; sch = schema(ts, d)
StatsModels.Schema with 2 entries:
  x =&gt; x
  y =&gt; y

julia&gt; term(:x)
x(unknown)

julia&gt; sch[term(:x)]
x(DummyCoding:3→2)

julia&gt; sch[term(:y)]
y(continuous)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/schema.jl#L58-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.concrete_term" href="#StatsModels.concrete_term"><code>StatsModels.concrete_term</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">concrete_term(t::Term, data[, hint])</code></pre><p>Create concrete term from the placeholder <code>t</code> based on a data source and optional hint.  If <code>data</code> is a table, the <code>getproperty</code> is used to extract the appropriate column.</p><p>The <code>hint</code> can be a <code>Dict{Symbol}</code> of hints, or a specific hint, a concrete term type (<code>ContinuousTerm</code> or <code>CategoricalTerm</code>), or an instance of some <code>&lt;:AbstractContrasts</code>, in which case a <code>CategoricalTerm</code> will be created using those contrasts.</p><p>If no hint is provided (or <code>hint==nothing</code>), the <code>eltype</code> of the data is used: <code>Number</code>s are assumed to be continuous, and all others are assumed to be categorical.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; concrete_term(term(:a), [1, 2, 3])
a(continuous)

julia&gt; concrete_term(term(:a), [1, 2, 3], nothing)
a(continuous)

julia&gt; concrete_term(term(:a), [1, 2, 3], CategoricalTerm)
a(DummyCoding:3→2)

julia&gt; concrete_term(term(:a), [1, 2, 3], EffectsCoding())
a(EffectsCoding:3→2)

julia&gt; concrete_term(term(:a), [1, 2, 3], Dict(:a=&gt;EffectsCoding()))
a(EffectsCoding:3→2)

julia&gt; concrete_term(term(:a), (a = [1, 2, 3], b = [0.0, 0.5, 1.0]))
a(continuous)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/schema.jl#L133-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.apply_schema" href="#StatsModels.apply_schema"><code>StatsModels.apply_schema</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">apply_schema(t, schema::StatsModels.Schema[, Mod::Type = Nothing])</code></pre><p>Return a new term that is the result of applying <code>schema</code> to term <code>t</code> with destination model (type) <code>Mod</code>.  If <code>Mod</code> is omitted, <code>Nothing</code> will be used.</p><p>When <code>t</code> is a <code>ContinuousTerm</code> or <code>CategoricalTerm</code> already, the term will be returned unchanged <em>unless</em> a matching term is found in the schema.  This allows selective re-setting of a schema to change the contrast coding or levels of a categorical term, or to change a continuous term to categorical or vice versa.</p><p>When defining behavior for custom term types, it&#39;s best to dispatch on <a href="#StatsModels.Schema"><code>StatsModels.Schema</code></a> for the second argument.  Leaving it as <code>::Any</code> will work in <em>most</em> cases, but cause method ambiguity in some.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/schema.jl#L223-L237">source</a></section><section><div><pre><code class="nohighlight hljs">apply_schema(t::AbstractTerm, schema::StatsModels.FullRank, Mod::Type)</code></pre><p>Apply a schema, under the assumption that when a less-than-full rank model matrix would be produced, categorical terms should be &quot;promoted&quot; to full rank (where a categorical variable with <span>$k$</span> levels would produce <span>$k$</span> columns, instead of <span>$k-1$</span> in the standard contrast coding schemes).  This step is applied automatically when <code>Mod &lt;: StatisticalModel</code>, but other types of models can opt-in by adding a method like</p><pre><code class="nohighlight hljs">StatsModels.apply_schema(t::FormulaTerm, schema::StatsModels.Schema, Mod::Type{&lt;:MyModelType}) =
    apply_schema(t, StatsModels.FullRank(schema), mod)</code></pre><p>See the section on <a href="../contrasts/#Modeling-categorical-data">Modeling categorical data</a> in the docs for more information on how promotion of categorical variables works.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/schema.jl#L437-L454">source</a></section></article><h2 id="Modeling"><a class="docs-heading-anchor" href="#Modeling">Modeling</a><a id="Modeling-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.fit" href="#StatsAPI.fit"><code>StatsAPI.fit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit(Mod::Type{&lt;:StatisticalModel}, f::FormulaTerm, data, args...;
    contrasts::Dict{Symbol}, kwargs...)</code></pre><p>Convert tabular data into a numeric response vector and predictor matrix using the formula <code>f</code>, and then <code>fit</code> the specified model type, wrapping the result in a <a href="#StatsModels.TableRegressionModel"><code>TableRegressionModel</code></a> or <a href="#StatsModels.TableStatisticalModel"><code>TableStatisticalModel</code></a> (as appropriate).</p><p>This is intended as a backstop for modeling packages that implement model types that are subtypes of <code>StatsAPI.StatisticalModel</code> but do not explicitly support the full StatsModels terms-based interface.  Currently this works by creating a <a href="#StatsModels.ModelFrame"><code>ModelFrame</code></a> from the formula and data, and then converting this to a <a href="#StatsModels.ModelMatrix"><code>ModelMatrix</code></a>, but this is an internal implementation detail which may change in the near future.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/statsmodel.jl#L109-L124">source</a></section><section><div><p>Fit a statistical model.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.gvif" href="#StatsAPI.gvif"><code>StatsAPI.gvif</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">gvif(m::RegressionModel; scale=false)</code></pre><p>Compute the generalized variance inflation factor (GVIF).</p><p>If <code>scale=true</code>, then each GVIF is scaled by the degrees of freedom for (number of coefficients associated with) the predictor: <span>$GVIF^(1 / (2*df))$</span>.</p><p>The <a href="https://doi.org/10.2307/2290467">GVIF</a> measures the increase in the variance of a (group of) parameter&#39;s estimate in a model with multiple parameters relative to the variance of a parameter&#39;s estimate in a model containing only that parameter. For continuous, numerical predictors, the GVIF is the same as the VIF, but for categorical predictors, the GVIF provides a single number for the entire group of contrast-coded coefficients associated with a categorical predictor.</p><p>See also <a href="#StatsAPI.vif"><code>vif</code></a>.</p><p><strong>References</strong></p><p>Fox, J., &amp; Monette, G. (1992). Generalized Collinearity Diagnostics. Journal of the American Statistical Association, 87(417), 178. doi:10.2307/2290467</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.lrtest" href="#StatsModels.lrtest"><code>StatsModels.lrtest</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">lrtest(mods::StatisticalModel...; atol::Real=0.0)</code></pre><p>For each sequential pair of statistical models in <code>mods...</code>, perform a likelihood ratio test to determine if the first one fits significantly better than the next.</p><p>A table is returned containing degrees of freedom (DOF), difference in DOF from the preceding model, log-likelihood, deviance, chi-squared statistic (i.e. absolute value of twice the difference in log-likelihood) and p-value for the comparison between the two models.</p><p>Optional keyword argument <code>atol</code> controls the numerical tolerance when testing whether the models are nested.</p><p><strong>Examples</strong></p><p>Suppose we want to compare the effects of two or more treatments on some result. Our null hypothesis is that <code>Result ~ 1</code> fits the data as well as <code>Result ~ 1 + Treatment</code>.</p><pre><code class="language-julia-repl hljs">julia&gt; using DataFrames, GLM

julia&gt; dat = DataFrame(Result=[1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1],
                       Treatment=[1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2],
                       Other=string.([1, 1, 2, 1, 2, 1, 3, 1, 1, 2, 2, 1]));

julia&gt; nullmodel = glm(@formula(Result ~ 1), dat, Binomial(), LogitLink());

julia&gt; model = glm(@formula(Result ~ 1 + Treatment), dat, Binomial(), LogitLink());

julia&gt; bigmodel = glm(@formula(Result ~ 1 + Treatment + Other), dat, Binomial(), LogitLink());

julia&gt; lrtest(nullmodel, model, bigmodel)
Likelihood-ratio test: 3 models fitted on 12 observations
────────────────────────────────────────────────────
     DOF  ΔDOF   LogLik  Deviance   Chisq  p(&gt;Chisq)
────────────────────────────────────────────────────
[1]    1        -8.1503   16.3006
[2]    2     1  -7.9780   15.9559  0.3447     0.5571
[3]    4     2  -7.0286   14.0571  1.8988     0.3870
────────────────────────────────────────────────────

julia&gt; lrtest(bigmodel, model, nullmodel)
Likelihood-ratio test: 3 models fitted on 12 observations
────────────────────────────────────────────────────
     DOF  ΔDOF   LogLik  Deviance   Chisq  p(&gt;Chisq)
────────────────────────────────────────────────────
[1]    4        -7.0286   14.0571
[2]    2    -2  -7.9780   15.9559  1.8988     0.3870
[3]    1    -1  -8.1503   16.3006  0.3447     0.5571
────────────────────────────────────────────────────</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/lrtest.jl#L20-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.formula" href="#StatsModels.formula"><code>StatsModels.formula</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">formula(model)</code></pre><p>Retrieve formula from a fitted or specified model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/statsmodel.jl#L99-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.modelmatrix" href="#StatsAPI.modelmatrix"><code>StatsAPI.modelmatrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">modelmatrix(model::RegressionModel)</code></pre><p>Return the model matrix (a.k.a. the design matrix).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.response" href="#StatsAPI.response"><code>StatsAPI.response</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">response(model::RegressionModel)</code></pre><p>Return the model response (a.k.a. the dependent variable).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsAPI.vif" href="#StatsAPI.vif"><code>StatsAPI.vif</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">vif(m::RegressionModel)</code></pre><p>Compute the variance inflation factor (VIF).</p><p>The <a href="https://en.wikipedia.org/wiki/Variance_inflation_factor">VIF</a> measures the increase in the variance of a parameter&#39;s estimate in a model with multiple parameters relative to the variance of a parameter&#39;s estimate in a model containing only that parameter.</p><p>See also <a href="#StatsAPI.gvif"><code>gvif</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>This method will fail if there is (numerically) perfect multicollinearity, i.e. rank deficiency. In that case though, the VIF is not particularly informative anyway.</p></div></div></div></section></article><h3 id="Traits"><a class="docs-heading-anchor" href="#Traits">Traits</a><a id="Traits-1"></a><a class="docs-heading-anchor-permalink" href="#Traits" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StatsModels.implicit_intercept" href="#StatsModels.implicit_intercept"><code>StatsModels.implicit_intercept</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">implicit_intercept(T::Type)
implicit_intercept(x::T) = implicit_intercept(T)</code></pre><p>Return <code>true</code> if models of type <code>T</code> should include an implicit intercept even if none is specified in the formula.  Is <code>true</code> by default for all <code>T&lt;:StatisticalModel</code>, and <code>false</code> for others.  To specify that a model type <code>T</code> includes an intercept even if one is not specified explicitly in the formula, overload this function for the corresponding type: <code>implicit_intercept(::Type{&lt;:T}) = true</code></p><p>If a model has an implicit intercept, it can be explicitly excluded by using <code>0</code> in the formula, which generates <a href="#StatsModels.InterceptTerm"><code>InterceptTerm{false}</code></a> with <a href="#StatsModels.apply_schema"><code>apply_schema</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/traits.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.drop_intercept" href="#StatsModels.drop_intercept"><code>StatsModels.drop_intercept</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">drop_intercept(T::Type)
drop_intercept(x::T) = drop_intercept(T)</code></pre><p>Define whether a given model automatically drops the intercept. Return <code>false</code> by default.  To specify that a model type <code>T</code> drops the intercept, overload this function for the  corresponding type: <code>drop_intercept(::Type{&lt;:T}) = true</code></p><p>Models that drop the intercept will be fitted without one: the intercept term will be  removed even if explicitly provided by the user. Categorical variables will be expanded  in the rank-reduced form (contrasts for <code>n</code> levels will only produce <code>n-1</code> columns).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/traits.jl#L22-L33">source</a></section></article><h3 id="Wrappers"><a class="docs-heading-anchor" href="#Wrappers">Wrappers</a><a id="Wrappers-1"></a><a class="docs-heading-anchor-permalink" href="#Wrappers" title="Permalink"></a></h3><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>These are internal implementation details that are likely to change in the near future.  In particular, the <code>ModelFrame</code> and <code>ModelMatrix</code> wrappers are dispreferred in favor of using terms directly, and can in most cases be replaced by something like</p><pre><code class="language-julia hljs"># instead of ModelMatrix(ModelFrame(f::FormulaTerm, data, model=MyModel))
sch = schema(f, data)
f = apply_schema(f, sch, MyModel)
response, predictors = modelcols(f, data)</code></pre></div></div><article class="docstring"><header><a class="docstring-binding" id="StatsModels.ModelFrame" href="#StatsModels.ModelFrame"><code>StatsModels.ModelFrame</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModelFrame(formula, data; model=StatisticalModel, contrasts=Dict())</code></pre><p>Wrapper that encapsulates a <code>FormulaTerm</code>, schema, data table, and model type.</p><p>This wrapper encapsulates all the information that&#39;s required to transform data of the same structure as the wrapped data frame into a model matrix (the <code>FormulaTerm</code>), as well as the information about how that formula term was instantiated (the schema and model type)</p><p>Creating a model frame involves first extracting the <a href="#StatsModels.schema"><code>schema</code></a> for the data (using any contrasts provided as hints), and then applying that schema with <a href="#StatsModels.apply_schema"><code>apply_schema</code></a> to the formula in the context of the provided model type.</p><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">ModelFrame(f::FormulaTerm, data; model::Type{M} = StatisticalModel, contrasts::Dict = Dict())</code></pre><p><strong>Fields</strong></p><ul><li><code>f::FormulaTerm</code>: Formula whose left hand side is the <em>response</em> and right hand side are the <em>predictors</em>.</li><li><code>schema::Any</code>: The schema that was applied to generate <code>f</code>.</li><li><code>data::D</code>: The data table being modeled.  The only restriction is that <code>data</code> is a table (<code>Tables.istable(data) == true</code>)</li><li><code>model::Type{M}</code>: The type of the model that will be fit from this model frame.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">julia&gt; df = (x = 1:4, y = 5:8)
julia&gt; mf = ModelFrame(@formula(y ~ 1 + x), df)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/modelframe.jl#L1-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.ModelMatrix" href="#StatsModels.ModelMatrix"><code>StatsModels.ModelMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ModelMatrix(mf::ModelFrame)</code></pre><p>Convert a <code>ModelFrame</code> into a numeric matrix suitable for modeling</p><p><strong>Fields</strong></p><ul><li><code>m::AbstractMatrix{&lt;:AbstractFloat}</code>: the generated numeric matrix</li><li><code>assign::Vector{Int}</code> the index of the term corresponding to each column of <code>m</code>.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia hljs">ModelMatrix(mf::ModelFrame)
# Specify the type of the resulting matrix (default Matrix{Float64})
ModelMatrix{T &lt;: AbstractMatrix{&lt;:AbstractFloat}}(mf::ModelFrame)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/modelframe.jl#L192-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.TableStatisticalModel" href="#StatsModels.TableStatisticalModel"><code>StatsModels.TableStatisticalModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wrapper for a <code>StatisticalModel</code> that has been fit from a <code>@formula</code> and tabular data.</p><p>Most functions from the StatsBase API are simply delegated to the wrapped model, with the exception of functions like <code>fit</code>, <code>predict</code>, and <code>coefnames</code> where the tabular nature of the data means that additional processing is required or information provided by the formula.</p><p><strong>Fields</strong></p><ul><li><code>model::M</code> the wrapped <code>StatisticalModel</code>.</li><li><code>mf::ModelFrame</code> encapsulates the formula, schema, and model type.</li><li><code>mm::ModelMatrix{T}</code> the model matrix that the model was fit from.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/statsmodel.jl#L35-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.TableRegressionModel" href="#StatsModels.TableRegressionModel"><code>StatsModels.TableRegressionModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wrapper for a <code>RegressionModel</code> that has been fit from a <code>@formula</code> and tabular data.</p><p>Most functions from the StatsBase API are simply delegated to the wrapped model, with the exception of functions like <code>fit</code>, <code>predict</code>, and <code>coefnames</code> where the tabular nature of the data means that additional processing is required or information provided by the formula.</p><p><strong>Fields</strong></p><ul><li><code>model::M</code> the wrapped <code>RegressioModel</code>.</li><li><code>mf::ModelFrame</code> encapsulates the formula, schema, and model type.</li><li><code>mm::ModelMatrix{T}</code> the model matrix that the model was fit from.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/e029ef4b34d1660ec23b147e3d91bccd1b7ac286/src/statsmodel.jl#L55-L68">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../temporal_terms/">« Temporal variables and Time Series Terms</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Friday 16 August 2024 15:39">Friday 16 August 2024</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
