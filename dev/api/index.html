<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API documentation · StatsModels.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>StatsModels.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../formula/">Modeling tabular data</a></li><li><a class="toctext" href="../internals/">Internals and extending the <code>@formula</code></a></li><li><a class="toctext" href="../contrasts/">Contrast coding categorical variables</a></li><li><a class="toctext" href="../temporal_terms/">Temporal variables and Time Series Terms</a></li><li class="current"><a class="toctext" href>API documentation</a><ul class="internal"><li><a class="toctext" href="#Formulae-and-terms-1">Formulae and terms</a></li><li><a class="toctext" href="#Schema-1">Schema</a></li><li><a class="toctext" href="#Modeling-1">Modeling</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>API documentation</a></li></ul><a class="edit-page" href="https://github.com/JuliaStats/StatsModels.jl/blob/master/docs/src/api.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>API documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="StatsModels.jl-API-1" href="#StatsModels.jl-API-1">StatsModels.jl API</a></h1><h2><a class="nav-anchor" id="Formulae-and-terms-1" href="#Formulae-and-terms-1">Formulae and terms</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.@formula" href="#StatsModels.@formula"><code>StatsModels.@formula</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@formula(ex)</code></pre><p>Capture and parse a formula expression as a <code>Formula</code> struct.</p><p>A formula is an abstract specification of a dependence between <em>left-hand</em> and <em>right-hand</em> side variables as in, e.g., a regression model.  Each side specifies at a high level how tabular data is to be converted to a numerical matrix suitable for modeling.  This specification looks something like Julia code, is represented as a Julia <code>Expr</code>, but uses special syntax.  The <code>@formula</code> macro takes an expression like <code>y ~ 1 + a*b</code>, transforms it according to the formula syntax rules into a lowered form (like <code>y ~ 1 + a + b + a&amp;b</code>), and constructs a <code>Formula</code> struct which captures the original expression, the lowered expression, and the left- and right-hand-side.</p><p>Operators that have special interpretations in this syntax are</p><ul><li><code>~</code> is the formula separator, where it is a binary operator (the first argument is the left-hand side, and the second is the right-hand side.</li><li><code>+</code> concatenates variables as columns when generating a model matrix.</li><li><code>&amp;</code> representes an <em>interaction</em> between two or more variables, which corresponds to a row-wise kronecker product of the individual terms (or element-wise product if all terms involved are continuous/scalar).</li><li><code>*</code> expands to all main effects and interactions: <code>a*b</code> is equivalent to <code>a+b+a&amp;b</code>, <code>a*b*c</code> to <code>a+b+c+a&amp;b+a&amp;c+b&amp;c+a&amp;b&amp;c</code>, etc.</li><li><code>1</code>, <code>0</code>, and <code>-1</code> indicate the presence (for <code>1</code>) or absence (for <code>0</code> and <code>-1</code>) of an intercept column.</li></ul><p>The rules that are applied are</p><ul><li>The associative rule (un-nests nested calls to <code>+</code>, <code>&amp;</code>, and <code>*</code>).</li><li>The distributive rule (interactions <code>&amp;</code> distribute over concatenation <code>+</code>).</li><li>The <code>*</code> rule expands <code>a*b</code> to <code>a+b+a&amp;b</code> (recursively).</li><li>Subtraction is converted to addition and negation, so <code>x-1</code> becomes <code>x + -1</code> (applies only to subtraction of literal 1).</li><li>Single-argument <code>&amp;</code> calls are stripped, so <code>&amp;(x)</code> becomes the main effect <code>x</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/formula.jl#L23-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.term" href="#StatsModels.term"><code>StatsModels.term</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">term(x)</code></pre><p>Wrap argument in an appropriate <code>AbstractTerm</code> type: <code>Symbol</code>s become <code>Term</code>s, and <code>Number</code>s become <code>ConstantTerm</code>s.  Any <code>AbstractTerm</code>s are unchanged.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ts = term.((1, :a, :b))
1
a(unknown)
b(unknown)

julia&gt; typeof(ts)
Tuple{ConstantTerm{Int64},Term,Term}</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/terms.jl#L579-L596">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.coefnames" href="#StatsBase.coefnames"><code>StatsBase.coefnames</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">coefnames(obj::StatisticalModel)</code></pre><p>Return the names of the coefficients.</p></div></div><div><div><pre><code class="language-none">coefnames(term::AbstractTerm)</code></pre><p>Return the name(s) of column(s) generated by a term.  Return value is either a <code>String</code> or an iterable of <code>String</code>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/terms.jl#L542-L547">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.modelcols" href="#StatsModels.modelcols"><code>StatsModels.modelcols</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">modelcols(t::AbstractTerm, data)</code></pre><p>Create a numerical &quot;model columns&quot; representation of data based on an <code>AbstractTerm</code>.  <code>data</code> can either be a whole table (a property-accessible collection of iterable columns or iterable collection of property-accessible rows, as defined by <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> or a single row (in the form of a <code>NamedTuple</code> of scalar values).  Tables will be converted to a <code>NamedTuple</code> of <code>Vectors</code> (e.g., a <code>Tables.ColumnTable</code>).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/terms.jl#L410-L419">source</a><div><div><pre><code class="language-none">modelcols(ts::NTuple{N, AbstractTerm}, data) where N</code></pre><p>When a tuple of terms is provided, <code>modelcols</code> broadcasts over the individual  terms.  To create a single matrix, wrap the tuple in a <a href="#StatsModels.MatrixTerm"><code>MatrixTerm</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; d = (a = [1:9;], b = rand(9), c = repeat([&quot;d&quot;,&quot;e&quot;,&quot;f&quot;], 3));

julia&gt; ts = apply_schema(term.((:a, :b, :c)), schema(d))
a(continuous) 
b(continuous)
c(DummyCoding:3→2)

julia&gt; cols = modelcols(ts, d)
([1, 2, 3, 4, 5, 6, 7, 8, 9], [0.7184176729016183, 0.4881665815778522, 0.7081609847641785, 0.7743011281211944, 0.584295963367869, 0.32493666547553657, 0.9894077965577408, 0.3331747574477202, 0.6532298571732302], [0.0 0.0; 1.0 0.0; … ; 1.0 0.0; 0.0 1.0])

julia&gt; reduce(hcat, cols)
9×4 Array{Float64,2}:
 1.0  0.718418  0.0  0.0
 2.0  0.488167  1.0  0.0
 3.0  0.708161  0.0  1.0
 4.0  0.774301  0.0  0.0
 5.0  0.584296  1.0  0.0
 6.0  0.324937  0.0  1.0
 7.0  0.989408  0.0  0.0
 8.0  0.333175  1.0  0.0
 9.0  0.65323   0.0  1.0

julia&gt; modelcols(MatrixTerm(ts), d)
9×4 Array{Float64,2}:
 1.0  0.718418  0.0  0.0
 2.0  0.488167  1.0  0.0
 3.0  0.708161  0.0  1.0
 4.0  0.774301  0.0  0.0
 5.0  0.584296  1.0  0.0
 6.0  0.324937  0.0  1.0
 7.0  0.989408  0.0  0.0
 8.0  0.333175  1.0  0.0
 9.0  0.65323   0.0  1.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/terms.jl#L432-L475">source</a></section><h3><a class="nav-anchor" id="Higher-order-terms-1" href="#Higher-order-terms-1">Higher-order terms</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.FormulaTerm" href="#StatsModels.FormulaTerm"><code>StatsModels.FormulaTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FormulaTerm{L,R} &lt;: AbstractTerm</code></pre><p>Represents an entire formula, with a left- and right-hand side.  These can be of any type (captured by the type parameters).  </p><p><strong>Fields</strong></p><ul><li><code>lhs::L</code>: The left-hand side (e.g., response)</li><li><code>rhs::R</code>: The right-hand side (e.g., predictors)</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/terms.jl#L41-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.InteractionTerm" href="#StatsModels.InteractionTerm"><code>StatsModels.InteractionTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">InteractionTerm{Ts} &lt;: AbstractTerm</code></pre><p>Represents an <em>interaction</em> between two or more individual terms.  </p><p>Generated by combining multiple <code>AbstractTerm</code>s with <code>&amp;</code> (which is what calls to <code>&amp;</code> in a <code>@formula</code> lower to)</p><p><strong>Fields</strong></p><ul><li><code>terms::Ts</code>: the terms that participate in the interaction.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; d = (y = rand(9), a = 1:9, b = rand(9), c = repeat([&quot;d&quot;,&quot;e&quot;,&quot;f&quot;], 3));

julia&gt; t = InteractionTerm(term.((:a, :b, :c)))
a(unknown) &amp; b(unknown) &amp; c(unknown)

julia&gt; t == term(:a) &amp; term(:b) &amp; term(:c)
true

julia&gt; t = apply_schema(t, schema(d))
a(continuous) &amp; b(continuous) &amp; c(DummyCoding:3→2)

julia&gt; modelcols(t, d)
9×2 Array{Float64,2}:
 0.0      0.0    
 1.09793  0.0    
 0.0      2.6946 
 0.0      0.0    
 4.67649  0.0    
 0.0      4.47245
 0.0      0.0    
 0.64805  0.0    
 0.0      6.97926

julia&gt; modelcols(t.terms, d)
([1, 2, 3, 4, 5, 6, 7, 8, 9], [0.8865801492659497, 0.5489667874821704, 0.8981985570141182, 0.5043129521484462, 0.9352977047074365, 0.7454079139997376, 0.4898716849925324, 0.08100620947201143, 0.7754728346104993], [0.0 0.0; 1.0 0.0; … ; 1.0 0.0; 0.0 1.0])</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/terms.jl#L130-L171">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.FunctionTerm" href="#StatsModels.FunctionTerm"><code>StatsModels.FunctionTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">FunctionTerm{Forig,Fanon,Names} &lt;: AbstractTerm</code></pre><p>Represents a call to a Julia function.  The first type parameter is the type of the function as originally specified (e.g., <code>typeof(log)</code>), while the second is the type of the anonymous function that will be applied element-wise to the data table.</p><p>The <code>FunctionTerm</code> <em>also</em> captures the arguments of the original call and parses them <em>as if</em> they were part of a special DSL call, applying the rules to expand <code>*</code>, distribute <code>&amp;</code> over <code>+</code>, and wrap symbols in <code>Term</code>s.  </p><p>By storing the original function as a type parameter <em>and</em> pessimistically parsing the arguments as if they&#39;re part of a special DSL call, this allows custom syntax to be supported with minimal extra effort.  Packages can dispatch on <code>apply_schema(f::FunctionTerm{typeof(special_syntax)}, schema, ::Type{&lt;:MyModel})</code> and pull out the arguments parsed as terms from <code>f.args_parsed</code> to construct their own custom terms.</p><p><strong>Fields</strong></p><ul><li><code>forig::Forig</code>: the original function (e.g., <code>log</code>)</li><li><code>fanon::Fanon</code>: the generated anonymous function (e.g., <code>(a, b) -&gt; log(1+a+b)</code>)</li><li><code>exorig::Expr</code>: the original expression passed to <code>@formula</code></li><li><code>args_parsed::Vector</code>: the arguments of the call passed to <code>@formula</code>, each  parsed <em>as if</em> the call was a &quot;special&quot; DSL call.</li></ul><p><strong>Type parameters</strong></p><ul><li><code>Forig</code>: the type of the original function (e.g., <code>typeof(log)</code>)</li><li><code>Fanon</code>: the type of the generated anonymous function</li><li><code>Names</code>: the names of the arguments to the anonymous function (as a <code>NTuple{N,Symbol}</code>)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; f = @formula(y ~ log(1 + a + b))
FormulaTerm
Response:
  y(unknown)
Predictors:
  (a,b)-&gt;log(1 + a + b)

julia&gt; typeof(f.rhs)
FunctionTerm{typeof(log),var&quot;##1#2&quot;,(:a, :b)}

julia&gt; f.rhs.forig(1 + 3 + 4)
2.0794415416798357

julia&gt; f.rhs.fanon(3, 4)
2.0794415416798357

julia&gt; modelcols(f.rhs, (a=3, b=4))
2.0794415416798357

julia&gt; modelcols(f.rhs, (a=[3, 4], b=[4, 5]))
2-element Array{Float64,1}:
 2.0794415416798357
 2.302585092994046 </code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/terms.jl#L57-L118">source</a></section><h3><a class="nav-anchor" id="Placeholder-terms-1" href="#Placeholder-terms-1">Placeholder terms</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.Term" href="#StatsModels.Term"><code>StatsModels.Term</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">Term &lt;: AbstractTerm</code></pre><p>A placeholder for a variable in a formula where the type (and necessary data invariants) is not yet known.  This will be converted to a <a href="#StatsModels.ContinuousTerm"><code>ContinuousTerm</code></a> or <a href="#StatsModels.CategoricalTerm"><code>CategoricalTerm</code></a> by <a href="#StatsModels.apply_schema"><code>apply_schema</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>sym::Symbol</code>: The name of the data column this term refers to.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/terms.jl#L8-L18">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.ConstantTerm" href="#StatsModels.ConstantTerm"><code>StatsModels.ConstantTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ConstantTerm{T&lt;:Number} &lt;: AbstractTerm</code></pre><p>Represents a literal number in a formula.  By default will be converted to [<code>InterceptTerm</code>] by <a href="#StatsModels.apply_schema"><code>apply_schema</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>n::T</code>: The number represented by this term.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/terms.jl#L26-L35">source</a></section><h3><a class="nav-anchor" id="Concrete-terms-1" href="#Concrete-terms-1">Concrete terms</a></h3><p>These are all generated by <a href="#StatsModels.apply_schema"><code>apply_schema</code></a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.ContinuousTerm" href="#StatsModels.ContinuousTerm"><code>StatsModels.ContinuousTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ContinuousTerm &lt;: AbstractTerm</code></pre><p>Represents a continuous variable, with a name and summary statistics.</p><p><strong>Fields</strong></p><ul><li><code>sym::Symbol</code>: The name of the variable</li><li><code>mean::T</code>: Mean</li><li><code>var::T</code>: Variance</li><li><code>min::T</code>: Minimum value</li><li><code>max::T</code>: Maximum value</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/terms.jl#L192-L204">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.CategoricalTerm" href="#StatsModels.CategoricalTerm"><code>StatsModels.CategoricalTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">CategoricalTerm{C,T,N} &lt;: AbstractTerm</code></pre><p>Represents a categorical term, with a name and <a href="../contrasts/#StatsModels.ContrastsMatrix"><code>ContrastsMatrix</code></a></p><p><strong>Fields</strong></p><ul><li><code>sym::Symbol</code>: The name of the variable</li><li><code>contrasts::ContrastsMatrix</code>: A contrasts matrix that captures the unique  values this variable takes on and how they are mapped onto numerical  predictors.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/terms.jl#L214-L225">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.InterceptTerm" href="#StatsModels.InterceptTerm"><code>StatsModels.InterceptTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">InterceptTerm{HasIntercept} &lt;: AbstractTerm</code></pre><p>Represents the presence or (explicit) absence of an &quot;intercept&quot; term in a regression model.  These terms are generated from <a href="#StatsModels.ConstantTerm"><code>ConstantTerm</code></a>s in a formula by <code>apply_schema(::ConstantTerm, schema, ::Type{&lt;:StatisticalModel})</code>. A <code>1</code> yields <code>InterceptTerm{true}</code>, and <code>0</code> or <code>-1</code> yield <code>InterceptTerm{false}</code> (which explicitly omits an intercept for models which implicitly includes one via the <a href="#StatsModels.implicit_intercept"><code>implicit_intercept</code></a> trait).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/terms.jl#L177-L186">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ShiftedArrays.lead" href="#ShiftedArrays.lead"><code>ShiftedArrays.lead</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">    lead(term, nsteps::Integer)

This `@formula` term is used to introduce lead variables.
For example `lead(x,1)` effectively adds a new column containing
the value of the `x` column from the next row.
If there is no such row (e.g. because this is the last row),
then the lead column will contain `missing` for that entry.

Note: this is only a basic row-wise lead operation.
It is up to the user to ensure that data is sorted by the temporal variable,
and that observations are spaced with regular time-steps.
(Which may require adding extra-rows filled with `missing` values.)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/temporal_terms.jl#L20-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="ShiftedArrays.lag" href="#ShiftedArrays.lag"><code>ShiftedArrays.lag</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">    lag(term, nsteps::Integer)

This `@formula` term is used to introduce lagged variables.
For example `lag(x,1)` effectively adds a new column containing
the value of the `x` column from the previous row.
If there is no such row (e.g. because this is the first row),
then the lagged column will contain `missing` for that entry.

Note: this is only a basic row-wise lag operation.
It is up to the user to ensure that data is sorted by the temporal variable,
and that observations are spaced with regular time-steps.
(Which may require adding extra-rows filled with `missing` values.)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/temporal_terms.jl#L19-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.MatrixTerm" href="#StatsModels.MatrixTerm"><code>StatsModels.MatrixTerm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">MatrixTerm{Ts} &lt;: AbstractTerm</code></pre><p>A collection of terms that should be combined to produce a single numeric matrix.</p><p>A matrix term is created by <a href="#StatsModels.apply_schema"><code>apply_schema</code></a> from a tuple of terms using  <a href="#StatsModels.collect_matrix_terms"><code>collect_matrix_terms</code></a>, which pulls out all the terms that are matrix terms as determined by the trait function <a href="#StatsModels.is_matrix_term"><code>is_matrix_term</code></a>, which is  true by default for all <code>AbstractTerm</code>s.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/terms.jl#L236-L245">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.collect_matrix_terms" href="#StatsModels.collect_matrix_terms"><code>StatsModels.collect_matrix_terms</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">collect_matrix_terms(ts::TupleTerm)
collect_matrix_terms(t::AbstractTerm) = collect_matrix_term((t, ))</code></pre><p>Depending on whether the component terms are matrix terms (meaning they have <a href="#StatsModels.is_matrix_term"><code>is_matrix_term(T) == true</code></a>), <code>collect_matrix_terms</code> will return</p><ol><li>A single <code>MatrixTerm</code> (if all components are matrix terms)</li><li>A tuple of the components (if none of them are matrix terms)</li><li>A tuple of terms, with all matrix terms collected into a single <code>MatrixTerm</code>  in the first element of the tuple, and the remaining non-matrix terms passed  through unchanged.</li></ol><p>By default all terms are matrix terms (that is, <code>is_matrix_term(::Type{&lt;:AbstractTerm}) = true</code>), the first case is by far the most common.  The others are provided only for convenience when dealing with specialized terms that can&#39;t be concatenated into a single model matrix, like random effects terms in <a href="https://github.com/dmbates/MixedModels.jl">MixedModels.jl</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/terms.jl#L253-L274">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.is_matrix_term" href="#StatsModels.is_matrix_term"><code>StatsModels.is_matrix_term</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">is_matrix_term(::Type{&lt;:AbstractTerm})</code></pre><p>Does this type of term get concatenated with other matrix terms into a single model matrix?  This controls the behavior of the <a href="#StatsModels.collect_matrix_terms"><code>collect_matrix_terms</code></a>, which collects all of its arguments for which <code>is_matrix_term</code> returns <code>true</code> into a <a href="#StatsModels.MatrixTerm"><code>MatrixTerm</code></a>, and returns the rest unchanged.</p><p>Since all &quot;normal&quot; terms which describe one or more model matrix columns are matrix terms, this defaults to <code>true</code> for any <code>AbstractTerm</code>.</p><p>An example of a non-matrix term is a random effect term in <a href="https://github.com/dmbates/MixedModels.jl">MixedModels.jl</a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/terms.jl#L291-L304">source</a></section><h2><a class="nav-anchor" id="Schema-1" href="#Schema-1">Schema</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.Schema" href="#StatsModels.Schema"><code>StatsModels.Schema</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">StatsModels.Schema</code></pre><p>Struct that wraps a <code>Dict</code> mapping <code>Term</code>s to their concrete forms.  This exists mainly for dispatch purposes and to support possibly more sophisticated behavior in the future.</p><p>A <code>Schema</code> behaves for all intents and purposes like an immutable <code>Dict</code>, and delegates the constructor as well as <code>getindex</code>, <code>get</code>, <code>merge!</code>, <code>merge</code>, <code>keys</code>, and <code>haskey</code> to the wrapped <code>Dict</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/schema.jl#L24-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.schema" href="#StatsModels.schema"><code>StatsModels.schema</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">schema([terms::AbstractVector{&lt;:AbstractTerm}, ]data, hints::Dict{Symbol})
schema(term::AbstractTerm, data, hints::Dict{Symbol})</code></pre><p>Compute all the invariants necessary to fit a model with <code>terms</code>.  A schema is a dict that maps <code>Term</code>s to their concrete instantiations (either <code>CategoricalTerm</code>s or <code>ContinuousTerm</code>s.  &quot;Hints&quot; may optionally be supplied in the form of a <code>Dict</code> mapping term names (as <code>Symbol</code>s) to term or contrast types.  If a hint is not provided for a variable,  the appropriate term type will be guessed based on the data type from the data column: any numeric data is assumed to be continuous, and any non-numeric data is assumed to be categorical.</p><p>Returns a <a href="#StatsModels.Schema"><code>StatsModels.Schema</code></a>, which is a wrapper around a <code>Dict</code> mapping <code>Term</code>s to their concrete instantiations (<code>ContinuousTerm</code> or <code>CategoricalTerm</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; d = (x=sample([:a, :b, :c], 10), y=rand(10));

julia&gt; ts = [Term(:x), Term(:y)];

julia&gt; schema(ts, d)
StatsModels.Schema with 2 entries:
  y =&gt; y
  x =&gt; x

julia&gt; schema(ts, d, Dict(:x =&gt; HelmertCoding()))
StatsModels.Schema with 2 entries:
  y =&gt; y
  x =&gt; x

julia&gt; schema(term(:y), d, Dict(:y =&gt; CategoricalTerm))
StatsModels.Schema with 1 entry:
  y =&gt; y</code></pre><p>Note that concrete <code>ContinuousTerm</code> and <code>CategoricalTerm</code> and un-typed <code>Term</code>s print the  same in a container, but when printed alone are different:</p><pre><code class="language-julia-repl">julia&gt; sch = schema(ts, d)
StatsModels.Schema with 2 entries:
  y =&gt; y
  x =&gt; x

julia&gt; term(:x)
x(unknown)

julia&gt; sch[term(:x)]
x(DummyCoding:3→2)

julia&gt; sch[term(:y)]
y(continuous)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/schema.jl#L56-L112">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.concrete_term" href="#StatsModels.concrete_term"><code>StatsModels.concrete_term</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">concrete_term(t::Term, data[, hint])</code></pre><p>Create concrete term from the placeholder <code>t</code> based on a data source and optional hint.  If <code>data</code> is a table, the <code>getproperty</code> is used to extract the appropriate column.</p><p>The <code>hint</code> can be a <code>Dict{Symbol}</code> of hints, or a specific hint, a concrete term type (<code>ContinuousTerm</code> or <code>CategoricalTerm</code>), or an instance of some <code>&lt;:AbstractContrasts</code>, in which case a <code>CategoricalTerm</code> will be created using those contrasts.</p><p>If no hint is provided (or <code>hint==nothing</code>), the <code>eltype</code> of the data is used: <code>Number</code>s are assumed to be continuous, and all others are assumed to be categorical.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; concrete_term(term(:a), [1, 2, 3])
a(continuous)

julia&gt; concrete_term(term(:a), [1, 2, 3], nothing)
a(continuous)

julia&gt; concrete_term(term(:a), [1, 2, 3], CategoricalTerm)
a(DummyCoding:3→2)

julia&gt; concrete_term(term(:a), [1, 2, 3], EffectsCoding())
a(EffectsCoding:3→2)

julia&gt; concrete_term(term(:a), [1, 2, 3], Dict(:a=&gt;EffectsCoding()))
a(EffectsCoding:3→2)

julia&gt; concrete_term(term(:a), (a = [1, 2, 3], b = rand(3)))
a(continuous)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/schema.jl#L129-L166">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.apply_schema" href="#StatsModels.apply_schema"><code>StatsModels.apply_schema</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">apply_schema(t, schema::StatsModels.Schema[, Mod::Type = Nothing])</code></pre><p>Return a new term that is the result of applying <code>schema</code> to term <code>t</code> with destination model (type) <code>Mod</code>.  If <code>Mod</code> is omitted, <code>Nothing</code> will be used.</p><p>When <code>t</code> is a <code>ContinuousTerm</code> or <code>CategoricalTerm</code> already, the term will be returned  unchanged <em>unless</em> a matching term is found in the schema.  This allows  selective re-setting of a schema to change the contrast coding or levels of a  categorical term, or to change a continuous term to categorical or vice versa.</p><p>When defining behavior for custom term types, it&#39;s best to dispatch on <a href="#StatsModels.Schema"><code>StatsModels.Schema</code></a> for the second argument.  Leaving it as <code>::Any</code> will work in <em>most</em> cases, but cause method ambiguity in some.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/schema.jl#L193-L207">source</a><div><div><pre><code class="language-none">apply_schema(t::AbstractTerm, schema::StatsModels.FullRank, Mod::Type)</code></pre><p>Apply a schema, under the assumption that when a less-than-full rank model matrix would be produced, categorical terms should be &quot;promoted&quot; to full rank (where a categorical variable with <span>$k$</span> levels would produce <span>$k$</span> columns, instead of <span>$k-1$</span> in the standard contrast coding schemes).  This step is applied automatically when <code>Mod &lt;: StatisticalModel</code>, but other types of models can opt-in by adding a method like</p><pre><code class="language-none">StatsModels.apply_schema(t::FormulaTerm, schema::StatsModels.Schema, Mod::Type{&lt;:MyModelType}) =
    apply_schema(t, StatsModels.FullRank(schema), mod)</code></pre><p>See the section on <a href="../contrasts/#Modeling-categorical-data-1">Modeling categorical data</a> in the docs for more information on how promotion of categorical variables works.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/schema.jl#L284-L301">source</a></section><h2><a class="nav-anchor" id="Modeling-1" href="#Modeling-1">Modeling</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.fit" href="#StatsBase.fit"><code>StatsBase.fit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fit(Mod::Type{&lt;:StatisticalModel}, f::FormulaTerm, data, args...; 
    contrasts::Dict{Symbol}, kwargs...)</code></pre><p>Convert tabular data into a numeric response vector and predictor matrix using the formula <code>f</code>, and then <code>fit</code> the specified model type, wrapping the result in a <a href="#StatsModels.TableRegressionModel"><code>TableRegressionModel</code></a> or <a href="#StatsModels.TableStatisticalModel"><code>TableStatisticalModel</code></a> (as appropriate).</p><p>This is intended as a backstop for modeling packages that implement model types that are subtypes of <code>StatsBase.StatisticalModel</code> but do not explicitly support the full StatsModels terms-based interface.  Currently this works by creating a <a href="#StatsModels.ModelFrame"><code>ModelFrame</code></a> from the formula and data, and then converting this to a <a href="#StatsModels.ModelMatrix"><code>ModelMatrix</code></a>, but this is an internal implementation detail which may change in the near future.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/statsmodel.jl#L99-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.response" href="#StatsBase.response"><code>StatsBase.response</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">response(obj::RegressionModel)</code></pre><p>Return the model response (a.k.a. the dependent variable).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsBase.modelmatrix" href="#StatsBase.modelmatrix"><code>StatsBase.modelmatrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">modelmatrix(obj::RegressionModel)</code></pre><p>Return the model matrix (a.k.a. the design matrix).</p></div></div></section><h3><a class="nav-anchor" id="Traits-1" href="#Traits-1">Traits</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.implicit_intercept" href="#StatsModels.implicit_intercept"><code>StatsModels.implicit_intercept</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">implicit_intercept(T::Type)
implicit_intercept(x::T) = implicit_intercept(T)</code></pre><p>Return <code>true</code> if models of type <code>T</code> should include an implicit intercept even if none is specified in the formula.  Is <code>true</code> by default for all <code>T&lt;:StatisticalModel</code>, and <code>false</code> for others.  To specify that a model type <code>T</code> includes an intercept even if one is not specified explicitly in the formula, overload this function for the corresponding type: <code>implicit_intercept(::Type{&lt;:T}) = true</code></p><p>If a model has an implicit intercept, it can be explicitly excluded by using <code>0</code> in the formula, which generates <a href="#StatsModels.InterceptTerm"><code>InterceptTerm{false}</code></a> with <a href="#StatsModels.apply_schema"><code>apply_schema</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/traits.jl#L3-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.drop_intercept" href="#StatsModels.drop_intercept"><code>StatsModels.drop_intercept</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">drop_intercept(T::Type)
drop_intercept(x::T) = drop_intercept(T)</code></pre><p>Define whether a given model automatically drops the intercept. Return <code>false</code> by default.  To specify that a model type <code>T</code> drops the intercept, overload this function for the  corresponding type: <code>drop_intercept(::Type{&lt;:T}) = true</code></p><p>Models that drop the intercept will be fitted without one: the intercept term will be  removed even if explicitly provided by the user. Categorical variables will be expanded  in the rank-reduced form (contrasts for <code>n</code> levels will only produce <code>n-1</code> columns).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/traits.jl#L22-L33">source</a></section><h3><a class="nav-anchor" id="Wrappers-1" href="#Wrappers-1">Wrappers</a></h3><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p>These are internal implementation details that are likely to change in the near future.  In particular, the <code>ModelFrame</code> and <code>ModelMatrix</code> wrappers are dispreferred in favor of using terms directly, and can in most cases be replaced by something like</p><pre><code class="language-julia"># instead of ModelMatrix(ModelFrame(f::FormulaTerm, data, model=MyModel))
sch = schema(f, data)
f = apply_schema(f, sch, MyModel)
response, predictors = modelcols(f, data)</code></pre></div></div><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.ModelFrame" href="#StatsModels.ModelFrame"><code>StatsModels.ModelFrame</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ModelFrame(formula, data; model=StatisticalModel, contrasts=Dict())</code></pre><p>Wrapper that encapsulates a <code>FormulaTerm</code>, schema, data table, and model type.</p><p>This wrapper encapsulates all the information that&#39;s required to transform data of the same structure as the wrapped data frame into a model matrix (the <code>FormulaTerm</code>), as well as the information about how that formula term was instantiated (the schema and model type)</p><p>Creating a model frame involves first extracting the <a href="#StatsModels.schema"><code>schema</code></a> for the data (using any contrasts provided as hints), and then applying that schema with <a href="#StatsModels.apply_schema"><code>apply_schema</code></a> to the formula in the context of the provided model type.</p><p><strong>Constructors</strong></p><pre><code class="language-julia">ModelFrame(f::FormulaTerm, data; model::Type{M} = StatisticalModel, contrasts::Dict = Dict())</code></pre><p><strong>Fields</strong></p><ul><li><code>f::FormulaTerm</code>: Formula whose left hand side is the <em>response</em> and right hand side are the <em>predictors</em>.</li><li><code>schema::Any</code>: The schema that was applied to generate <code>f</code>.</li><li><code>data::D</code>: The data table being modeled.  The only restriction is that <code>data</code>  is a table (<code>Tables.istable(data) == true</code>)</li><li><code>model::Type{M}</code>: The type of the model that will be fit from this model frame.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; df = (x = 1:4, y = 5:8)
julia&gt; mf = ModelFrame(@formula(y ~ 1 + x), df)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/modelframe.jl#L1-L36">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.ModelMatrix" href="#StatsModels.ModelMatrix"><code>StatsModels.ModelMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">ModelMatrix(mf::ModelFrame)</code></pre><p>Convert a <code>ModelFrame</code> into a numeric matrix suitable for modeling</p><p><strong>Fields</strong></p><ul><li><code>m::AbstractMatrix{&lt;:AbstractFloat}</code>: the generated numeric matrix</li><li><code>assign::Vector{Int}</code> the index of the term corresponding to each column of <code>m</code>.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-julia">ModelMatrix(mf::ModelFrame)
# Specify the type of the resulting matrix (default Matrix{Float64})
ModelMatrix{T &lt;: AbstractMatrix{&lt;:AbstractFloat}}(mf::ModelFrame)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/modelframe.jl#L142-L159">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.TableStatisticalModel" href="#StatsModels.TableStatisticalModel"><code>StatsModels.TableStatisticalModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Wrapper for a <code>StatisticalModel</code> that has been fit from a <code>@formula</code> and tabular data.  </p><p>Most functions from the StatsBase API are simply delegated to the wrapped model, with the exception of functions like <code>fit</code>, <code>predict</code>, and <code>coefnames</code> where the tabular nature of the data means that additional processing is required or information provided by the formula.</p><p><strong>Fields</strong></p><ul><li><code>model::M</code> the wrapped <code>StatisticalModel</code>.</li><li><code>mf::ModelFrame</code> encapsulates the formula, schema, and model type.</li><li><code>mm::ModelMatrix{T}</code> the model matrix that the model was fit from.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/statsmodel.jl#L35-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="StatsModels.TableRegressionModel" href="#StatsModels.TableRegressionModel"><code>StatsModels.TableRegressionModel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Wrapper for a <code>RegressionModel</code> that has been fit from a <code>@formula</code> and tabular data.  </p><p>Most functions from the StatsBase API are simply delegated to the wrapped model, with the exception of functions like <code>fit</code>, <code>predict</code>, and <code>coefnames</code> where the tabular nature of the data means that additional processing is required or information provided by the formula.</p><p><strong>Fields</strong></p><ul><li><code>model::M</code> the wrapped <code>RegressioModel</code>.</li><li><code>mf::ModelFrame</code> encapsulates the formula, schema, and model type.</li><li><code>mm::ModelMatrix{T}</code> the model matrix that the model was fit from.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/0630f46cbf229d7a4481cd6ddbc1ede4d53b170c/src/statsmodel.jl#L55-L68">source</a></section><footer><hr/><a class="previous" href="../temporal_terms/"><span class="direction">Previous</span><span class="title">Temporal variables and Time Series Terms</span></a></footer></article></body></html>
