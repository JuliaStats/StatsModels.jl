<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Modeling tabular data · StatsModels.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">StatsModels.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li class="is-active"><a class="tocitem" href>Modeling tabular data</a><ul class="internal"><li><a class="tocitem" href="#The-@formula-language"><span>The <code>@formula</code> language</span></a></li><li><a class="tocitem" href="#Julia-functions-in-a-@formula"><span>Julia functions in a <code>@formula</code></span></a></li><li><a class="tocitem" href="#Constructing-a-formula-programmatically"><span>Constructing a formula programmatically</span></a></li><li><a class="tocitem" href="#Fitting-a-model-from-a-formula"><span>Fitting a model from a formula</span></a></li></ul></li><li><a class="tocitem" href="../internals/">Internals and extending the <code>@formula</code></a></li><li><a class="tocitem" href="../contrasts/">Contrast coding categorical variables</a></li><li><a class="tocitem" href="../temporal_terms/">Temporal variables and Time Series Terms</a></li><li><a class="tocitem" href="../api/">API documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Modeling tabular data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Modeling tabular data</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaStats/StatsModels.jl/blob/master/docs/src/formula.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Modeling-tabular-data"><a class="docs-heading-anchor" href="#Modeling-tabular-data">Modeling tabular data</a><a id="Modeling-tabular-data-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-tabular-data" title="Permalink"></a></h1><p>Most statistical models require that data be represented as a <code>Matrix</code>-like collection of a single numeric type.  Much of the data we want to model, however, is <strong>tabular data</strong>, where data is represented as a collection of fields with possibly heterogeneous types.  One of the primary goals of <code>StatsModels</code> is to make it simpler to transform tabular data into matrix format suitable for statistical modeling.</p><p>At the moment, &quot;tabular data&quot; means a <a href="https://github.com/JuliaData/Tables.jl">Tables.jl</a> table, which will be materialized as a <code>Tables.ColumnTable</code> (a <code>NamedTuple</code> of column vectors).  Work on first-class support for streaming/row-oriented tables is ongoing.</p><h2 id="The-@formula-language"><a class="docs-heading-anchor" href="#The-@formula-language">The <code>@formula</code> language</a><a id="The-@formula-language-1"></a><a class="docs-heading-anchor-permalink" href="#The-@formula-language" title="Permalink"></a></h2><p>StatsModels implements the <a href="../api/#StatsModels.@formula"><code>@formula</code></a> domain-specific language for describing table-to-matrix transformations.  This language is designed to be familiar to users of other statistical software, while also taking advantage of Julia&#39;s unique strengths to be fast and flexible.</p><p>A basic formula is composed of individual <em>terms</em>—symbols which refer to data columns, or literal numbers <code>0</code> or <code>1</code>—combined by <code>+</code>, <code>&amp;</code>, <code>*</code>, and (at the top level) <code>~</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>@formula</code> macro <strong>must</strong> be called with parentheses to ensure that the formula is parsed properly.</p></div></div><p>Here is an example of the <code>@formula</code> in action:</p><pre><code class="language-julia-repl">julia&gt; using StatsModels, DataFrames

julia&gt; using StableRNGs; rng = StableRNG(1);

julia&gt; f = @formula(y ~ 1 + a + b + c + b&amp;c)
FormulaTerm
Response:
  y(unknown)
Predictors:
  1
  a(unknown)
  b(unknown)
  c(unknown)
  b(unknown) &amp; c(unknown)

julia&gt; df = DataFrame(y = rand(rng, 9), a = 1:9, b = rand(rng, 9), c = repeat([&quot;d&quot;,&quot;e&quot;,&quot;f&quot;], 3))
9×4 DataFrame
 Row │ y          a      b         c
     │ Float64    Int64  Float64   String
─────┼────────────────────────────────────
   1 │ 0.585195       1  0.236782  d
   2 │ 0.0773379      2  0.943741  e
   3 │ 0.716628       3  0.445671  f
   4 │ 0.320357       4  0.763679  d
   5 │ 0.653093       5  0.145071  e
   6 │ 0.236639       6  0.021124  f
   7 │ 0.709684       7  0.152545  d
   8 │ 0.557787       8  0.617492  e
   9 │ 0.05079        9  0.481531  f

julia&gt; f = apply_schema(f, schema(f, df))
FormulaTerm
Response:
  y(continuous)
Predictors:
  1
  a(continuous)
  b(continuous)
  c(DummyCoding:3→2)
  b(continuous) &amp; c(DummyCoding:3→2)

julia&gt; resp, pred = modelcols(f, df);

julia&gt; pred
9×7 Array{Float64,2}:
 1.0  1.0  0.236782  0.0  0.0  0.0       0.0
 1.0  2.0  0.943741  1.0  0.0  0.943741  0.0
 1.0  3.0  0.445671  0.0  1.0  0.0       0.445671
 1.0  4.0  0.763679  0.0  0.0  0.0       0.0
 1.0  5.0  0.145071  1.0  0.0  0.145071  0.0
 1.0  6.0  0.021124  0.0  1.0  0.0       0.021124
 1.0  7.0  0.152545  0.0  0.0  0.0       0.0
 1.0  8.0  0.617492  1.0  0.0  0.617492  0.0
 1.0  9.0  0.481531  0.0  1.0  0.0       0.481531

julia&gt; coefnames(f)
(&quot;y&quot;, [&quot;(Intercept)&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c: e&quot;, &quot;c: f&quot;, &quot;b &amp; c: e&quot;, &quot;b &amp; c: f&quot;])
</code></pre><p>Let&#39;s break down the formula expression <code>y ~ 1 + a + b + c + b&amp;c</code>:</p><p>At the top level is the <strong>formula separator</strong> <code>~</code>, which separates the left-hand (or response) variable <code>y</code> from the right-hand size (or predictor) variables on the right <code>1 + a + b + c + b&amp;c</code>.</p><p>The left-hand side has one term <code>y</code> which means that the response variable is the column from the data named <code>:y</code>.  The response can be accessed with the analogous <code>response(f, df)</code> function.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>To make a &quot;one-sided&quot; formula (with no response), put a <code>0</code> on the left-hand side, like <code>@formula(0 ~ 1 + a + b)</code>.</p></div></div><p>The right hand side is made up of a number of different <strong>terms</strong>, separated by <code>+</code>: <code>1 + a + b + c + b&amp;c</code>.  Each term corresponds to one or more columns in the generated model matrix: </p><ul><li>The first term <code>1</code> generates a constant or &quot;intercept&quot; column full of <code>1.0</code>s.</li><li>The next two terms <code>a</code> and <code>b</code> correspond to columns from the data table called <code>:a</code>, <code>:b</code>, which both hold numeric data (<code>Float64</code> and <code>Int</code> respectively).  By default, numerical columns are assumed to correspond to <strong>continuous terms</strong>, and are converted to <code>Float64</code> and copied to the model matrix.</li><li>The term <code>c</code> corresponds to the <code>:c</code> column in the table, which is <em>not</em> numeric, so it has been <a href="../contrasts/#Modeling-categorical-data">contrast coded</a>: there are three unique values or levels, and the default coding scheme (<a href="../contrasts/#StatsModels.DummyCoding"><code>DummyCoding</code></a>) generates an indicator variable for each level after the first (e.g., <code>df[:c] .== &quot;b&quot;</code> and <code>df[:c] .== &quot;a&quot;</code>).</li><li>The last term <code>b&amp;c</code> is an <strong>interaction term</strong>, and generates model matrix columns for each <em>pair</em> of columns generated by the <code>b</code> and <code>c</code> terms. Columns are combined with element-wise multiplication.  Since <code>b</code> generates only a single column and <code>c</code> two, <code>b&amp;c</code> generates two columns, equivalent to <code>df[:b] .* (df[:c] .== &quot;b&quot;)</code> and <code>df[:b] .* (df[:c] .== &quot;c&quot;)</code>.</li></ul><p>Because we often want to include both &quot;main effects&quot; (<code>b</code> and <code>c</code>) and interactions (<code>b&amp;c</code>) of multiple variables, within a <code>@formula</code> the <code>*</code> operator denotes this &quot;main effects and interactions&quot; operation:</p><pre><code class="language-julia-repl">julia&gt; @formula(y ~ 1 + a + b*c)
FormulaTerm
Response:
  y(unknown)
Predictors:
  1
  a(unknown)
  b(unknown)
  c(unknown)
  b(unknown) &amp; c(unknown)</code></pre><p>Also note that the interaction operators <code>&amp;</code> and <code>*</code> are distributive with the term separator <code>+</code>:</p><pre><code class="language-julia-repl">julia&gt; @formula(y ~ 1 + (a + b) &amp; c)
FormulaTerm
Response:
  y(unknown)
Predictors:
  1
  a(unknown) &amp; c(unknown)
  b(unknown) &amp; c(unknown)</code></pre><h2 id="Julia-functions-in-a-@formula"><a class="docs-heading-anchor" href="#Julia-functions-in-a-@formula">Julia functions in a <code>@formula</code></a><a id="Julia-functions-in-a-@formula-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-functions-in-a-@formula" title="Permalink"></a></h2><p>Any calls to Julia functions that don&#39;t have special meaning (or are part of an <a href="../internals/#Internals-and-extending-the-formula-DSL">extension</a> provided by a modeling package) are treated like normal Julia code, and evaluated elementwise:</p><pre><code class="language-julia-repl">julia&gt; modelmatrix(@formula(y ~ 1 + a + log(1+a)), df)
9×3 Array{Float64,2}:
 1.0  1.0  0.693147
 1.0  2.0  1.09861
 1.0  3.0  1.38629
 1.0  4.0  1.60944
 1.0  5.0  1.79176
 1.0  6.0  1.94591
 1.0  7.0  2.07944
 1.0  8.0  2.19722
 1.0  9.0  2.30259</code></pre><p>Note that the expression <code>1 + a</code> is treated differently as part of the formula than in the call to <code>log</code>, where it&#39;s interpreted as normal addition.</p><p>This even applies to custom functions.  For instance, if for some reason you wanted to include a regressor based on a <code>String</code> column that encoded whether any character in a string was after <code>&#39;e&#39;</code> in the alphabet, you could do</p><pre><code class="language-julia-repl">julia&gt; gt_e(s) = any(c &gt; &#39;e&#39; for c in s)
gt_e (generic function with 1 method)

julia&gt; modelmatrix(@formula(y ~ 1 + gt_e(c)), df)
9×2 Array{Float64,2}:
 1.0  0.0
 1.0  0.0
 1.0  1.0
 1.0  0.0
 1.0  0.0
 1.0  1.0
 1.0  0.0
 1.0  0.0
 1.0  1.0
</code></pre><p>Julia functions like this are evaluated elementwise when the numeric arrays are created for the response and model matrix.  This makes it easy to fit models to transformed data <em>lazily</em>, without creating temporary columns in your table. For instance, to fit a linear regression to a log-transformed response:</p><pre><code class="language-julia-repl">julia&gt; using GLM

julia&gt; lm(@formula(log(y) ~ 1 + a + b), df)
StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}

:(log(y)) ~ 1 + a + b

Coefficients:
──────────────────────────────────────────────────────────────────────────
                  Coef.  Std. Error      t  Pr(&gt;|t|)  Lower 95%  Upper 95%
──────────────────────────────────────────────────────────────────────────
(Intercept)   0.0698025    0.928295   0.08    0.9425  -2.20165    2.34126
a            -0.105669     0.128107  -0.82    0.4410  -0.419136   0.207797
b            -1.63199      1.12678   -1.45    0.1977  -4.38911    1.12513
──────────────────────────────────────────────────────────────────────────

julia&gt; df.log_y = log.(df.y);

julia&gt; lm(@formula(log_y ~ 1 + a + b), df)            # equivalent
StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}

log_y ~ 1 + a + b

Coefficients:
──────────────────────────────────────────────────────────────────────────
                  Coef.  Std. Error      t  Pr(&gt;|t|)  Lower 95%  Upper 95%
──────────────────────────────────────────────────────────────────────────
(Intercept)   0.0698025    0.928295   0.08    0.9425  -2.20165    2.34126
a            -0.105669     0.128107  -0.82    0.4410  -0.419136   0.207797
b            -1.63199      1.12678   -1.45    0.1977  -4.38911    1.12513
──────────────────────────────────────────────────────────────────────────
</code></pre><p>The no-op function <code>identity</code> can be used to block the normal formula-specific interpretation of <code>+</code>, <code>*</code>, and <code>&amp;</code>:</p><pre><code class="language-julia-repl">julia&gt; modelmatrix(@formula(y ~ 1 + b + identity(1+b)), df)
9×3 Array{Float64,2}:
 1.0  0.236782  1.23678
 1.0  0.943741  1.94374
 1.0  0.445671  1.44567
 1.0  0.763679  1.76368
 1.0  0.145071  1.14507
 1.0  0.021124  1.02112
 1.0  0.152545  1.15255
 1.0  0.617492  1.61749
 1.0  0.481531  1.48153</code></pre><h2 id="Constructing-a-formula-programmatically"><a class="docs-heading-anchor" href="#Constructing-a-formula-programmatically">Constructing a formula programmatically</a><a id="Constructing-a-formula-programmatically-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-a-formula-programmatically" title="Permalink"></a></h2><p>A formula can be constructed at runtime by creating <code>Term</code>s and combining them with the formula operators <code>+</code>, <code>&amp;</code>, and <code>~</code>:</p><pre><code class="language-julia-repl">julia&gt; Term(:y) ~ ConstantTerm(1) + Term(:a) + Term(:b) + Term(:a) &amp; Term(:b)
FormulaTerm
Response:
  y(unknown)
Predictors:
  1
  a(unknown)
  b(unknown)
  a(unknown) &amp; b(unknown)</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Even though the <code>@formula</code> macro supports arbitrary julia functions, runtime (programmatic) formula construction does not.  This is because to resolve a symbol giving a function&#39;s <em>name</em> into the actual <em>function</em> itself, it&#39;s necessary to <code>eval</code>.  In practice this is not often an issue, <em>except</em> in cases where a package provides special syntax by overloading a function (like <code>|</code> for <a href="https://github.com/dmbates/MixedModels.jl">MixedModels.jl</a>, or <code>absorb</code> for <a href="https://github.com/Nosferican/Econometrics.jl">Econometrics.jl</a>).  In these cases, you should use the corresponding constructors for the actual terms themselves (e.g., <code>RanefTerm</code> and <code>FixedEffectsTerm</code> respectively), as long as the packages have <a href="../internals/#extend-runtime">implemented support for them</a>.</p></div></div><p>The <a href="../api/#StatsModels.term"><code>term</code></a> function constructs a term of the appropriate type from symbols or strings (<code>Term</code>) and numbers (<code>ConstantTerm</code>), which makes it easy to  work with collections of mixed type:</p><pre><code class="language-julia-repl">julia&gt; ts = term.((1, :a, &quot;b&quot;))
1
a(unknown)
b(unknown)</code></pre><p>These can then be combined with standard reduction techniques:</p><pre><code class="language-julia-repl">julia&gt; f1 = term(:y) ~ foldl(+, ts)
FormulaTerm
Response:
  y(unknown)
Predictors:
  1
  a(unknown)
  b(unknown)

julia&gt; f2 = term(:y) ~ sum(ts)
FormulaTerm
Response:
  y(unknown)
Predictors:
  1
  a(unknown)
  b(unknown)

julia&gt; f1 == f2 == @formula(y ~ 1 + a + b)
true
</code></pre><h2 id="Fitting-a-model-from-a-formula"><a class="docs-heading-anchor" href="#Fitting-a-model-from-a-formula">Fitting a model from a formula</a><a id="Fitting-a-model-from-a-formula-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-a-model-from-a-formula" title="Permalink"></a></h2><p>The main use of <code>@formula</code> is to streamline specifying and fitting statistical models based on tabular data.  From the user&#39;s perspective, this is done by <code>fit</code> methods that take a <code>FormulaTerm</code> and a table instead of numeric matrices.</p><p>As an example, we&#39;ll simulate some data from a linear regression model with an interaction term, a continuous predictor, a categorical predictor, and the interaction of the two, and then fit a <code>GLM.LinearModel</code> to recover the simulated coefficients.</p><pre><code class="language-julia-repl">julia&gt; using GLM, DataFrames, StatsModels

julia&gt; using StableRNGs; rng = StableRNG(1);

julia&gt; data = DataFrame(a = rand(rng, 100), b = repeat([&quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;], 25));

julia&gt; X = StatsModels.modelmatrix(@formula(y ~ 1 + a*b).rhs, data);

julia&gt; β_true = 1:8;

julia&gt; ϵ = randn(rng, 100)*0.1;

julia&gt; data.y = X*β_true .+ ϵ;

julia&gt; mod = fit(LinearModel, @formula(y ~ 1 + a*b), data)
StatsModels.TableRegressionModel{LinearModel{GLM.LmResp{Array{Float64,1}},GLM.DensePredChol{Float64,LinearAlgebra.Cholesky{Float64,Array{Float64,2}}}},Array{Float64,2}}

y ~ 1 + a + b + a &amp; b

Coefficients:
───────────────────────────────────────────────────────────────────────
               Coef.  Std. Error      t  Pr(&gt;|t|)  Lower 95%  Upper 95%
───────────────────────────────────────────────────────────────────────
(Intercept)  1.01518   0.0400546  25.34    &lt;1e-42   0.935626    1.09473
a            1.97476   0.0701427  28.15    &lt;1e-46   1.83545     2.11407
b: e         3.01269   0.0571186  52.74    &lt;1e-69   2.89925     3.12614
b: f         4.01918   0.065827   61.06    &lt;1e-75   3.88844     4.14992
b: g         4.99176   0.0593715  84.08    &lt;1e-88   4.87385     5.10968
a &amp; b: e     5.98288   0.0954641  62.67    &lt;1e-76   5.79328     6.17248
a &amp; b: f     6.98622   0.107871   64.76    &lt;1e-77   6.77197     7.20046
a &amp; b: g     7.92541   0.109873   72.13    &lt;1e-82   7.70719     8.14362
───────────────────────────────────────────────────────────────────────
</code></pre><p>Internally, this is accomplished in three steps:</p><ol><li>The expression passed to <code>@formula</code> is lowered to term constructors combined by <code>~</code>, <code>+</code>, and <code>&amp;</code>, which evaluate to create terms for the whole formula and any interaction terms.</li><li>A schema is extracted from the data, which determines whether each variable is continuous or categorical and extracts the summary statistics of each variable (mean/variance/min/max or unique levels respectively).  This schema is then <em>applied</em> to the formula with <code>apply_schema(term, schema, ::Type{Model})</code>, which returns a new formula with each placeholder <code>Term</code> replaced with a concrete <code>ContinuousTerm</code> or <code>CategoricalTerm</code> as appropriate.  This is also the stage where any custom syntax is applied (see <a href="../internals/#Internals-and-extending-the-formula-DSL">the section on extending the <code>@formula</code> language</a> for more details).</li><li>Numeric arrays are generated for the response and predictors from the full table using <code>modelcols(term, data)</code>.</li></ol><p>The <code>ModelFrame</code> and <code>ModelMatrix</code> types can still be used to do this transformation, but this is only to preserve some backwards compatibility. Package authors who would like to include support for fitting models from a <code>@formula</code> are <strong>strongly</strong> encouraged to directly use <code>schema</code>, <code>apply_schema</code>, and <code>modelcols</code> to handle the table-to-matrix transformations they need.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Introduction</a><a class="docs-footer-nextpage" href="../internals/">Internals and extending the <code>@formula</code> »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 5 August 2022 22:13">Friday 5 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
