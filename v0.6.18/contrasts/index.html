<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Contrast coding categorical variables · StatsModels.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">StatsModels.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../formula/">Modeling tabular data</a></li><li><a class="tocitem" href="../internals/">Internals and extending the <code>@formula</code></a></li><li class="is-active"><a class="tocitem" href>Contrast coding categorical variables</a><ul class="internal"><li><a class="tocitem" href="#How-to-specify-contrast-coding"><span>How to specify contrast coding</span></a></li><li><a class="tocitem" href="#Interface"><span>Interface</span></a></li><li><a class="tocitem" href="#Contrast-coding-systems"><span>Contrast coding systems</span></a></li><li><a class="tocitem" href="#Further-details"><span>Further details</span></a></li></ul></li><li><a class="tocitem" href="../temporal_terms/">Temporal variables and Time Series Terms</a></li><li><a class="tocitem" href="../api/">API documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Contrast coding categorical variables</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Contrast coding categorical variables</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaStats/StatsModels.jl/blob/master/docs/src/contrasts.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Modeling-categorical-data"><a class="docs-heading-anchor" href="#Modeling-categorical-data">Modeling categorical data</a><a id="Modeling-categorical-data-1"></a><a class="docs-heading-anchor-permalink" href="#Modeling-categorical-data" title="Permalink"></a></h1><p>To convert categorical data into a numerical representation suitable for modeling, <code>StatsModels</code> implements a variety of <strong>contrast coding systems</strong>. Each contrast coding system maps a categorical vector with <span>$k$</span> levels onto <span>$k-1$</span> linearly independent model matrix columns.</p><p>The following contrast coding systems are implemented:</p><ul><li><a href="#StatsModels.DummyCoding"><code>DummyCoding</code></a></li><li><a href="#StatsModels.EffectsCoding"><code>EffectsCoding</code></a></li><li><a href="#StatsModels.HelmertCoding"><code>HelmertCoding</code></a></li><li><a href="#StatsModels.HypothesisCoding"><code>HypothesisCoding</code></a></li><li><a href="#StatsModels.SeqDiffCoding"><code>SeqDiffCoding</code></a></li></ul><h2 id="How-to-specify-contrast-coding"><a class="docs-heading-anchor" href="#How-to-specify-contrast-coding">How to specify contrast coding</a><a id="How-to-specify-contrast-coding-1"></a><a class="docs-heading-anchor-permalink" href="#How-to-specify-contrast-coding" title="Permalink"></a></h2><p>The default contrast coding system is <code>DummyCoding</code>.  To override this, use the <code>contrasts</code> argument when constructing a <code>ModelFrame</code>:</p><pre><code class="language-julia">mf = ModelFrame(@formula(y ~ 1 + x), df, contrasts = Dict(:x =&gt; EffectsCoding()))</code></pre><p>To change the contrast coding for one or more variables in place, use</p><article class="docstring"><header><a class="docstring-binding" id="StatsModels.setcontrasts!" href="#StatsModels.setcontrasts!"><code>StatsModels.setcontrasts!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setcontrasts!(mf::ModelFrame; kwargs...)
setcontrasts!(mf::ModelFrame, contrasts::Dict{Symbol})</code></pre><p>Update the contrasts used for coding categorical variables in <a href="../api/#StatsModels.ModelFrame"><code>ModelFrame</code></a> in place.  This is accomplished by computing a new schema based on the provided contrasts and the <code>ModelFrame</code>&#39;s data, and applying it to the <code>ModelFrame</code>&#39;s <code>FormulaTerm</code>.</p><p>Note that only the <code>ModelFrame</code> itself is mutated: because <code>AbstractTerm</code>s are immutable, any changes will produce a copy.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/552e3ba609da8789f8de0c071aeeeeda2529133b/src/modelframe.jl#L152-L164">source</a></section></article><h2 id="Interface"><a class="docs-heading-anchor" href="#Interface">Interface</a><a id="Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Interface" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StatsModels.AbstractContrasts" href="#StatsModels.AbstractContrasts"><code>StatsModels.AbstractContrasts</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Interface to describe contrast coding systems for categorical variables.</p><p>Concrete subtypes of <code>AbstractContrasts</code> describe a particular way of converting a categorical data vector into numeric columns in a <code>ModelMatrix</code>. Each instantiation optionally includes the levels to generate columns for and the base level. If not specified these will be taken from the data when a <code>ContrastsMatrix</code> is generated (during <code>ModelFrame</code> construction).</p><p><strong>Constructors</strong></p><p>For <code>C &lt;: AbstractContrast</code>:</p><pre><code class="language-julia">C()                                     # levels are inferred later
C(levels = ::Vector{Any})               # levels checked against data later
C(base = ::Any)                         # specify base level
C(levels = ::Vector{Any}, base = ::Any) # specify levels and base</code></pre><p><strong>Arguments</strong></p><ul><li><code>levels</code>: Optionally, the data levels can be specified here.  This allows you to specify the order of the levels.  If specified, the levels will be checked against the levels actually present in the data when the <code>ContrastsMatrix</code> is constructed. Any mismatch will result in an error, because levels missing in the data would lead to empty columns in the model matrix, and levels missing from the contrasts would lead to empty or undefined rows.</li><li><code>base</code>: The base level may also be specified.  The actual interpretation of this depends on the particular contrast type, but in general it can be thought of as a &quot;reference&quot; level.  It defaults to the first level.</li></ul><p><strong>Contrast coding systems</strong></p><ul><li><a href="#StatsModels.DummyCoding"><code>DummyCoding</code></a> - Code each non-base level as a 0-1 indicator column.</li><li><a href="#StatsModels.EffectsCoding"><code>EffectsCoding</code></a> - Code each non-base level as 1, and base as -1.</li><li><a href="#StatsModels.HelmertCoding"><code>HelmertCoding</code></a> - Code each non-base level as the difference from the mean of the lower levels</li><li><a href="#StatsModels.SeqDiffCoding"><code>SeqDiffCoding</code></a> - Code for differences between sequential levels of the variable.</li><li><a href="#StatsModels.HypothesisCoding"><code>HypothesisCoding</code></a> - Manually specify contrasts via a hypothesis  matrix, which gives the weighting for the average response for each level</li><li><a href="#StatsModels.ContrastsCoding"><code>StatsModels.ContrastsCoding</code></a> - Manually specify contrasts matrix, which is directly copied into the model matrix.</li></ul><p>The last two coding types, <code>HypothesisCoding</code> and <code>StatsModels.ContrastsCoding</code>, provide a way to manually specify a contrasts matrix. For a variable <code>x</code> with <code>k</code> levels, a contrasts matrix <code>M</code> is a <code>k×k-1</code> matrix, that maps the <code>k</code> levels onto <code>k-1</code> model matrix columns.  Specifically, let <code>X</code> be the full-rank indicator matrix for <code>x</code>, where <code>X[i,j] = 1</code> if <code>x[i] == levels(x)[j]</code>, and 0 otherwise. Then the model matrix columns generated by the contrasts matrix <code>M</code> are <code>Y = X * M</code>.</p><p>The <em>hypothesis matrix</em> is the <code>k-1×k</code> matrix that gives the weighted combinations of group mean responses that are represented by regression coefficients for the generated contrasts.  The contrasts matrix is the generalized pseudo-inverse (e.g. <code>LinearAlgebra.pinv</code>) of the hypothesis matrix. See <a href="#StatsModels.HypothesisCoding"><code>HypothesisCoding</code></a> or Schad et al. (2020) for more information.</p><p><strong>Extending</strong></p><p>The easiest way to specify custom contrasts is with <code>HypothesisCoding</code> or <code>StatsModels.ContrastsCoding</code>.  But if you want to actually implement a custom contrast coding system, you can subtype <code>AbstractContrasts</code>.  This requires a constructor, a <code>contrasts_matrix</code> method for constructing the actual contrasts matrix that maps from levels to <code>ModelMatrix</code> column values, and (optionally) a <code>termnames</code> method:</p><pre><code class="language-julia">mutable struct MyCoding &lt;: AbstractContrasts
    ...
end

contrasts_matrix(C::MyCoding, baseind, n) = ...
termnames(C::MyCoding, levels, baseind) = ...</code></pre><p><strong>References</strong></p><p>Schad, D. J., Vasishth, S., Hohenstein, S., &amp; Kliegl, R. (2020). How to capitalize on a priori contrasts in linear (mixed) models: A tutorial. <em>Journal of Memory and Language, 110</em>, 104038. https://doi.org/10.1016/j.jml.2019.104038</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/552e3ba609da8789f8de0c071aeeeeda2529133b/src/contrasts.jl#L16-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.ContrastsMatrix" href="#StatsModels.ContrastsMatrix"><code>StatsModels.ContrastsMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An instantiation of a contrast coding system for particular levels</p><p>This type is used internally for generating model matrices based on categorical data, and <strong>most users will not need to deal with it directly</strong>.  Conceptually, a <code>ContrastsMatrix</code> object stands for an instantiation of a contrast coding <em>system</em> for a particular set of categorical <em>data levels</em>.</p><p>If levels are specified in the <code>AbstractContrasts</code>, those will be used, and likewise for the base level (which defaults to the first level).</p><p><strong>Constructors</strong></p><pre><code class="language-julia">ContrastsMatrix(contrasts::AbstractContrasts, levels::AbstractVector)
ContrastsMatrix(contrasts_matrix::ContrastsMatrix, levels::AbstractVector)</code></pre><p><strong>Arguments</strong></p><ul><li><code>contrasts::AbstractContrasts</code>: The contrast coding system to use.</li><li><code>levels::AbstractVector</code>: The levels to generate contrasts for.</li><li><code>contrasts_matrix::ContrastsMatrix</code>: Constructing a <code>ContrastsMatrix</code> from another will check that the levels match.  This is used, for example, in constructing a model matrix from a <code>ModelFrame</code> using different data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/552e3ba609da8789f8de0c071aeeeeda2529133b/src/contrasts.jl#L130-L156">source</a></section></article><h2 id="Contrast-coding-systems"><a class="docs-heading-anchor" href="#Contrast-coding-systems">Contrast coding systems</a><a id="Contrast-coding-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Contrast-coding-systems" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="StatsModels.DummyCoding" href="#StatsModels.DummyCoding"><code>StatsModels.DummyCoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DummyCoding([base[, levels]])
DummyCoding(; base=nothing, levels=nothing)</code></pre><p>Dummy coding generates one indicator column (1 or 0) for each non-base level.</p><p>If <code>levels</code> are omitted or <code>nothing</code>, they are determined from the data by calling the <code>levels</code> function on the data when constructing <code>ContrastsMatrix</code>. If <code>base</code> is omitted or <code>nothing</code>, the first level is used as the base.</p><p>Columns have non-zero mean and are collinear with an intercept column (and lower-order columns for interactions) but are orthogonal to each other. In a regression model, dummy coding leads to an intercept that is the mean of the dependent variable for base level.</p><p>Also known as &quot;treatment coding&quot; or &quot;one-hot encoding&quot;.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; StatsModels.ContrastsMatrix(DummyCoding(), [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]).matrix
4×3 Array{Float64,2}:
 0.0  0.0  0.0
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/552e3ba609da8789f8de0c071aeeeeda2529133b/src/contrasts.jl#L288-L315">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.EffectsCoding" href="#StatsModels.EffectsCoding"><code>StatsModels.EffectsCoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">EffectsCoding([base[, levels]])
EffectsCoding(; base=nothing, levels=nothing)</code></pre><p>Effects coding generates columns that code each non-base level as the deviation from the base level.  For each non-base level <code>x</code> of <code>variable</code>, a column is generated with 1 where <code>variable .== x</code> and -1 where <code>variable .== base</code>.</p><p><code>EffectsCoding</code> is like <code>DummyCoding</code>, but using -1 for the base level instead of 0.</p><p>If <code>levels</code> are omitted or <code>nothing</code>, they are determined from the data by calling the <code>levels</code> function when constructing <code>ContrastsMatrix</code>.  If <code>base</code> is omitted or <code>nothing</code>, the first level is used as the base.</p><p>When all levels are equally frequent, effects coding generates model matrix columns that are mean centered (have mean 0).  For more than two levels the generated columns are not orthogonal.  In a regression model with an effects-coded variable, the intercept corresponds to the grand mean.</p><p>Also known as &quot;sum coding&quot; or &quot;simple coding&quot;. Note though that the default in R and SPSS is to use the <em>last</em> level as the base. Here we use the <em>first</em> level as the base, for consistency with other coding systems.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; StatsModels.ContrastsMatrix(EffectsCoding(), [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]).matrix
4×3 Array{Float64,2}:
 -1.0  -1.0  -1.0
  1.0   0.0   0.0
  0.0   1.0   0.0
  0.0   0.0   1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/552e3ba609da8789f8de0c071aeeeeda2529133b/src/contrasts.jl#L322-L358">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.HelmertCoding" href="#StatsModels.HelmertCoding"><code>StatsModels.HelmertCoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HelmertCoding([base[, levels]])
HelmertCoding(; base=nothing, levels=nothing)</code></pre><p>Helmert coding codes each level as the difference from the average of the lower levels.</p><p>If <code>levels</code> are omitted or <code>nothing</code>, they are determined from the data by calling the <code>levels</code> function when constructing <code>Contrastsmatrix</code>.  If <code>base</code> is omitted or <code>nothing</code>, the first level is used as the base. For each non-base level, Helmert coding generates a columns with -1 for each of n levels below, n for that level, and 0 above.</p><p>When all levels are equally frequent, Helmert coding generates columns that are mean-centered (mean 0) and orthogonal.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; StatsModels.ContrastsMatrix(HelmertCoding(), [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]).matrix
4×3 Array{Float64,2}:
 -1.0  -1.0  -1.0
  1.0  -1.0  -1.0
  0.0   2.0  -1.0
  0.0   0.0   3.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/552e3ba609da8789f8de0c071aeeeeda2529133b/src/contrasts.jl#L368-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.SeqDiffCoding" href="#StatsModels.SeqDiffCoding"><code>StatsModels.SeqDiffCoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SeqDiffCoding([base[, levels]])</code></pre><p>Code each level in order to test &quot;sequential difference&quot; hypotheses, which compares each level to the level below it (starting with the second level). Specifically, the <span>$n$</span>th predictor tests the hypothesis that the difference between levels <span>$n$</span> and <span>$n+1$</span> is zero.</p><p>Differences are computed in order of <code>levels</code>.  If <code>levels</code> are omitted or <code>nothing</code>, they are determined from the data by calling the <code>levels</code> function when constructing <code>ContrastsMatrix</code>. If <code>base</code> is omitted or <code>nothing</code>, the first level is used as the base.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; seqdiff = StatsModels.ContrastsMatrix(SeqDiffCoding(), [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]).matrix
4×3 Array{Float64,2}:
 -0.75  -0.5  -0.25
  0.25  -0.5  -0.25
  0.25   0.5  -0.25
  0.25   0.5   0.75</code></pre><p>The interpretation of sequential difference coding may be hard to see from the contrasts matrix itself.  The corresponding hypothesis matrix shows a clearer picture.  From the rows of the hypothesis matrix, we can see that these contrasts test the difference between the first and second levels, the second and third, and the third and fourth, respectively:</p><pre><code class="language-julia-repl">julia&gt; StatsModels.hypothesis_matrix(seqdiff)
3×4 Array{Int64,2}:
 -1   1   0  0
  0  -1   1  0
  0   0  -1  1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/552e3ba609da8789f8de0c071aeeeeda2529133b/src/contrasts.jl#L409-L447">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.HypothesisCoding" href="#StatsModels.HypothesisCoding"><code>StatsModels.HypothesisCoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">HypothesisCoding(hypotheses::AbstractMatrix; levels=nothing, labels=nothing)</code></pre><p>Specify how to code a categorical variable in terms of a <em>hypothesis matrix</em>. For a variable with <span>$k$</span> levels, this should be a <span>$k-1 	imes k$</span> matrix. Each row of the matrix corresponds to a hypothesis about the mean outcomes under each of the <span>$k$</span> levels of the predictor.  The entries in the row give the weights assigned to each of these <span>$k$</span> means, and the corresponding predictor in a regression model estimates the weighted sum of these cell means.</p><p>For instance, if we have a variable which has four levels A, B, C, and D, and we want to test the hypothesis that the difference between the average outcomes for levels A and B is different from zero, the corresponding row of the hypothesis matrix would be <code>[-1, 1, 0, 0]</code>.  Likewise, to test whether the difference between B and C is different from zero, the hypothesis vector would be <code>[0, -1, 1, 0]</code>.  To test each &quot;successive difference&quot; hypothesis, the full hypothesis matrix would be</p><pre><code class="language-julia-repl">julia&gt; sdiff_hypothesis = [-1  1  0  0
                            0 -1  1  0
                            0  0 -1  1];</code></pre><p>Contrasts are derived the hypothesis matrix by taking the pseudoinverse:</p><pre><code class="language-julia-repl">julia&gt; using LinearAlgebra

julia&gt; sdiff_contrasts = pinv(sdiff_hypothesis)
4×3 Array{Float64,2}:
 -0.75  -0.5  -0.25
  0.25  -0.5  -0.25
  0.25   0.5  -0.25
  0.25   0.5   0.75</code></pre><p>The above matrix is what is produced by constructing a <a href="#StatsModels.ContrastsMatrix"><code>ContrastsMatrix</code></a> from a <code>HypothesisCoding</code> instance:</p><pre><code class="language-julia-repl">julia&gt; StatsModels.ContrastsMatrix(HypothesisCoding(sdiff_hypothesis), [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]).matrix
4×3 Array{Float64,2}:
 -0.75  -0.5  -0.25
  0.25  -0.5  -0.25
  0.25   0.5  -0.25
  0.25   0.5   0.75</code></pre><p>The interpretation of the such &quot;sequential difference&quot; contrasts are clear when expressed as a hypothesis matrix, but it is not obvious just from looking at the contrasts matrix.  For this reason <code>HypothesisCoding</code> is preferred for specifying custom contrast coding schemes over <code>ContrastsCoding</code>.</p><p>Optional arguments <code>levels</code> and <code>labels</code> give the names (in order) of the hypothesis matrix columns (corresponding to levels of the data) and rows (corresponding to the tested hypothesis).  The <code>labels</code> also determine the names of the model matrix columns generated by these contrasts.</p><p><strong>References</strong></p><p>Schad, D. J., Vasishth, S., Hohenstein, S., &amp; Kliegl, R. (2020). How to capitalize on a priori contrasts in linear (mixed) models: A tutorial. <em>Journal of Memory and Language, 110</em>, 104038. https://doi.org/10.1016/j.jml.2019.104038</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/552e3ba609da8789f8de0c071aeeeeda2529133b/src/contrasts.jl#L463-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.hypothesis_matrix" href="#StatsModels.hypothesis_matrix"><code>StatsModels.hypothesis_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hypothesis_matrix(cmat::AbstractMatrix; intercept=needs_intercept(cm), tolerance=1e-5)
hypothesis_matrix(contrasts::AbstractContrasts, n; baseind=1, kwargs...)
hypothesis_matrix(cmat::ContrastsMatrix; kwargs...)</code></pre><p>Compute the hypothesis matrix for a contrasts matrix using the generalized pseudo-inverse (<code>LinearAlgebra.pinv</code>).  <code>intercept</code> determines whether a column of ones is included before taking the pseudoinverse, which is needed for contrasts where the columns are not orthogonal to the intercept (e.g., have non-zero mean).  If <code>tolerance != 0</code> (the default), the hypotheses are rounded to <code>Int</code>s if possible and <code>Rational</code>s if not, using the given tolerance.  If <code>tolerance == 0</code>, then the hypothesis matrix is returned as-is.</p><p>The orientation of the hypothesis matrix is <em>opposite</em> that of the contrast matrix: each row of the contrasts matrix is a data level and each column is a predictor, whereas each row of the hypothesis matrix is the interpretation of a predictor with weights for each level given in the columns.</p><p>Note that this assumes a <em>balanced design</em> where there are the same number of observations in every cell.  This is only important for non-orthgonal contrasts (including contrasts that are not orthogonal with the intercept).</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cmat = StatsModels.contrasts_matrix(DummyCoding(), 1, 4)
4×3 Array{Float64,2}:
 0.0  0.0  0.0
 1.0  0.0  0.0
 0.0  1.0  0.0
 0.0  0.0  1.0

julia&gt; StatsModels.hypothesis_matrix(cmat)
4×4 Array{Int64,2}:
  1  0  0  0
 -1  1  0  0
 -1  0  1  0
 -1  0  0  1</code></pre><p>For non-centered contrasts like <code>DummyCoding</code>, without including the intercept  the hypothesis matrix is incorrect.  So while <code>intercept=true</code> is the default for  non-centered contrasts, you can see the (wrong) hypothesis matrix when ignoring  it by forcing <code>intercept=false</code>:</p><pre><code class="language-julia-repl">julia&gt; StatsModels.hypothesis_matrix(cmat, intercept=false)
3×4 Array{Int64,2}:
 0  1  0  0
 0  0  1  0
 0  0  0  1</code></pre><p>The default behavior is to coerce to the nearest integer or rational value, with a tolerance of the <code>tolerance</code> kwarg (defaults to <code>1e-5</code>).  The raw pseudo-inverse matrix can be obtained as <code>Float64</code> by setting <code>tolerance=0</code>:</p><pre><code class="language-julia-repl">julia&gt; StatsModels.hypothesis_matrix(cmat, tolerance=0) # ugly
4×4 Array{Float64,2}:
  1.0  -2.23753e-16   6.91749e-18  -1.31485e-16
 -1.0   1.0          -2.42066e-16   9.93754e-17
 -1.0   4.94472e-17   1.0           9.93754e-17
 -1.0   1.04958e-16  -1.31044e-16   1.0        </code></pre><p>Finally, the hypothesis matrix for a constructed <code>ContrastsMatrix</code> (as stored by <code>CategoricalTerm</code>s) can also be extracted:</p><pre><code class="language-julia-repl">julia&gt; StatsModels.hypothesis_matrix(StatsModels.ContrastsMatrix(DummyCoding(), [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]))
4×4 Array{Int64,2}:
  1  0  0  0
 -1  1  0  0
 -1  0  1  0
 -1  0  0  1
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/552e3ba609da8789f8de0c071aeeeeda2529133b/src/contrasts.jl#L652-L730">source</a></section></article><h3 id="Special-internal-contrasts"><a class="docs-heading-anchor" href="#Special-internal-contrasts">Special internal contrasts</a><a id="Special-internal-contrasts-1"></a><a class="docs-heading-anchor-permalink" href="#Special-internal-contrasts" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="StatsModels.FullDummyCoding" href="#StatsModels.FullDummyCoding"><code>StatsModels.FullDummyCoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FullDummyCoding()</code></pre><p>Full-rank dummy coding generates one indicator (1 or 0) column for each level, <strong>including</strong> the base level. This is sometimes known as  <a href="https://en.wikipedia.org/wiki/One-hot">one-hot encoding</a>.</p><p>Not exported but included here for the sake of completeness. Needed internally for some situations where a categorical variable with <span>$k$</span> levels needs to be converted into <span>$k$</span> model matrix columns instead of the standard <span>$k-1$</span>.  This occurs when there are missing lower-order terms, as in discussed below in <a href="#Categorical-variables-in-Formulas">Categorical variables in Formulas</a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; StatsModels.ContrastsMatrix(StatsModels.FullDummyCoding(), [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]).matrix
4×4 Array{Float64,2}:
 1.0  0.0  0.0  0.0
 0.0  1.0  0.0  0.0
 0.0  0.0  1.0  0.0
 0.0  0.0  0.0  1.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/552e3ba609da8789f8de0c071aeeeeda2529133b/src/contrasts.jl#L253-L276">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsModels.ContrastsCoding" href="#StatsModels.ContrastsCoding"><code>StatsModels.ContrastsCoding</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StatsModels.ContrastsCoding(mat::AbstractMatrix[, levels]])
StatsModels.ContrastsCoding(mat::AbstractMatrix[; levels=nothing])</code></pre><p>Coding by manual specification of contrasts matrix. For k levels, the contrasts must be a k by k-1 Matrix.  The contrasts in this matrix will be copied directly into the model matrix; if you want to specify your contrasts as hypotheses (i.e.,  weights assigned to each level&#39;s cell mean), you should use  <a href="#StatsModels.HypothesisCoding"><code>HypothesisCoding</code></a> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaStats/StatsModels.jl/blob/552e3ba609da8789f8de0c071aeeeeda2529133b/src/contrasts.jl#L595-L604">source</a></section></article><h2 id="Further-details"><a class="docs-heading-anchor" href="#Further-details">Further details</a><a id="Further-details-1"></a><a class="docs-heading-anchor-permalink" href="#Further-details" title="Permalink"></a></h2><h3 id="Categorical-variables-in-Formulas"><a class="docs-heading-anchor" href="#Categorical-variables-in-Formulas">Categorical variables in <code>Formula</code>s</a><a id="Categorical-variables-in-Formulas-1"></a><a class="docs-heading-anchor-permalink" href="#Categorical-variables-in-Formulas" title="Permalink"></a></h3><p>Generating model matrices from multiple variables, some of which are categorical, requires special care.  The reason for this is that rank-<span>$k-1$</span> contrasts are appropriate for a categorical variable with <span>$k$</span> levels when it <em>aliases</em> other terms, making it <em>partially redundant</em>.  Using rank-<span>$k$</span> for such a redundant variable will generally result in a rank-deficient model matrix and a model that can&#39;t be identified.</p><p>A categorical variable in a term <em>aliases</em> the term that remains when that variable is dropped.  For example, with categorical <code>a</code>:</p><ul><li>In <code>a</code>, the sole variable <code>a</code> aliases the intercept term <code>1</code>.</li><li>In <code>a&amp;b</code>, the variable <code>a</code> aliases the main effect term <code>b</code>, and vice versa.</li><li>In <code>a&amp;b&amp;c</code>, the variable <code>a</code> alises the interaction term <code>b&amp;c</code> (regardless of whether <code>b</code> and <code>c</code> are categorical).</li></ul><p>If a categorical variable aliases another term that is present elsewhere in the formula, we call that variable <em>redundant</em>.  A variable is <em>non-redundant</em> when the term that it alises is <em>not</em> present elsewhere in the formula.  For categorical <code>a</code>, <code>b</code>, and <code>c</code>:</p><ul><li>In <code>y ~ 1 + a</code>, the <code>a</code> in the main effect of <code>a</code> aliases the intercept <code>1</code>.</li><li>In <code>y ~ 0 + a</code>, <code>a</code> does not alias any other terms and is <em>non-redundant</em>.</li><li>In <code>y ~ 1 + a + a&amp;b</code>:<ul><li>The <code>b</code> in <code>a&amp;b</code> is redundant because it aliases the main effect <code>a</code>: dropping <code>b</code> from <code>a&amp;b</code> leaves <code>a</code>.</li><li>The <code>a</code> in <code>a&amp;b</code> is <em>non-redundant</em> because it aliases <code>b</code>, which is not present anywhere else in the formula.</li></ul></li></ul><p>When constructing a <code>ModelFrame</code> from a <code>Formula</code>, each term is checked for non-redundant categorical variables.  Any such non-redundant variables are &quot;promoted&quot; to full rank in that term by using <a href="#StatsModels.FullDummyCoding"><code>FullDummyCoding</code></a> instead of the contrasts used elsewhere for that variable.</p><p>One additional complexity is introduced by promoting non-redundant variables to full rank.  For the purpose of determining redundancy, a full-rank dummy coded categorical variable <em>implicitly</em> introduces the term that it aliases into the formula.  Thus, in <code>y ~ 1 + a + a&amp;b + b&amp;c</code>:</p><ul><li>In <code>a&amp;b</code>, <code>a</code> aliases the main effect <code>b</code>, which is not explicitly present in the formula.  This makes it non-redundant and so its contrast coding is promoted to <code>FullDummyCoding</code>, which <em>implicitly</em> introduces the main effect of <code>b</code>.</li><li>Then, in <code>b&amp;c</code>, the variable <code>c</code> is now <em>redundant</em> because it aliases the main effect of <code>b</code>, and so it keeps its original contrast coding system.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../internals/">« Internals and extending the <code>@formula</code></a><a class="docs-footer-nextpage" href="../temporal_terms/">Temporal variables and Time Series Terms »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 6 January 2021 15:36">Wednesday 6 January 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
